### Проблема и требование:
1. **PAYMENT_OBJECT и SSR_ARTICLE** – оба требуют условного маппинга.
2. Поле `code` для **SSR_ARTICLE** находится внутри `LinkedHashSet` в родительской сущности.
3. Нам нужно эффективно доставать **code** и маппить соответствующие структуры **при наличии конкретных кодов** из `fields`.

---

### Подход к решению:
1. **PAYMENT_OBJECT**: Проверяем наличие `PaymentObjectEntity` и маппим его, используя вложенные мапперы.
2. **SSR_ARTICLE**: Проходим по `LinkedHashSet` в родительской сущности, фильтруем элементы на основе кода и маппим только при условии.

---

## Оптимизированный Маппер для `PAYMENT_OBJECT` и `SSR_ARTICLE`

### 1. **PFLoanFundsRqPaymentObjectMapper**: Маппинг `PAYMENT_OBJECT`

```java
@Mapper(config = MainMapperConfig.class, uses = PFLoanFundsRqPaymentObjectSsrMapper.class)
public interface PFLoanFundsRqPaymentObjectMapper {

    @Mapping(target = "name", source = "name")
    @Mapping(target = "projectName", source = "projectName")
    PaymentObjectEntityBo entityToBo(PaymentObjectEntity entity);

    // Условный маппинг для PAYMENT_OBJECT
    default PaymentObjectEntityBo mapPaymentObjectConditionally(@MappingTarget PaymentObjectEntityBo bo,
                                                                PaymentObjectEntity entity,
                                                                @Context List<RegistryCodes> fields) {
        if (entity.getPaymentObjectSsr() != null && fields.contains(RegistryCodes.SSR_ARTICLE)) {
            bo.setPaymentObjectSsr(
                paymentObjectSsrMapper.mapPaymentObjectConditionally(
                    entity.getPaymentObjectSsr(), fields
                )
            );
        } else {
            bo.setPaymentObjectSsr(null);
        }
        return bo;
    }
}
```

---

### 2. **PFLoanFundsRqPaymentObjectSsrMapper**: Маппинг `SSR_ARTICLE`

```java
@Mapper(config = MainMapperConfig.class, uses = PFLoanFundsRqPaymentSsrArticleMapper.class)
public interface PFLoanFundsRqPaymentObjectSsrMapper {

    @Mapping(target = "paymentSsrArticles", ignore = true)
    PaymentObjectSsrEntityBo entityToBo(PaymentObjectSsrEntity entity);

    // Условный маппинг для SSR_ARTICLE
    default PaymentObjectSsrEntityBo mapPaymentObjectConditionally(PaymentObjectSsrEntity entity,
                                                                   @Context List<RegistryCodes> fields) {
        var bo = entityToBo(entity);

        if (entity.getPaymentSsrArticles() != null && fields.contains(RegistryCodes.SSR_ARTICLE)) {
            bo.setPaymentSsrArticles(
                entity.getPaymentSsrArticles().stream()
                      .filter(article -> article.getCode() != null)
                      .map(article -> paymentSsrArticleMapper.entityToBo(article))
                      .collect(Collectors.toCollection(LinkedHashSet::new))
            );
        } else {
            bo.setPaymentSsrArticles(null);
        }
        return bo;
    }
}
```

---

### 3. **PFLoanFundsRqPaymentSsrArticleMapper**: Маппинг для статей (`code`)

```java
@Mapper(config = MainMapperConfig.class)
public interface PFLoanFundsRqPaymentSsrArticleMapper {

    @Mapping(target = "code", source = "code")
    PaymentSsrArticleEntityBo entityToBo(PaymentSsrArticleEntity entity);

    default void mapSsrArticleCodeConditionally(@MappingTarget PaymentSsrArticleEntityBo bo,
                                                PaymentSsrArticleEntity entity,
                                                @Context List<RegistryCodes> fields) {
        if (entity.getCode() != null && fields.contains(RegistryCodes.SSR_ARTICLE)) {
            bo.setCode(entity.getCode());
        } else {
            bo.setCode(null);
        }
    }
}
```

---

### 4. **PAYMENT_ANALYTIC Маппер**: Главный маппер

```java
@Mapper(config = MainMapperConfig.class, uses = PFLoanFundsRqPaymentObjectMapper.class)
public interface PFLoanFundsRqPaymentAnalyticMapper {

    @Mapping(target = "id", source = "id")
    @Mapping(target = "clientId", source = "clientId")
    @Mapping(target = "paymentObjects", ignore = true)
    PaymentAnalyticDto entityToBo(PaymentAnalyticEntity entity);

    default PaymentAnalyticDto mapFieldsConditionally(@MappingTarget PaymentAnalyticDto dto,
                                                      PaymentAnalyticEntity entity,
                                                      @Context List<RegistryCodes> fields) {
        if (fields.contains(RegistryCodes.PAYMENT_OBJECT)) {
            dto.setPaymentObjects(entity.getPaymentObjects().stream()
                    .map(object -> paymentObjectMapper.mapPaymentObjectConditionally(
                            new PaymentObjectEntityBo(), object, fields
                    ))
                    .collect(Collectors.toCollection(LinkedHashSet::new))
            );
        }
        return dto;
    }
}
```

---

### Объяснение:
1. **Мапперы вложенных объектов**:
   - Используют `@Context List<RegistryCodes>` для проверки наличия кода.
   - Поле `code` маппится только если условие выполнено.

2. **Фильтрация `SSR_ARTICLE`**:
   - Проверяется `LinkedHashSet` на наличие элементов с `code`.
   - Маппятся только подходящие элементы.

3. **Главный маппер**:
   - Отвечает за вызов **`PAYMENT_OBJECT`** и вложенных мапперов.

---

### Пример вызова:

```java
@Autowired
private PFLoanFundsRqPaymentAnalyticMapper mapper;

public void exampleUsage() {
    var entity = new PaymentAnalyticEntity(); // Создаём сущность
    var fields = List.of(RegistryCodes.PAYMENT_OBJECT, RegistryCodes.SSR_ARTICLE);

    PaymentAnalyticDto dto = mapper.mapFieldsConditionally(new PaymentAnalyticDto(), entity, fields);

    System.out.println(dto);
}
```

---

### Итог:
1. **Маппинг с условной логикой** реализован через `@Context` и `default` методы.
2. **PAYMENT_OBJECT** и **SSR_ARTICLE** обрабатываются только при наличии кодов в `fields`.
3. **LinkedHashSet** обрабатывается с фильтрацией и передачей значений в дочерние мапперы.
4. Все мапперы связаны друг с другом с помощью **`uses`**.


default PaymentAnalyticDto toDtoWithFields(PaymentAnalyticEntity entity, Set<String> fields) {
    PaymentAnalyticDto dto = new PaymentAnalyticDto();

    for (String field : fields) {
        switch (field) {
            case "id" -> dto.setId(entity.getId());
            case "clientId" -> dto.setClientId(entity.getClientId());
            case "paymentOrderId" -> dto.setPaymentDocumentId(entity.getPaymentDocumentId());
            case "NUMBER" -> dto.setNumber(entity.getNumber());
            case "LOAN_FUNDS_REQUEST_STATUS" -> dto.setStatus(entity.getStatus());
            case "DATE" -> dto.setDate(entity.getDate());
            case "FUNDS_TYPE" -> dto.setFundsType(entity.getFundsType());
            case "CREDIT_AGREEMENT" -> {
                dto.setCreditAgreementNumber(entity.getCreditAgreementNumber());
                dto.setCreditAgreementDate(entity.getCreditAgreementDate());
            }
            case "PAYER_ACCOUNT" -> {
                dto.setPayerAccount(entity.getPayerAccount());
                dto.setObcAccountFlag(entity.getObcAccountFlag());
            }
            case "TRANCHE_ISSUE_DATE" -> dto.setTrancheIssueDate(entity.getTrancheIssueDate());
            case "AMOUNT" -> dto.setAmount(entity.getAmount());
            case "PAYMENT_PURPOSE" -> dto.setPaymentPurpose(entity.getPaymentPurpose());
            case "RECIPIENT_NAME" -> dto.setRecipientName(entity.getRecipientName());
            case "RECIPIENT_ACCOUNT" -> dto.setRecipientAccount(entity.getRecipientAccount());
            case "DVRU" -> {
                dto.setDvruNumber(entity.getDvruNumber());
                dto.setDvruDate(entity.getDvruDate());
            }
            case "PAYMENT_TYPE" -> dto.setPaymentType(entity.getPaymentType());
            case "PAYMENT_OBJECT" -> {
                if (entity.getPaymentObjects() != null) {
                    dto.setPaymentObjects(entity.getPaymentObjects().stream()
                            .map(this::mapPaymentObject)
                            .collect(Collectors.toSet()));
                }
            }
            case "SSR_ARTICLE" -> {
                if (entity.getPaymentObjects() != null) {
                    dto.setPaymentObjects(entity.getPaymentObjects().stream()
                            .map(paymentObject -> new PaymentAnalyticDto.PaymentObjectEntityDto(
                                    paymentObject.getName(),
                                    paymentObject.getProjectName(),
                                    mapPaymentObjectSsr(paymentObject.getPaymentObjectSsr())
                            )).collect(Collectors.toSet()));
                }
            }
        }
    }

    return dto;
}


Чтобы маппить **связанные сущности** из вашей модели `PaymentAnalyticDto` и `PaymentAnalyticEntity`, можно использовать **MapStruct** с маппингом вложенных объектов и коллекций.

---

## Полный пример маппинга с вложенными сущностями

### 1. **Конфигурация MapStruct**

Создаем конфигурацию для общего использования в мапперах:

```java
import org.mapstruct.MapperConfig;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.CollectionMappingStrategy;

@MapperConfig(
    unmappedTargetPolicy = ReportingPolicy.IGNORE, // Игнорировать не замапленные поля
    collectionMappingStrategy = CollectionMappingStrategy.ACCESSOR_ONLY, // Коллекции маппятся через геттеры/сеттеры
    componentModel = "spring"
)
public interface MainMapperConfig {
}
```

---

### 2. **Создание мапперов для вложенных объектов**

1. **Mapper для `PaymentSsrArticleDto`**:

```java
import org.mapstruct.Mapper;

@Mapper(config = MainMapperConfig.class)
public interface PaymentSsrArticleMapper {
    PaymentAnalyticDto.PaymentSsrArticleDto toDto(PaymentSsrArticleEntity entity);
}
```

2. **Mapper для `PaymentObjectSsrEntityDto`**:

```java
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(config = MainMapperConfig.class, uses = PaymentSsrArticleMapper.class)
public interface PaymentObjectSsrMapper {
    @Mapping(target = "paymentSsrArticles", source = "paymentSsrArticles")
    PaymentAnalyticDto.PaymentObjectSsrEntityDto toDto(PaymentObjectSsrEntity entity);
}
```

3. **Mapper для `PaymentObjectEntityDto`**:

```java
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(config = MainMapperConfig.class, uses = PaymentObjectSsrMapper.class)
public interface PaymentObjectMapper {
    @Mapping(target = "name", source = "name")
    @Mapping(target = "projectName", source = "projectName")
    @Mapping(target = "paymentObjectSsr", source = "paymentObjectSsr")
    PaymentAnalyticDto.PaymentObjectEntityDto toDto(PaymentObjectEntity entity);
}
```

---

### 3. **Главный маппер для `PaymentAnalyticDto`**

Главный маппер использует вложенные мапперы:

```java
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;

@Mapper(config = MainMapperConfig.class, uses = PaymentObjectMapper.class)
public interface PaymentAnalyticMapper {

    @Mappings({
        @Mapping(target = "id", source = "id"),
        @Mapping(target = "clientId", source = "clientId"),
        @Mapping(target = "paymentDocumentId", source = "paymentDocumentId"),
        @Mapping(target = "number", source = "number"),
        @Mapping(target = "status", source = "status"),
        @Mapping(target = "date", source = "date"),
        @Mapping(target = "fundsType", source = "fundsType"),
        @Mapping(target = "creditAgreementNumber", source = "creditAgreementNumber"),
        @Mapping(target = "creditAgreementDate", source = "creditAgreementDate"),
        @Mapping(target = "payerAccount", source = "payerAccount"),
        @Mapping(target = "obcAccountFlag", source = "obcAccountFlag"),
        @Mapping(target = "trancheIssueDate", source = "trancheIssueDate"),
        @Mapping(target = "amount", source = "amount"),
        @Mapping(target = "paymentPurpose", source = "paymentPurpose"),
        @Mapping(target = "recipientName", source = "recipientName"),
        @Mapping(target = "recipientAccount", source = "recipientAccount"),
        @Mapping(target = "dvruNumber", source = "dvruNumber"),
        @Mapping(target = "dvruDate", source = "dvruDate"),
        @Mapping(target = "paymentType", source = "paymentType"),
        @Mapping(target = "paymentObjects", source = "paymentObjects")
    })
    PaymentAnalyticDto toDto(PaymentAnalyticEntity entity);
}
```

---

### 4. **Пример сущностей**

```java
public class PaymentAnalyticEntity {
    private UUID id;
    private UUID clientId;
    private UUID paymentDocumentId;
    private Integer number;
    private PaymentAnalyticStatusEnum status;
    private LocalDate date;
    private FundsType fundsType;
    private String creditAgreementNumber;
    private LocalDate creditAgreementDate;
    private String payerAccount;
    private Boolean obcAccountFlag;
    private LocalDate trancheIssueDate;
    private BigDecimal amount;
    private String paymentPurpose;
    private String recipientName;
    private String recipientAccount;
    private String dvruNumber;
    private LocalDate dvruDate;
    private PaymentType paymentType;
    private Set<PaymentObjectEntity> paymentObjects;
}

public class PaymentObjectEntity {
    private String name;
    private String projectName;
    private PaymentObjectSsrEntity paymentObjectSsr;
}

public class PaymentObjectSsrEntity {
    private Set<PaymentSsrArticleEntity> paymentSsrArticles;
}

public class PaymentSsrArticleEntity {
    private String code;
}
```

---

### 5. **Использование мапперов**

**Пример вызова:**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class PaymentAnalyticService {

    @Autowired
    private PaymentAnalyticMapper mapper;

    public PaymentAnalyticDto mapToDto(PaymentAnalyticEntity entity) {
        return mapper.toDto(entity);
    }
}
```

---

## Результат

- **Главный маппер** `PaymentAnalyticMapper` вызывает вложенные мапперы для связанных сущностей.
- **MapStruct** автоматически обрабатывает коллекции и вложенные связи.
- Связанные сущности маппятся в **DTO**, сохраняя структуру и вложенность.

@Query(value = "SELECT DISTINCT p " +
               "FROM PaymentAnalyticEntity p " +
               "LEFT JOIN FETCH p.paymentObjects po " +
               "LEFT JOIN FETCH po.paymentObjectSsr paymentSsr " +
               "LEFT JOIN FETCH paymentSsr.paymentSsrArticles articles",
       countQuery = "SELECT COUNT(DISTINCT p) FROM PaymentAnalyticEntity p")
Page<PaymentAnalyticEntity> findAllWithRelations(Specification<PaymentAnalyticEntity> spec, Pageable pageable);



Map<UUID, PFLloanFundsRqRegistryItemBo> analyticMap = new LinkedHashMap<>();

for (Tuple tuple : tuples) {
    UUID id = tuple.get(PaymentAnalyticEntity_.ID, UUID.class);

    // Верхний уровень: PFLloanFundsRqRegistryItemBo
    PFLloanFundsRqRegistryItemBo analyticDto = analyticMap.computeIfAbsent(id, k -> {
        PFLloanFundsRqRegistryItemBo dto = new PFLloanFundsRqRegistryItemBo();
        dto.setId(id);
        dto.setClientId(tuple.get(PaymentAnalyticEntity_.CLIENT_ID, UUID.class));
        dto.setPaymentDocumentId(tuple.get(PaymentAnalyticEntity_.PAYMENT_DOCUMENT_ID, UUID.class));
        dto.setNumber(tuple.get(PaymentAnalyticEntity_.NUMBER, Integer.class));
        dto.setStatus(tuple.get(PaymentAnalyticEntity_.STATUS, String.class));
        dto.setDate(tuple.get(PaymentAnalyticEntity_.DATE, LocalDate.class));

        // Инициализируем LinkedHashSet для гарантирования порядка вставки и уникальности по ID
        dto.setPaymentObjects(new LinkedHashSet<>());
        return dto;
    });

    // Второй уровень: PaymentObjectEntityBo
    UUID paymentObjectId = tuple.get(PaymentObjectEntity_.ID, UUID.class);
    String paymentObjectName = tuple.get(PaymentObjectEntity_.NAME, String.class);
    String projectName = tuple.get(PaymentObjectEntity_.PROJECT_NAME, String.class);

    if (paymentObjectId != null) {
        PaymentObjectEntityBo paymentObjectDto = analyticDto.getPaymentObjects()
            .stream()
            .filter(po -> paymentObjectId.equals(po.getId()))
            .findFirst()
            .orElseGet(() -> {
                PaymentObjectEntityBo newPaymentObject = new PaymentObjectEntityBo();
                newPaymentObject.setId(paymentObjectId);
                newPaymentObject.setName(paymentObjectName);
                newPaymentObject.setProjectName(projectName);

                // Третий уровень: PaymentObjectSsrEntityBo
                // Здесь один объект, но для статей используем LinkedHashSet
                PaymentObjectSsrEntityBo paymentObjectSsr = new PaymentObjectSsrEntityBo();
                paymentObjectSsr.setPaymentSsrArticles(new LinkedHashSet<>());
                newPaymentObject.setPaymentObjectSsr(paymentObjectSsr);

                analyticDto.getPaymentObjects().add(newPaymentObject);
                return newPaymentObject;
            });

        // Четвёртый уровень: PaymentSsrArticleEntityBo
        UUID articleId = tuple.get(PaymentSsrArticleEntity_.ID, UUID.class);
        String articleCode = tuple.get(PaymentSsrArticleEntity_.CODE, String.class);

        if (articleId != null) {
            boolean articleExists = paymentObjectDto.getPaymentObjectSsr().getPaymentSsrArticles()
                .stream()
                .anyMatch(article -> articleId.equals(article.getId()));

            if (!articleExists) {
                PaymentSsrArticleEntityBo articleDto = new PaymentSsrArticleEntityBo();
                articleDto.setId(articleId);
                articleDto.setCode(articleCode);

                paymentObjectDto.getPaymentObjectSsr().getPaymentSsrArticles().add(articleDto);
            }
        }
    }
}
