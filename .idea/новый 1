Function<JPAQuery<PaymentAnalyticEntity>, JPAQuery<MyResponseDto>> projectionFunction = query -> {
    QPaymentAnalyticEntity paymentAnalytic = QPaymentAnalyticEntity.paymentAnalyticEntity;
    QPaymentObject paymentObject = QPaymentObject.paymentObject;
    QPaymentObjectSsr paymentObjectSsr = QPaymentObjectSsr.paymentObjectSsr;
    QPaymentSsrArticle ssrArticle = QPaymentSsrArticle.paymentSsrArticle;
    QConfirmationDocument confirmationDocument = QConfirmationDocument.confirmationDocument;

    return query.select(Projections.bean(
            MyResponseDto.class,
            // Основные поля
            paymentAnalytic.id,
            paymentAnalytic.clientId,
            paymentAnalytic.number.as("applicationNumber"),
            paymentAnalytic.status.as("loanFundsRequestStatus"),
            paymentAnalytic.date.as("applicationDate"),
            paymentAnalytic.fundsType.as("fundsType"),
            paymentAnalytic.creditAgreementNumber.as("creditAgreementNumber"),
            paymentAnalytic.creditAgreementDate.as("creditAgreementDate"),
            paymentAnalytic.payerAccount.as("payerAccount"),
            paymentAnalytic.obcAccountFlag.as("obcAccountFlag"),
            paymentAnalytic.trancheIssueDate.as("trancheIssueDate"),
            paymentAnalytic.amount.as("amount"),
            paymentAnalytic.paymentPurpose.as("paymentPurpose"),
            paymentAnalytic.recipientName.as("recipientName"),
            paymentAnalytic.recipientAccount.as("recipientAccount"),
            paymentAnalytic.dvruNumber.as("dvruNumber"),
            paymentAnalytic.dvruDate.as("dvruDate"),
            paymentAnalytic.paymentType.as("paymentType"),
            paymentAnalytic.paymentOrderStatus.as("paymentOrderStatus"),
            // Связанные таблицы
            paymentObject.id.as("paymentObjectId"),
            paymentObjectSsr.article.as("paymentObjectArticle"),
            ssrArticle.code.as("ssrArticleCodes"),
            confirmationDocument.documentNumber.as("confirmationDocumentNumber")
        ))
        .from(paymentAnalytic)
        // Связь с paymentObject
        .leftJoin(paymentAnalytic.paymentObjects, paymentObject)
        // Связь с paymentObjectSsr через paymentObject
        .leftJoin(paymentObject.paymentObjectSsr, paymentObjectSsr)
        // Связь с ssrArticle через paymentObjectSsr
        .leftJoin(paymentObjectSsr.ssrArticles, ssrArticle)
        // Связь с confirmationDocument
        .leftJoin(paymentAnalytic.confirmationDocuments, confirmationDocument);
};

import com.querydsl.core.types.Expression;
import com.querydsl.core.types.dsl.PathBuilder;
import com.querydsl.core.types.dsl.SimpleExpression;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

public class QuerydslProjectionMapper {

    public static <Entity, DTO> List<Expression<?>> mapFieldsToProjections(Class<Entity> entityClass, Class<DTO> dtoClass) {
        List<Expression<?>> projections = new ArrayList<>();

        // Создаем PathBuilder для указанного класса сущности
        PathBuilder<Entity> entityPath = new PathBuilder<>(entityClass, entityClass.getSimpleName().toLowerCase());

        // Проходим по всем методам DTO
        for (Method method : dtoClass.getDeclaredMethods()) {
            String methodName = method.getName();
            if (methodName.startsWith("get")) {
                // Преобразуем имя метода в имя поля (удаляем "get" и делаем первую букву строчной)
                String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);

                try {
                    // Получаем поле QueryDSL по имени
                    SimpleExpression<?> fieldExpression = entityPath.get(fieldName);
                    // Добавляем поле в список проекций
                    projections.add(fieldExpression.as(fieldName));
                } catch (IllegalArgumentException e) {
                    // Если поле не найдено в PathBuilder, можно обработать исключение
                    System.err.println("Field not found for method: " + methodName);
                }
            }
        }

        return projections;
    }
}
public <T> Expression<?>[] mapFieldsToProjections(Class<E> entityClass, Class<T> dtoClass) {
    List<Expression<?>> projections = new ArrayList<>();
    PathBuilder<E> entityPath = new PathBuilder<>(entityClass, entityClass.getSimpleName().toLowerCase());

    for (Method method : dtoClass.getDeclaredMethods()) {
        if (method.getName().startsWith("get")) {
            // Получение имени поля из метода
            String fieldName = Character.toLowerCase(method.getName().charAt(3)) + method.getName().substring(4);
            try {
                // Маппинг поля QueryDSL с алиасом
                Expression<?> fieldExpression = entityPath.get(fieldName);
                projections.add(fieldExpression.as(fieldName));
            } catch (IllegalArgumentException e) {
                System.err.println("Field not found for method: " + method.getName());
            }
        }
    }

    // Возвращаем массив Expression<?>[]
    return projections.toArray(new Expression<?>[0]);
}

public List<String> extractJoinsFromGraph(EntityManager entityManager, String graphName, Class<?> entityClass) {
    EntityGraph<?> entityGraph = entityManager.getEntityGraph(graphName);

    // Список связей (атрибутов)
    List<String> joins = new ArrayList<>();
    for (AttributeNode<?> node : entityGraph.getAttributeNodes()) {
        joins.add(node.getAttributeName());
    }

    return joins;
}
public <E> JPAQuery<E> applyJoinsFromGraph(
    JPAQuery<E> query,
    EntityManager entityManager,
    String graphName,
    EntityPathBase<E> rootEntity
) {
    // Извлекаем связи из графа
    List<String> joins = extractJoinsFromGraph(entityManager, graphName, rootEntity.getType());

    // Применяем `join` для каждой связи
    for (String join : joins) {
        PathBuilder<?> joinPath = new PathBuilder<>(rootEntity.getType(), join);
        query.leftJoin(joinPath);
    }

    return query;
}


@Service
public class PaymentAnalyticService {

    private final QdslProjectionRepositoryImpl<PaymentAnalyticEntity> repository;

    @Autowired
    private EntityManager entityManager;

    public PaymentAnalyticService(QdslProjectionRepositoryImpl<PaymentAnalyticEntity> repository) {
        this.repository = repository;
    }

    public Page<PfLoanFundsRqRegistryItemDto> findAllWithPaginationAndFilters(
            Predicate predicate,
            Pageable pageable,
            List<OrderSpecifier<?>> orderSpecifiers
    ) {
        // Ручное указание имени графа
        String graphName = "PaymentAnalyticEntity.FULL_ANALYTIC_ENTITY_GRAPH";

        // 1. Настраиваем проекции
        Expression<?>[] projections = QProjectionUtil.mapFieldsToProjections(
            PaymentAnalyticEntity.class,
            PfLoanFundsRqRegistryItemDto.class
        );

        // 2. Настраиваем функцию проекции с учетом графа
        Function<JPAQuery<PaymentAnalyticEntity>, JPAQuery<PfLoanFundsRqRegistryItemDto>> projectionFunction = query -> {
            query.select(Projections.fields(PfLoanFundsRqRegistryItemDto.class, projections))
                 .from(QPaymentAnalyticEntity.paymentAnalyticEntity);

            // Применяем join на основе графа
            QProjectionUtil.applyJoinsFromGraph(query, entityManager, graphName, QPaymentAnalyticEntity.paymentAnalyticEntity);

            return query;
        };

        // 3. Вызываем универсальный метод репозитория
        return repository.findAll(predicate, pageable, orderSpecifiers, projectionFunction);
    }
}

+++++++++++++++++++++++++++++++++++++++++++
```java
// QProjectionMapper.java
public interface QProjectionMapper {
    <E, T> Expression<?>[] mapFieldsToProjections(Class<E> entityClass, Class<T> dtoClass);
    <E> EntityPathBase<E> getEntityPathBase(Class<E> entityClass);
    <E> void applyJoinsFromGraph(JPAQuery<?> query, String graphName, EntityPathBase<E> rootEntity);
}

// QProjectionMapperImpl.java
import javax.persistence.*;
import javax.persistence.metamodel.*;
import java.beans.PropertyDescriptor;
import java.util.*;
import com.querydsl.core.types.*;
import com.querydsl.core.types.dsl.*;
import com.querydsl.jpa.impl.JPAQuery;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Component;

@Component
public class QProjectionMapperImpl implements QProjectionMapper {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public <E, T> Expression<?>[] mapFieldsToProjections(Class<E> entityClass, Class<T> dtoClass) {
        List<Expression<?>> projections = new ArrayList<>();
        PathBuilder<E> entityPath = new PathBuilder<>(entityClass, entityClass.getSimpleName().toLowerCase());

        for (PropertyDescriptor propertyDescriptor : BeanUtils.getPropertyDescriptors(dtoClass)) {
            String propertyName = propertyDescriptor.getName();
            if ("class".equals(propertyName)) {
                continue;
            }
            try {
                Expression<?> fieldExpression = entityPath.get(propertyName);
                projections.add(fieldExpression.as(propertyName));
            } catch (IllegalArgumentException e) {
                throw new EntityNotFoundException(
                        "Field not found in entity for DTO projection: " + propertyName, e);
            }
        }
        return projections.toArray(new Expression<?>[0]);
    }

    @Override
    public <E> EntityPathBase<E> getEntityPathBase(Class<E> entityClass) {
        return new PathBuilder<>(entityClass, entityClass.getSimpleName().toLowerCase());
    }

    @Override
    public <E> void applyJoinsFromGraph(JPAQuery<?> query, String graphName, EntityPathBase<E> rootEntity) {
        List<String> joins = extractJoinsFromGraph(graphName);
        for (String join : joins) {
            Path<Object> joinPath = rootEntity.get(join);
            query.leftJoin(joinPath).fetchJoin();
        }
    }

    private List<String> extractJoinsFromGraph(String graphName) {
        EntityGraph<?> entityGraph = entityManager.getEntityGraph(graphName);
        List<String> joins = new ArrayList<>();
        for (AttributeNode<?> node : entityGraph.getAttributeNodes()) {
            joins.add(node.getAttributeName());
        }
        return joins;
    }
}

// QdslProjectionRepository.java
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.Predicate;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

public interface QdslProjectionRepository<E> {
    <T> Page<T> findAll(
            Predicate predicate,
            Pageable pageable,
            List<OrderSpecifier<?>> orderSpecifiers,
            String graphName,
            Class<T> projectionClass);
}

// QdslProjectionRepositoryImpl.java
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.dsl.EntityPathBase;
import com.querydsl.jpa.impl.JPAQuery;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.Transactional;
import java.util.List;

public class QdslProjectionRepositoryImpl<E> implements QdslProjectionRepository<E> {

    @PersistenceContext
    private EntityManager entityManager;

    private final Class<E> domainClass;
    private final EntityPathBase<E> entityPathBase;
    private final QProjectionMapper qProjectionMapper;

    public QdslProjectionRepositoryImpl(Class<E> domainClass, QProjectionMapper qProjectionMapper) {
        this.domainClass = domainClass;
        this.entityPathBase = qProjectionMapper.getEntityPathBase(domainClass);
        this.qProjectionMapper = qProjectionMapper;
    }

    @Override
    @Transactional
    public <T> Page<T> findAll(
            Predicate predicate,
            Pageable pageable,
            List<OrderSpecifier<?>> orderSpecifiers,
            String graphName,
            Class<T> projectionClass) {

        JPAQuery<T> query = new JPAQuery<>(entityManager);
        Expression<?>[] projections = qProjectionMapper.mapFieldsToProjections(domainClass, projectionClass);

        query.select(Projections.fields(projectionClass, projections))
                .from(entityPathBase);

        qProjectionMapper.applyJoinsFromGraph(query, graphName, entityPathBase);

        query.where(predicate)
                .orderBy(orderSpecifiers.toArray(new OrderSpecifier<?>[0]))
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize());

        List<T> content = query.fetch();
        long total = fetchTotalCount(predicate);

        return new PageImpl<>(content, pageable, total);
    }

    private long fetchTotalCount(Predicate predicate) {
        JPAQuery<Long> countQuery = new JPAQuery<>(entityManager);
        Long total = countQuery.select(entityPathBase.count())
                .from(entityPathBase)
                .where(predicate)
                .fetchOne();
        return total != null ? total : 0;
    }
}

// YourServiceClass.java
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.Predicate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Set;
import java.util.UUID;

@Service
public class YourServiceClass {

    @Autowired
    private QdslProjectionRepository<PaymentAnalyticEntity> repository;

    public Page<PfLoanFundsRqRegistryItemDto> findAllWithPaginationAndFilters(
            Set<UUID> orgIds,
            PaginationRequestDto pagination,
            List<SortingRequestDto> sorting,
            PfLoanFundsRqRegistryFilterDto requestFilter,
            List<RegistryCodes> fields) {

        Predicate predicate = buildPredicate(requestFilter, fields);
        Pageable pageable = createPageable(pagination, sorting);
        List<OrderSpecifier<?>> orderSpecifiers = buildOrderSpecifiers(
                sorting, QPaymentAnalyticEntity.paymentAnalyticEntity);

        String graphName = PaymentAnalyticEntity.FULL_ANALYTIC_ENTITY_GRAPH;

        return repository.findAll(
                predicate,
                pageable,
                orderSpecifiers,
                graphName,
                PfLoanFundsRqRegistryItemDto.class);
    }

    // Implement buildPredicate, createPageable, and buildOrderSpecifiers methods
}

// Ensure that you have the necessary imports and any required helper methods implemented.
// The code has been organized according to SOLID principles, types have been checked and corrected,
// and the code is now more testable with the use of interfaces and dependency injection.
```

