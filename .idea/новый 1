public static <E, T> Expression<?>[] mapFieldsToProjections(Class<E> entityClass, Class<T> dtoClass) {
    List<Expression<?>> projections = new ArrayList<>();
    PathBuilder<E> entityPath = new PathBuilder<>(entityClass, entityClass.getSimpleName().toLowerCase());

    for (Method method : dtoClass.getDeclaredMethods()) {
        String methodName = method.getName();
        if (methodName.startsWith("get")) {
            String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);
            Class<?> dtoFieldType = method.getReturnType();

            // Попытка определить тип поля сущности
            Field entityField;
            try {
                entityField = entityClass.getDeclaredField(fieldName);
            } catch (NoSuchFieldException e) {
                throw new EntityNotFoundException(String.format(
                    "В сущности %s не найдено поле %s, соответствующее полю в DTO %s: %s",
                    entityClass.getSimpleName(), fieldName, dtoClass.getSimpleName(), methodName), e);
            }

            Class<?> entityFieldType = entityField.getType();
            if (!dtoFieldType.equals(entityFieldType)) {
                throw new IllegalArgumentException(String.format(
                    "Тип поля '%s' в сущности %s (%s) не совпадает с типом поля в %s (%s)",
                    fieldName, entityClass.getSimpleName(), entityFieldType.getSimpleName(),
                    dtoClass.getSimpleName(), dtoFieldType.getSimpleName()
                ));
            }

            // Создание типизированного выражения
            @SuppressWarnings("unchecked")
            SimpleExpression<?> fieldExpression = (SimpleExpression<?>) entityPath.get(entityFieldType, fieldName);

            projections.add(fieldExpression.as(fieldName));
        }
    }

    return projections.toArray(new Expression<?>[0]);
}
