Ниже я опишу, как я понял задачу, а затем приведу полный, развернутый пример кода, не сокращая и не убавляя ничего. Я буду использовать предоставленные данные и классы, иерархию сущностей, `PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification` и `PaymentAnalyticDto` (Dto предоставлен для понимания структуры, но само DTO не будет использоваться в спецификациях напрямую). Код будет адаптирован под требование: предоставить удобный API, позволяющий в сервисе вызывать методы типа `filterService.applyFilter(...)` или `filterService.applySorting(...)`, передавая:

1. Класс сущности верхнего уровня (например `PaymentAnalyticEntity.class`).
2. Путь до уровня вложенности с использованием билдера и метамодели (в примере будут методы для получения пути).
3. Список `RegistryCodes` для фильтрации или список `SortingRequestDto` для сортировки (где `sortField` маппится к одному из `RegistryCodes`).
   
`RegistryCodes` – enum, который уже существует и менять/расширять его нельзя. Он служит для определения, по каким полям фильтровать и сортировать.  
`SortingRequestDto` – содержит код поля и направление сортировки. По умолчанию сортировка убывающая, если иное не указано.  
`PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification` – предоставлен в условии и уже рабочий, мы его использовать будем как пример спецификации сортировки. Можно адаптировать подход, вынеся общий функционал.  
`SpecificationBuilder` – билдер для композиции спецификаций.  
`FilterService` и `SortingService` – сервисы, предоставляющие удобные методы для разработчика, чтобы применить фильтры/сортировки на основе входных данных. Они должны использовать предоставленные `RegistryCodes` и метамодель для построения `Specification`.  
В репозитории мы хотим иметь возможность вызвать `repository.findAll(...)` передавая фильтрующую спецификацию и спецификацию сортировки. Если в `Pageable` есть явная сортировка, то использовать её, если нет – использовать нашу спецификацию сортировки.

### Как я понял задание:

- У нас есть набор кодов полей (`RegistryCodes`), по которым мы можем фильтровать и сортировать `PaymentAnalyticEntity` и связанные с ней вложенные сущности.
- Мы должны предоставить сервис (например `FilterService` и `SortingService`), который на вход принимает:
  - Класс сущности верхнего уровня.
  - "Путь" до вложенных сущностей (если нужно), который задается либо параметрами, либо билдером. Путь необходим для получения нужных join в спецификациях.
  - Список кодов полей (для фильтра) или список `SortingRequestDto` (для сортировки), содержащий код поля из `RegistryCodes`.
  
- `FilterService` должен вернуть `Specification<PaymentAnalyticEntity>`, которую потом можно передать в репозиторий.
- `SortingService` должен вернуть `Specification<PaymentAnalyticEntity>` для сортировки. Если в `Pageable` сортировка не задана, то применять спецификацию сортировки, иначе использовать сортировку из `Pageable`.
- Нельзя менять `RegistryCodes`, но можно использовать его методы (`of(...)`) для валидации кода.
- Реализовать это максимально подробно, не сокращая код.
- Показать итоговый вызов в сервисном слое, где мы используем `FilterService` и `SortingService`, затем передаем результат в репозиторий.

### Полный пример кода

#### Enum RegistryCodes (предоставлен, менять нельзя)
```java
public enum RegistryCodes {
    LOAN_FUNDS_REQUEST_STATUS("LOAN_FUNDS_REQUEST_STATUS"),
    PAYMENT_ORDER_STATUS("PAYMENT_ORDER_STATUS"),
    RECIPIENT_ACCOUNT("RECIPIENT_ACCOUNT"),
    PAYMENT_TYPE("PAYMENT_TYPE"),
    DVRU("DVRU"),
    FUNDS_TYPE("FUNDS_TYPE"),
    SSR_ARTICLE("SSR_ARTICLE"),
    PAYMENT_OBJECT("PAYMENT_OBJECT"),
    RECIPIENT_NAME("RECIPIENT_NAME"),
    TRANCHE_ISSUE_DATE("TRANCHE_ISSUE_DATE"),
    PAYMENT_PURPOSE("PAYMENT_PURPOSE"),
    AMOUNT("AMOUNT"),
    PAYER_ACCOUNT("PAYER_ACCOUNT"),
    CREDIT_AGREEMENT("CREDIT_AGREEMENT"),
    DATE("DATE"),
    NUMBER("NUMBER");

    private final String value;

    RegistryCodes(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    // Статический метод для получения экземпляра по строковому значению
    // уже реализован у вас в коде, предполагается примерно так:
    public static RegistryCodes of(String value) {
        // Примерный код, в вашем коде уже реализован
        for (RegistryCodes rc : values()) {
            if (rc.getValue().equals(value)) {
                return rc;
            }
        }
        throw new IllegalArgumentException("Unknown RegistryCode: " + value);
    }

    public static RegistryCodes ofNullable(String value) {
        if (value == null) return null;
        return of(value);
    }
}
```

#### SortingRequestDto (предоставлен)
```java
import jakarta.validation.constraints.NotNull;

public class SortingRequestDto {
    @NotNull
    private String sortField;

    @NotNull
    private Boolean sortDescending = Boolean.TRUE;

    public SortingRequestDto() {
    }

    public SortingRequestDto(String sortField, Boolean sortDescending) {
        this.sortField = sortField;
        this.sortDescending = sortDescending;
    }

    public String getSortField() {
        return sortField;
    }

    public void setSortField(String sortField) {
        this.sortField = sortField;
    }

    public Boolean getSortDescending() {
        return sortDescending;
    }

    public void setSortDescending(Boolean sortDescending) {
        this.sortDescending = sortDescending;
    }
}
```

#### PaymentAnalyticEntity и метамодель (пример, как минимум поля ссылающиеся)
```java
// Предполагаем, что у вас уже есть сущность PaymentAnalyticEntity и ее метамодель PaymentAnalyticEntity_
// Здесь только примерная структура (не нужно менять ваш код)
// Примерно так выглядит сущность (упрощенно):

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Set;
import java.util.UUID;

@Entity
@Table(name="payment_analytic")
public class PaymentAnalyticEntity {

    @Id
    private UUID id;

    private UUID clientId;
    private UUID paymentDocumentId;
    private Integer number;
    // Статус запроса на получение средств
    private String status;
    private LocalDate date;
    private String fundsType;
    private String creditAgreementNumber;
    private LocalDate creditAgreementDate;
    private String payerAccount;
    private Boolean obcAccountFlag;
    private LocalDate trancheIssueDate;
    private BigDecimal amount;
    private String paymentPurpose;
    private String recipientName;
    private String recipientAccount;
    private String dvruNumber;
    private LocalDate dvruDate;
    private String paymentType;

    @OneToMany(mappedBy = "paymentAnalytic", fetch = FetchType.LAZY)
    private Set<PaymentObjectEntity> paymentObjects;

    // getters and setters omitted
}

// Метамодель (сгенерируется автоматически через hibernate-jpamodelgen)
// Примерно будет так:
@StaticMetamodel(PaymentAnalyticEntity.class)
public class PaymentAnalyticEntity_ {
    public static volatile SingularAttribute<PaymentAnalyticEntity, UUID> id;
    public static volatile SingularAttribute<PaymentAnalyticEntity, UUID> clientId;
    public static volatile SingularAttribute<PaymentAnalyticEntity, UUID> paymentDocumentId;
    public static volatile SingularAttribute<PaymentAnalyticEntity, Integer> number;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> status;
    public static volatile SingularAttribute<PaymentAnalyticEntity, LocalDate> date;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> fundsType;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> creditAgreementNumber;
    public static volatile SingularAttribute<PaymentAnalyticEntity, LocalDate> creditAgreementDate;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> payerAccount;
    public static volatile SingularAttribute<PaymentAnalyticEntity, Boolean> obcAccountFlag;
    public static volatile SingularAttribute<PaymentAnalyticEntity, LocalDate> trancheIssueDate;
    public static volatile SingularAttribute<PaymentAnalyticEntity, BigDecimal> amount;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> paymentPurpose;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> recipientName;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> recipientAccount;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> dvruNumber;
    public static volatile SingularAttribute<PaymentAnalyticEntity, LocalDate> dvruDate;
    public static volatile SingularAttribute<PaymentAnalyticEntity, String> paymentType;
    public static volatile SetAttribute<PaymentAnalyticEntity, PaymentObjectEntity> paymentObjects;
}
```

#### Вложенные сущности и их метамодели (для SSR статьи и т.д.)
```java
@Entity
@Table(name = "payment_object")
public class PaymentObjectEntity {

    @Id
    private UUID id;

    private String name;
    private String projectName;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payment_object_ssr_id")
    private PaymentObjectSsrEntity paymentObjectSsr;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payment_analytic_id")
    private PaymentAnalyticEntity paymentAnalytic;

    // getters/setters
}

@StaticMetamodel(PaymentObjectEntity.class)
public class PaymentObjectEntity_ {
    public static volatile SingularAttribute<PaymentObjectEntity, UUID> id;
    public static volatile SingularAttribute<PaymentObjectEntity, String> name;
    public static volatile SingularAttribute<PaymentObjectEntity, String> projectName;
    public static volatile SingularAttribute<PaymentObjectEntity, PaymentObjectSsrEntity> paymentObjectSsr;
    public static volatile SingularAttribute<PaymentObjectEntity, PaymentAnalyticEntity> paymentAnalytic;
}


@Entity
@Table(name = "payment_object_ssr")
public class PaymentObjectSsrEntity {

    @Id
    private UUID id;

    @OneToMany(mappedBy = "paymentObjectSsr", fetch = FetchType.LAZY)
    private Set<PaymentSsrArticleEntity> paymentSsrArticles;

    // getters/setters
}

@StaticMetamodel(PaymentObjectSsrEntity.class)
public class PaymentObjectSsrEntity_ {
    public static volatile SingularAttribute<PaymentObjectSsrEntity, UUID> id;
    public static volatile SetAttribute<PaymentObjectSsrEntity, PaymentSsrArticleEntity> paymentSsrArticles;
}


@Entity
@Table(name = "payment_ssr_article")
public class PaymentSsrArticleEntity {

    @Id
    private UUID id;

    private String code;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payment_object_ssr_id")
    private PaymentObjectSsrEntity paymentObjectSsr;

    // getters/setters
}

@StaticMetamodel(PaymentSsrArticleEntity.class)
public class PaymentSsrArticleEntity_ {
    public static volatile SingularAttribute<PaymentSsrArticleEntity, UUID> id;
    public static volatile SingularAttribute<PaymentSsrArticleEntity, String> code;
    public static volatile SingularAttribute<PaymentSsrArticleEntity, PaymentObjectSsrEntity> paymentObjectSsr;
}
```

#### Исходная спецификация сортировки (предоставлено)
```java
import jakarta.persistence.criteria.*;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;

public class PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification implements Specification<PaymentAnalyticEntity> {

    private final List<SortingRequestDto> sortingDtos;

    public PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification(List<SortingRequestDto> sortingDtos) {
        this.sortingDtos = sortingDtos;
    }

    @Override
    public Predicate toPredicate(Root<PaymentAnalyticEntity> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
        List<Order> orders = new ArrayList<>();

        if (sortingDtos != null && !sortingDtos.isEmpty()) {
            for (SortingRequestDto dto : sortingDtos) {
                boolean descending = dto.getSortDescending();
                String sortField = dto.getSortField().toUpperCase();

                // Тут у вас логика, которая по sortField выбирает поле сущности
                // Она была у вас в примере кода, оставим как есть
                switch (sortField) {
                    case "NUMBER" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.number), descending));
                    case "LOAN_FUNDS_REQUEST_STATUS" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.status), descending));
                    case "DATE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.date), descending));
                    case "FUNDS_TYPE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.fundsType), descending));
                    case "CREDIT_AGREEMENT" -> {
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.creditAgreementNumber), descending));
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.creditAgreementDate), descending));
                    }
                    case "PAYER_ACCOUNT" -> {
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.payerAccount), descending));
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.obcAccountFlag), descending));
                    }
                    case "TRANCHE_ISSUE_DATE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.trancheIssueDate), descending));
                    case "AMOUNT" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.amount), descending));
                    case "PAYMENT_PURPOSE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.paymentPurpose), descending));
                    case "RECIPIENT_NAME" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.recipientName), descending));
                    case "RECIPIENT_ACCOUNT" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.recipientAccount), descending));
                    case "DVRU" -> {
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.dvruNumber), descending));
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.dvruDate), descending));
                    }
                    case "PAYMENT_TYPE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.paymentType), descending));
                    case "SSR_ARTICLE" -> {
                        Expression<String> codePath = root.join(PaymentAnalyticEntity_.paymentObjects)
                                .join(PaymentObjectEntity_.paymentObjectSsr)
                                .join(PaymentObjectSsrEntity_.paymentSsrArticles)
                                .get(PaymentSsrArticleEntity_.code);
                        orders.add(createOrder(cb, codePath, descending));
                    }
                    default -> throw new IllegalArgumentException("Unknown sorting field: " + sortField);
                }
            }
        } else {
            // Сортировка по умолчанию
            orders.add(cb.desc(root.get(PaymentAnalyticEntity_.date)));
        }

        query.orderBy(orders);
        return null;
    }

    private Order createOrder(CriteriaBuilder cb, Expression<?> expression, boolean descending) {
        return descending ? cb.desc(expression) : cb.asc(expression);
    }
}
```

#### SpecificationBuilder - строитель спецификаций
```java
import org.springframework.data.jpa.domain.Specification;
import java.util.ArrayList;
import java.util.List;

public class SpecificationBuilder<T> {
    private final List<Specification<T>> specifications = new ArrayList<>();

    public SpecificationBuilder<T> add(Specification<T> spec) {
        if (spec != null) {
            specifications.add(spec);
        }
        return this;
    }

    public Specification<T> build() {
        Specification<T> result = Specification.where(null);
        for (Specification<T> spec : specifications) {
            result = result.and(spec);
        }
        return result;
    }
}
```

#### FilterService

Фильтрация будет зависеть от `RegistryCodes`. Допустим, для простоты фильтрация будет делать eq по некоторым полям верхнего уровня, а при необходимости залезать во вложенные. В реальности вам нужно будет реализовать логику фильтрации в зависимости от требований. Здесь будет пример того, как можно использовать коды, чтобы получить нужный `Path` к полю, и применить к нему, например, фильтр `isNotNull()` или `equal(value)`, в реальности нужно знать входные данные фильтра. Я покажу общий подход.

```java
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.*;

import java.util.List;

public class FilterService {

    // Этот метод применит фильтр на основе списков RegistryCodes.
    // Предположим, что фильтр - это просто проверка на isNotNull по каждому коду (для примера).
    // На практике вы можете расширить логику и использовать значения фильтра.
    public <T> Specification<T> applyFilter(Class<T> entityClass,
                                            SpecificationPathBuilder<T> pathBuilder,
                                            List<RegistryCodes> fields) {
        return (root, query, cb) -> {
            Predicate predicate = cb.conjunction();
            for (RegistryCodes code : fields) {
                // Получаем путь к полю по коду
                Expression<?> expression = pathBuilder.buildPath(root, code, cb);
                if (expression != null) {
                    // Пример: добавляем условие не null
                    predicate = cb.and(predicate, cb.isNotNull(expression));
                } else {
                    // Если поле не найдено, можно выбросить исключение или игнорировать
                    throw new IllegalArgumentException("No field mapping found for code: " + code);
                }
            }
            return predicate;
        };
    }
}
```

#### SortingService

Сервис, который применяет сортировку на основе `SortingRequestDto`. Он будет использовать логику, похожую на ту, что в `PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification`, но более универсально. Мы будем искать поле через pathBuilder.

```java
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.*;

import java.util.ArrayList;
import java.util.List;

public class SortingService {
    public <T> Specification<T> applySorting(Class<T> entityClass,
                                             SpecificationPathBuilder<T> pathBuilder,
                                             List<SortingRequestDto> sortingDtos) {
        return (root, query, cb) -> {
            List<Order> orders = new ArrayList<>();
            if (sortingDtos != null && !sortingDtos.isEmpty()) {
                for (SortingRequestDto dto : sortingDtos) {
                    RegistryCodes code = RegistryCodes.of(dto.getSortField());
                    Expression<?> expression = pathBuilder.buildPath(root, code, cb);
                    if (expression != null) {
                        orders.add(dto.getSortDescending() ? cb.desc(expression) : cb.asc(expression));
                    } else {
                        throw new IllegalArgumentException("No field mapping found for code: " + code);
                    }
                }
            } else {
                // Сортировка по умолчанию (например, по дате убыв.)
                // В вашем примере по умолчанию sort по date desc
                Expression<?> expression = pathBuilder.buildPath(root, RegistryCodes.DATE, cb);
                if (expression != null) {
                    orders.add(cb.desc(expression));
                }
            }

            query.orderBy(orders);
            return null;
        };
    }
}
```

#### SpecificationPathBuilder

Интерфейс (или абстрактный класс), который умеет на основе `RegistryCodes` выдать `Path` или `Expression` для фильтрации/сортировки, учитывая вложенные сущности. Это ключевой момент – он задает "путь" к нужному уровню структуры. Можно реализовать для `PaymentAnalyticEntity`:

```java
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.Expression;
import jakarta.persistence.criteria.Root;
import jakarta.persistence.criteria.SetJoin;

public class PaymentAnalyticSpecificationPathBuilder implements SpecificationPathBuilder<PaymentAnalyticEntity> {

    @Override
    public Expression<?> buildPath(Root<PaymentAnalyticEntity> root, RegistryCodes code, CriteriaBuilder cb) {
        // Здесь логика маппинга RegistryCodes -> поле сущности
        // Должна повторять логику из PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification
        // Допустим простой маппинг:
        switch (code) {
            case NUMBER:
                return root.get(PaymentAnalyticEntity_.number);
            case LOAN_FUNDS_REQUEST_STATUS:
                return root.get(PaymentAnalyticEntity_.status);
            case DATE:
                return root.get(PaymentAnalyticEntity_.date);
            case FUNDS_TYPE:
                return root.get(PaymentAnalyticEntity_.fundsType);
            case CREDIT_AGREEMENT:
                // Для CREDIT_AGREEMENT у нас два поля:
                // Возьмем основной creditAgreementNumber для фильтра/сортировки
                return root.get(PaymentAnalyticEntity_.creditAgreementNumber);
            case PAYER_ACCOUNT:
                // Аналогично берем payerAccount
                return root.get(PaymentAnalyticEntity_.payerAccount);
            case TRANCHE_ISSUE_DATE:
                return root.get(PaymentAnalyticEntity_.trancheIssueDate);
            case AMOUNT:
                return root.get(PaymentAnalyticEntity_.amount);
            case PAYMENT_PURPOSE:
                return root.get(PaymentAnalyticEntity_.paymentPurpose);
            case RECIPIENT_NAME:
                return root.get(PaymentAnalyticEntity_.recipientName);
            case RECIPIENT_ACCOUNT:
                return root.get(PaymentAnalyticEntity_.recipientAccount);
            case DVRU:
                // Возьмем dvruNumber для сортировки/фильтра
                return root.get(PaymentAnalyticEntity_.dvruNumber);
            case PAYMENT_TYPE:
                return root.get(PaymentAnalyticEntity_.paymentType);
            case SSR_ARTICLE:
                // SSR_ARTICLE = поле code в PaymentSsrArticleEntity
                SetJoin<PaymentAnalyticEntity, PaymentObjectEntity> paymentObjectJoin = root.join(PaymentAnalyticEntity_.paymentObjects, jakarta.persistence.criteria.JoinType.LEFT);
                var ssrJoin = paymentObjectJoin.join(PaymentObjectEntity_.paymentObjectSsr, jakarta.persistence.criteria.JoinType.LEFT);
                var articleJoin = ssrJoin.join(PaymentObjectSsrEntity_.paymentSsrArticles, jakarta.persistence.criteria.JoinType.LEFT);
                return articleJoin.get(PaymentSsrArticleEntity_.code);
            case PAYMENT_OBJECT:
                // PAYMENT_OBJECT - допустим это name или projectName
                // Возьмем name, например
                SetJoin<PaymentAnalyticEntity, PaymentObjectEntity> poJoin = root.join(PaymentAnalyticEntity_.paymentObjects, jakarta.persistence.criteria.JoinType.LEFT);
                return poJoin.get(PaymentObjectEntity_.name);
            case PAYMENT_ORDER_STATUS:
                // У вас нет явно этого поля в PaymentAnalyticEntity
                // Предположим, что PAYMENT_ORDER_STATUS = status (если это разные поля - нужно добавить)
                // Возьмем status, так как нет других данных
                return root.get(PaymentAnalyticEntity_.status);
            default:
                return null;
        }
    }
}
```

#### Интерфейс SpecificationPathBuilder
```java
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.Expression;
import jakarta.persistence.criteria.Root;

public interface SpecificationPathBuilder<T> {
    Expression<?> buildPath(Root<T> root, RegistryCodes code, CriteriaBuilder cb);
}
```

#### Репозиторий

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.repository.CrudRepository;
import java.util.UUID;

public interface PaymentAnalyticRepository extends CrudRepository<PaymentAnalyticEntity, UUID>, JpaSpecificationExecutor<PaymentAnalyticEntity> {

    @EntityGraph(attributePaths = {
            "paymentObjects",
            "paymentObjects.paymentObjectSsr",
            "paymentObjects.paymentObjectSsr.paymentSsrArticles"
    })
    Page<PaymentAnalyticEntity> findAll(Specification<PaymentAnalyticEntity> specification, Pageable pageable);
}
```

#### Пример использования в сервисе

В сервисе мы хотим сделать примерно так:

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class PaymentAnalyticService {

    private final PaymentAnalyticRepository repository;
    private final FilterService filterService;
    private final SortingService sortingService;

    public PaymentAnalyticService(PaymentAnalyticRepository repository) {
        this.repository = repository;
        this.filterService = new FilterService();
        this.sortingService = new SortingService();
    }

    public Page<PaymentAnalyticEntity> getFilteredAndSortedData(Pageable pageable,
                                                               List<RegistryCodes> filterFields,
                                                               List<SortingRequestDto> sortingFields) {

        // Строим путь (pathBuilder) для сущности PaymentAnalyticEntity
        PaymentAnalyticSpecificationPathBuilder pathBuilder = new PaymentAnalyticSpecificationPathBuilder();

        // Создаем спецификацию фильтра
        Specification<PaymentAnalyticEntity> filterSpec = null;
        if (filterFields != null && !filterFields.isEmpty()) {
            filterSpec = filterService.applyFilter(PaymentAnalyticEntity.class, pathBuilder, filterFields);
        }

        // Создаем спецификацию сортировки
        Specification<PaymentAnalyticEntity> sortingSpec = null;
        if (sortingFields != null && !sortingFields.isEmpty()) {
            sortingSpec = sortingService.applySorting(PaymentAnalyticEntity.class, pathBuilder, sortingFields);
        }

        // Объединяем спецификации (если обе не null)
        SpecificationBuilder<PaymentAnalyticEntity> builder = new SpecificationBuilder<>();
        if (filterSpec != null) {
            builder.add(filterSpec);
        }

        // Проверяем сортировку из pageable
        if (pageable.getSort().isUnsorted()) {
            // Если сортировка в pageable отсутствует - применяем нашу sortingSpec
            if (sortingSpec != null) {
                builder.add(sortingSpec);
            }
            return repository.findAll(builder.build(), pageable);
        } else {
            // Если в pageable есть сортировка, используем только фильтр,
            // сортировка возьмется из pageable
            return repository.findAll(builder.build(), pageable);
        }
    }
}
```

#### Как я понял задание:

- У нас есть сущность `PaymentAnalyticEntity`.
- У нас есть enum `RegistryCodes` с кодами полей.  
- Мы хотим создать удобный API для разработчика, чтобы в сервисном слое можно было вызвать метод, который применит фильтрацию и сортировку на основе этих кодов.  
- Для этого мы создали `FilterService` и `SortingService`, а также `SpecificationPathBuilder`, который маппит `RegistryCodes` в конкретные пути к атрибутам сущности через метамодель.  
- Для фильтрации и сортировки мы используем `Specification` из Spring Data JPA.  
- В итоге можно вызвать, например:
  
  ```java
  List<RegistryCodes> filters = List.of(RegistryCodes.DATE, RegistryCodes.AMOUNT);
  List<SortingRequestDto> sortRequests = List.of(new SortingRequestDto("DATE", false));
  
  Page<PaymentAnalyticEntity> page = paymentAnalyticService.getFilteredAndSortedData(pageable, filters, sortRequests);
  ```
  
- Если `pageable` не содержит сортировок, будет применена наша сортировка из `sortRequests`. Если содержит – будут использоваться сортировки из `pageable`, а наша спецификация сортировки будет проигнорирована.

Таким образом, мы предоставили полный код, строго под ваши данные, ничего не сокращая, и реализовали удобный API с FilterService и SortingService, а также с путем, задаваемым через `SpecificationPathBuilder`, без изменения enum `RegistryCodes`.



******************************************************************************************
*****************************************************************************************
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Expression;
import jakarta.persistence.criteria.Order;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import org.springframework.data.jpa.domain.Specification;
import ru.domrf.elka.tranche.loan_funds_rq_search.model.entity.PaymentAnalyticEntity_;
import ru.domrf.elka.tranche.loan_funds_rq_search.model.entity.PaymentObjectEntity_;
import ru.domrf.elka.tranche.loan_funds_rq_search.model.entity.PaymentObjectSsrEntity_;
import ru.domrf.elka.tranche.loan_funds_rq_search.model.entity.PaymentSsrArticleEntity_;
import ru.domrf.elka.tranche.loan_funds_rq_search.model.dto.sorting.SortingRequestDto;

import java.util.ArrayList;
import java.util.List;

public class PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification implements Specification<PaymentAnalyticEntity> {

    private final List<SortingRequestDto> sortingDtos;

    public PFLoanFundsRqRegistryPaymentAnalyticSortingSpecification(List<SortingRequestDto> sortingDtos) {
        this.sortingDtos = sortingDtos;
    }

    @Override
    public Predicate toPredicate(Root<PaymentAnalyticEntity> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
        List<Order> orders = new ArrayList<>();

        if (sortingDtos != null && !sortingDtos.isEmpty()) {
            for (SortingRequestDto dto : sortingDtos) {
                boolean descending = dto.getSortDescending();
                String sortField = dto.getSortField().toUpperCase();

                switch (sortField) {
                    case "NUMBER" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.number), descending));
                    case "LOAN_FUNDS_REQUEST_STATUS" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.status), descending));
                    case "DATE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.date), descending));
                    case "FUNDS_TYPE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.fundsType), descending));
                    case "CREDIT_AGREEMENT" -> {
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.creditAgreementNumber), descending));
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.creditAgreementDate), descending));
                    }
                    case "PAYER_ACCOUNT" -> {
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.payerAccount), descending));
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.obcAccountFlag), descending));
                    }
                    case "TRANCHE_ISSUE_DATE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.trancheIssueDate), descending));
                    case "AMOUNT" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.amount), descending));
                    case "PAYMENT_PURPOSE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.paymentPurpose), descending));
                    case "RECIPIENT_NAME" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.recipientName), descending));
                    case "RECIPIENT_ACCOUNT" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.recipientAccount), descending));
                    case "DVRU" -> {
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.dvruNumber), descending));
                        orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.dvruDate), descending));
                    }
                    case "PAYMENT_TYPE" -> orders.add(createOrder(cb, root.get(PaymentAnalyticEntity_.paymentType), descending));
                    case "CODE" -> {
                        // Сортировка по вложенному полю "code" через метаклассы
                        Expression<String> codePath = root.join(PaymentAnalyticEntity_.paymentObjects)
                                                          .join(PaymentObjectEntity_.paymentObjectSsr)
                                                          .join(PaymentObjectSsrEntity_.paymentSsrArticles)
                                                          .get(PaymentSsrArticleEntity_.code);
                        orders.add(createOrder(cb, codePath, descending));
                    }
                    default -> throw new IllegalArgumentException("Unknown sorting field: " + sortField);
                }
            }
        } else {
            // Сортировка по умолчанию
            orders.add(cb.desc(root.get(PaymentAnalyticEntity_.date)));
        }

        query.orderBy(orders);
        return null; // Возвращаем null, так как только сортировка требуется
    }

    private Order createOrder(CriteriaBuilder cb, Expression<?> expression, boolean descending) {
        return descending ? cb.desc(expression) : cb.asc(expression);
    }
}
