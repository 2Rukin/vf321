@Query(value = "SELECT DISTINCT p " +
               "FROM PaymentAnalyticEntity p " +
               "LEFT JOIN FETCH p.paymentObjects po " +
               "LEFT JOIN FETCH po.paymentObjectSsr paymentSsr " +
               "LEFT JOIN FETCH paymentSsr.paymentSsrArticles articles",
       countQuery = "SELECT COUNT(DISTINCT p) FROM PaymentAnalyticEntity p")
Page<PaymentAnalyticEntity> findAllWithRelations(Specification<PaymentAnalyticEntity> spec, Pageable pageable);



Map<UUID, PFLloanFundsRqRegistryItemBo> analyticMap = new LinkedHashMap<>();

for (Tuple tuple : tuples) {
    UUID id = tuple.get(PaymentAnalyticEntity_.ID, UUID.class);

    // Верхний уровень: PFLloanFundsRqRegistryItemBo
    PFLloanFundsRqRegistryItemBo analyticDto = analyticMap.computeIfAbsent(id, k -> {
        PFLloanFundsRqRegistryItemBo dto = new PFLloanFundsRqRegistryItemBo();
        dto.setId(id);
        dto.setClientId(tuple.get(PaymentAnalyticEntity_.CLIENT_ID, UUID.class));
        dto.setPaymentDocumentId(tuple.get(PaymentAnalyticEntity_.PAYMENT_DOCUMENT_ID, UUID.class));
        dto.setNumber(tuple.get(PaymentAnalyticEntity_.NUMBER, Integer.class));
        dto.setStatus(tuple.get(PaymentAnalyticEntity_.STATUS, String.class));
        dto.setDate(tuple.get(PaymentAnalyticEntity_.DATE, LocalDate.class));

        // Инициализируем LinkedHashSet для гарантирования порядка вставки и уникальности по ID
        dto.setPaymentObjects(new LinkedHashSet<>());
        return dto;
    });

    // Второй уровень: PaymentObjectEntityBo
    UUID paymentObjectId = tuple.get(PaymentObjectEntity_.ID, UUID.class);
    String paymentObjectName = tuple.get(PaymentObjectEntity_.NAME, String.class);
    String projectName = tuple.get(PaymentObjectEntity_.PROJECT_NAME, String.class);

    if (paymentObjectId != null) {
        PaymentObjectEntityBo paymentObjectDto = analyticDto.getPaymentObjects()
            .stream()
            .filter(po -> paymentObjectId.equals(po.getId()))
            .findFirst()
            .orElseGet(() -> {
                PaymentObjectEntityBo newPaymentObject = new PaymentObjectEntityBo();
                newPaymentObject.setId(paymentObjectId);
                newPaymentObject.setName(paymentObjectName);
                newPaymentObject.setProjectName(projectName);

                // Третий уровень: PaymentObjectSsrEntityBo
                // Здесь один объект, но для статей используем LinkedHashSet
                PaymentObjectSsrEntityBo paymentObjectSsr = new PaymentObjectSsrEntityBo();
                paymentObjectSsr.setPaymentSsrArticles(new LinkedHashSet<>());
                newPaymentObject.setPaymentObjectSsr(paymentObjectSsr);

                analyticDto.getPaymentObjects().add(newPaymentObject);
                return newPaymentObject;
            });

        // Четвёртый уровень: PaymentSsrArticleEntityBo
        UUID articleId = tuple.get(PaymentSsrArticleEntity_.ID, UUID.class);
        String articleCode = tuple.get(PaymentSsrArticleEntity_.CODE, String.class);

        if (articleId != null) {
            boolean articleExists = paymentObjectDto.getPaymentObjectSsr().getPaymentSsrArticles()
                .stream()
                .anyMatch(article -> articleId.equals(article.getId()));

            if (!articleExists) {
                PaymentSsrArticleEntityBo articleDto = new PaymentSsrArticleEntityBo();
                articleDto.setId(articleId);
                articleDto.setCode(articleCode);

                paymentObjectDto.getPaymentObjectSsr().getPaymentSsrArticles().add(articleDto);
            }
        }
    }
}
