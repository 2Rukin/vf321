import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.Predicate;
import com.querydsl.jpa.impl.JPAQuery;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.support.PageableExecutionUtils;

import javax.persistence.EntityManager;
import java.util.List;

public class PaymentAnalyticRepositoryCustomImpl implements PaymentAnalyticRepositoryCustom {

    private final EntityManager entityManager;

    @Autowired
    public PaymentAnalyticRepositoryCustomImpl(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    @Override
    public Page<PaymentAnalyticDto> findAllWithFilters(Expression<PaymentAnalyticDto> projections,
                                                       Predicate predicate,
                                                       List<OrderSpecifier<?>> sortings,
                                                       Pageable pageable) {
        QPaymentAnalyticEntity paymentAnalyticEntity = QPaymentAnalyticEntity.paymentAnalyticEntity;

        // Основной запрос
        JPAQuery<PaymentAnalyticDto> query = new JPAQuery<>(entityManager)
                .select(projections)
                .from(paymentAnalyticEntity)
                .where(predicate)
                .orderBy(sortings.toArray(new OrderSpecifier[0]))
                .offset(pageable.getOffset())
                .limit(pageable.getPageSize());

        // Выполнение запроса и получение результатов
        List<PaymentAnalyticDto> results = query.fetch();

        // Подсчёт totalCount
        JPAQuery<Long> countQuery = new JPAQuery<>(entityManager)
                .select(paymentAnalyticEntity.count())
                .from(paymentAnalyticEntity)
                .where(predicate);

        // Возвращаем результат с пагинацией
        return PageableExecutionUtils.getPage(results, pageable, countQuery::fetchOne);
    }
}





public void merge(SubgraphDescriptor<?> other) {
    // Объединение атрибутов
    for (SingularAttribute<?, ?> attr : other.attributes) {
        if (!this.attributes.contains(attr)) {
            this.attributes.add((SingularAttribute<T, ?>) attr);
        }
    }

    // Объединение сабграфов
    if (other.subgraphs != null) {
        for (SubgraphDescriptor<?> nested : other.subgraphs) {
            Optional<SubgraphDescriptor<?>> existing = this.subgraphs.stream()
                    .filter(sg -> sg.getField().equals(nested.getField()))
                    .findFirst();

            if (existing.isPresent()) {
                // Рекурсивное объединение вложенных сабграфов
                existing.get().merge(nested);
            } else {
                // Добавляем новый вложенный сабграф
                SubgraphDescriptor<?> newNested = new SubgraphDescriptor<>(
                        nested.getField(),
                        new ArrayList<>(nested.getAttributes()),
                        new ArrayList<>(nested.getSubgraphs())  // Глубокое копирование вложенных сабграфов
                );
                this.subgraphs.add(newNested);
            }
        }
    }
}



### Решение для исправления маппинга с учётом динамических вложенных сущностей

Если структура данных может содержать **вложенные сущности**, и неизвестно заранее, какие именно поля были получены в результате запроса, то подход с использованием **MapStruct** можно усовершенствовать следующим образом:

---

### Основные принципы решения
1. **Проверка на `null`** перед маппингом вложенных объектов.
2. Использование **`default` методов** в интерфейсе MapStruct для кастомной логики маппинга.
3. Реализация вложенного маппинга через отдельные мапперы.

---

### Исправленный маппер

```java
@Mapper(componentModel = "spring", uses = {PaymentObjectMapper.class, PaymentObjectSsrMapper.class})
public interface PaymentAnalyticMapper {

    @Mapping(target = "id", source = "id")
    @Mapping(target = "clientId", source = "clientId")
    @Mapping(target = "paymentOrderId", source = "paymentDocumentId")
    @Mapping(target = "number", ignore = true)
    @Mapping(target = "loanFundsRequestStatus", ignore = true)
    @Mapping(target = "date", source = "date")
    @Mapping(target = "fundsType", source = "fundsType")
    @Mapping(target = "creditAgreementNumber", source = "creditAgreementNumber")
    @Mapping(target = "creditAgreementDate", source = "creditAgreementDate")
    @Mapping(target = "payerAccount", source = "payerAccount")
    @Mapping(target = "obcAccountFlag", source = "obcAccountFlag")
    @Mapping(target = "trancheIssueDate", source = "trancheIssueDate")
    @Mapping(target = "amount", source = "amount")
    @Mapping(target = "paymentPurpose", source = "paymentPurpose")
    @Mapping(target = "recipientName", source = "recipientName")
    @Mapping(target = "recipientAccount", source = "recipientAccount")
    @Mapping(target = "dvruNumber", source = "dvruNumber")
    @Mapping(target = "dvruDate", source = "dvruDate")
    @Mapping(target = "paymentType", source = "paymentType")
    @Mapping(target = "paymentObjects", source = "paymentObjects") // Вложенный маппинг
    PFLloanFundsRqRegistryItemDto toDto(PaymentAnalyticEntity paymentAnalyticEntity);

    List<PFLloanFundsRqRegistryItemDto> toDtoList(List<PaymentAnalyticEntity> paymentAnalyticEntities);
}
```

---

### Вложенный маппер для `PaymentObjectEntity`

```java
@Mapper(componentModel = "spring", uses = {PaymentObjectSsrMapper.class})
public interface PaymentObjectMapper {

    @Mapping(target = "name", source = "name")
    @Mapping(target = "projectName", source = "projectName")
    @Mapping(target = "paymentObjectSsr", source = "paymentObjectSsr")
    PaymentObjectDto toDto(PaymentObjectEntity paymentObjectEntity);

    default List<PaymentObjectDto> mapToDtoSet(Set<PaymentObjectEntity> entities) {
        if (entities == null) {
            return null;
        }
        return entities.stream()
                       .map(this::toDto)
                       .collect(Collectors.toList());
    }
}
```

---

### Вложенный маппер для `PaymentObjectSsrEntity`

```java
@Mapper(componentModel = "spring")
public interface PaymentObjectSsrMapper {

    @Mapping(target = "paymentSsrArticles", source = "paymentSsrArticles")
    PaymentObjectSsrDto toDto(PaymentObjectSsrEntity paymentObjectSsrEntity);

    default List<PaymentSsrArticleDto> mapSsrArticles(Set<PaymentSsrArticleEntity> articles) {
        if (articles == null) {
            return null;
        }
        return articles.stream()
                       .map(article -> new PaymentSsrArticleDto(article.getCode(), article.getName()))
                       .collect(Collectors.toList());
    }
}
```

---

### Ключевые детали:
1. **Методы `default` для работы с коллекциями**:  
   Например, метод `mapToDtoSet` конвертирует `Set<PaymentObjectEntity>` в `List<PaymentObjectDto>`. Это полезно, если вложенные сущности являются коллекциями.

2. **Рекурсивный маппинг**:  
   Мапперы `PaymentObjectMapper` и `PaymentObjectSsrMapper` используются для маппинга вложенных сущностей.

3. **Обработка `null`**:  
   Встроенные проверки `null` в `default` методах помогают избежать ошибок при обработке отсутствующих полей.

4. **`ignore = true` для полей**:  
   Если определённое поле отсутствует, оно просто игнорируется при маппинге.

---

### Пример выходной DTO-структуры:

```java
public class PFLloanFundsRqRegistryItemDto {
    private UUID id;
    private UUID clientId;
    private UUID paymentOrderId;
    private LocalDate date;
    private BigDecimal amount;
    private String paymentPurpose;
    private List<PaymentObjectDto> paymentObjects;
    // Другие поля...
}

public class PaymentObjectDto {
    private String name;
    private String projectName;
    private PaymentObjectSsrDto paymentObjectSsr;
}

public class PaymentObjectSsrDto {
    private List<PaymentSsrArticleDto> paymentSsrArticles;
}

public class PaymentSsrArticleDto {
    private String code;
    private String name;

    public PaymentSsrArticleDto(String code, String name) {
        this.code = code;
        this.name = name;
    }
}
```

---

### Итог

1. Использование **отдельных мапперов** для вложенных сущностей упрощает код.
2. Проверка на `null` помогает корректно обрабатывать отсутствующие поля.
3. Маппинг коллекций (`Set` и `List`) реализован через **`default` методы**.

Такое решение полностью **адаптивно** к динамически получаемым данным и позволяет избежать ошибок при маппинге вложенных сущностей.



Чтобы использовать **возможности метасущности** в аннотации `@Mapping` с MapStruct, можно обратиться к статическим полям метасущностей напрямую. Это обеспечивает типобезопасность и минимизирует ошибки при изменении полей сущностей.

---

### Исправленный маппер с использованием метасущностей

```java
@Mapper(componentModel = "spring", uses = {PaymentObjectMapper.class, PaymentObjectSsrMapper.class})
public interface PaymentAnalyticMapper {

    @Mapping(target = "id", source = PaymentAnalyticEntity_.ID) // Метасущность
    @Mapping(target = "clientId", source = PaymentAnalyticEntity_.CLIENT_ID)
    @Mapping(target = "paymentOrderId", source = PaymentAnalyticEntity_.PAYMENT_DOCUMENT_ID)
    @Mapping(target = "number", ignore = true)
    @Mapping(target = "loanFundsRequestStatus", ignore = true)
    @Mapping(target = "date", source = PaymentAnalyticEntity_.DATE)
    @Mapping(target = "fundsType", source = PaymentAnalyticEntity_.FUNDS_TYPE)
    @Mapping(target = "creditAgreementNumber", source = PaymentAnalyticEntity_.CREDIT_AGREEMENT_NUMBER)
    @Mapping(target = "creditAgreementDate", source = PaymentAnalyticEntity_.CREDIT_AGREEMENT_DATE)
    @Mapping(target = "payerAccount", source = PaymentAnalyticEntity_.PAYER_ACCOUNT)
    @Mapping(target = "obcAccountFlag", source = PaymentAnalyticEntity_.OBC_ACCOUNT_FLAG)
    @Mapping(target = "trancheIssueDate", source = PaymentAnalyticEntity_.TRANCHE_ISSUE_DATE)
    @Mapping(target = "amount", source = PaymentAnalyticEntity_.AMOUNT)
    @Mapping(target = "paymentPurpose", source = PaymentAnalyticEntity_.PAYMENT_PURPOSE)
    @Mapping(target = "recipientName", source = PaymentAnalyticEntity_.RECIPIENT_NAME)
    @Mapping(target = "recipientAccount", source = PaymentAnalyticEntity_.RECIPIENT_ACCOUNT)
    @Mapping(target = "dvruNumber", source = PaymentAnalyticEntity_.DVRU_NUMBER)
    @Mapping(target = "dvruDate", source = PaymentAnalyticEntity_.DVRU_DATE)
    @Mapping(target = "paymentType", source = PaymentAnalyticEntity_.PAYMENT_TYPE)
    @Mapping(target = "paymentObjects", source = PaymentAnalyticEntity_.PAYMENT_OBJECTS) // Вложенный маппинг
    PFLloanFundsRqRegistryItemDto toDto(PaymentAnalyticEntity paymentAnalyticEntity);

    List<PFLloanFundsRqRegistryItemDto> toDtoList(List<PaymentAnalyticEntity> paymentAnalyticEntities);
}
```

---

### Изменение в маппере вложенных объектов `PaymentObjectMapper`

Аналогично для `PaymentObjectMapper`:

```java
@Mapper(componentModel = "spring", uses = {PaymentObjectSsrMapper.class})
public interface PaymentObjectMapper {

    @Mapping(target = "name", source = PaymentObjectEntity_.NAME) // Метасущность
    @Mapping(target = "projectName", source = PaymentObjectEntity_.PROJECT_NAME)
    @Mapping(target = "paymentObjectSsr", source = PaymentObjectEntity_.PAYMENT_OBJECT_SSR)
    PaymentObjectDto toDto(PaymentObjectEntity paymentObjectEntity);

    default List<PaymentObjectDto> mapToDtoSet(Set<PaymentObjectEntity> entities) {
        if (entities == null) {
            return null;
        }
        return entities.stream()
                       .map(this::toDto)
                       .collect(Collectors.toList());
    }
}
```

---

### Почему это работает?

1. Метасущности, такие как `PaymentAnalyticEntity_.ID`, представляют собой статические поля, которые MapStruct может использовать для указания **источников данных**.  
2. Это значительно **повышает читаемость** кода и **облегчает поддержку**, так как ошибки именования будут автоматически отловлены на этапе компиляции.  
3. Это также делает ваш маппер **типобезопасным**, что полезно при больших структурах данных.

---

### Итог

Теперь аннотация `@Mapping` использует метасущности (например, `PaymentAnalyticEntity_.ID`) для указания источника, что обеспечивает более чистый и безопасный маппинг. Такой подход идеально подходит для поддержки динамических сущностей и больших структур.


Ниже приведён пример того, как расширить ваш `PaymentAnalyticRepository`, чтобы в сервисе можно было вызвать метод `findAllWithGraph(finalSpec, pageable, entityGraph, PaymentAnalyticEntity.class)` и получить результаты с учётом `EntityGraph`.

### 1. Создаём кастомный интерфейс репозитория

Создайте дополнительный интерфейс, где вы объявите нужный метод:

```java
public interface PaymentAnalyticRepositoryCustom {
    Page<PaymentAnalyticEntity> findAllWithGraph(Specification<PaymentAnalyticEntity> spec,
                                                 Pageable pageable,
                                                 EntityGraph<PaymentAnalyticEntity> entityGraph,
                                                 Class<PaymentAnalyticEntity> domainClass);
}
```

### 2. Реализуем этот интерфейс в кастомном классе репозитория

Создайте реализацию. Обычно она называется `PaymentAnalyticRepositoryImpl` (по соглашению Spring Data имя должно совпадать с именем вашего основного репозитория + `Impl`):

```java
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.TypedQuery;
import jakarta.persistence.criteria.*;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.EntityGraph;

import java.util.List;

public class PaymentAnalyticRepositoryImpl implements PaymentAnalyticRepositoryCustom {

    @PersistenceContext
    private EntityManager em;

    @Override
    public Page<PaymentAnalyticEntity> findAllWithGraph(Specification<PaymentAnalyticEntity> spec,
                                                        Pageable pageable,
                                                        EntityGraph<PaymentAnalyticEntity> entityGraph,
                                                        Class<PaymentAnalyticEntity> domainClass) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<PaymentAnalyticEntity> cq = cb.createQuery(domainClass);
        Root<PaymentAnalyticEntity> root = cq.from(domainClass);

        Predicate predicate = (spec != null) ? spec.toPredicate(root, cq, cb) : cb.conjunction();
        cq.where(predicate);

        // Применяем сортировку, если есть
        if (pageable.getSort().isSorted()) {
            List<Order> orders = pageable.getSort().stream()
                    .map(order -> order.isAscending() ? cb.asc(root.get(order.getProperty()))
                            : cb.desc(root.get(order.getProperty())))
                    .toList();
            cq.orderBy(orders);
        }

        TypedQuery<PaymentAnalyticEntity> query = em.createQuery(cq);

        // Применяем EntityGraph, если он есть
        if (entityGraph != null) {
            query.setHint("jakarta.persistence.loadgraph", entityGraph);
        }

        // Пагинация
        query.setFirstResult((int) pageable.getOffset());
        query.setMaxResults(pageable.getPageSize());

        List<PaymentAnalyticEntity> content = query.getResultList();

        // Подсчет количества (count)
        CriteriaQuery<Long> countCq = cb.createQuery(Long.class);
        Root<PaymentAnalyticEntity> countRoot = countCq.from(domainClass);
        countCq.select(cb.count(countRoot));
        if (spec != null) {
            countCq.where(spec.toPredicate(countRoot, countCq, cb));
        }
        Long total = em.createQuery(countCq).getSingleResult();

        return new PageImpl<>(content, pageable, total);
    }
}
```

### 3. Расширяем основной репозиторий

Теперь ваш `PaymentAnalyticRepository` должен наследоваться от основного базового репозитория и от вновь созданного `PaymentAnalyticRepositoryCustom`:

```java
public interface PaymentAnalyticRepository 
        extends BaseReadOnlyRepository<PaymentAnalyticEntity, UUID>,
                PaymentAnalyticRepositoryCustom {
}
```

Поскольку ваш `BaseReadOnlyRepository` расширяет `Repository`, Spring Data сможет сгенерировать основную часть, а `PaymentAnalyticRepositoryImpl` будет подхвачена как расширение репозитория (если вы используете стандартные пакеты и аннотации `@EnableJpaRepositories` без указания `repositoryBaseClass`, оно должно заработать автоматически).

### 4. Вызов из сервиса

Теперь в вашем сервисе вы можете вызывать:

```java
var res = repository.findAllWithGraph(finalSpec, pageable, entityGraph, PaymentAnalyticEntity.class);
```

и этот метод будет работать как ожидается, используя вашу реализацию для выборки данных с применением `Specification`, `Pageable`, и `EntityGraph`.



Проблема в том, что Spring пытается создать бин `EntityGraphCustomRepositoryImpl`, но вы передаёте ему `Class<T>` в конструктор, который Spring не знает, как инстанцировать. Схема с передачей `Class<T>` через конструктор в таком виде не сработает из коробки.

Когда вы работаете с `JpaRepository` и `JpaSpecificationExecutor`, Spring Data JPA генерирует реализации репозиториев автоматически, используя `SimpleJpaRepository` как базовый класс, или ваш кастомный базовый класс, если вы его указали. Если вы хотите добавить функциональность, связанную с `EntityGraph`, вам нужно интегрировать её в этот механизм, а не вручную создавать конструкторы, требующие `Class<T>`.

Есть два основных подхода:

### Подход 1: Использовать `JpaEntityInformation` для получения класса сущности

Вы можете создать базовый репозиторий, который получает `JpaEntityInformation<T, ?>` и `EntityManager` от Spring Data JPA. Тогда `Class<T>` можно извлечь из `entityInformation.getJavaType()`.

Пример:

```java
@NoRepositoryBean
public class EntityGraphCustomRepositoryImpl<T, ID extends Serializable>
        implements EntityGraphCustomRepository<T> {

    protected final EntityManager em;
    protected final Class<T> domainClass;

    public EntityGraphCustomRepositoryImpl(JpaEntityInformation<T, ID> entityInformation, EntityManager em) {
        this.em = em;
        this.domainClass = entityInformation.getJavaType();
    }

    @Override
    public Page<T> findAllWithGraph(Specification<T> spec, Pageable pageable, EntityGraph<T> entityGraph) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<T> cq = cb.createQuery(domainClass);
        Root<T> root = cq.from(domainClass);

        Predicate predicate = spec != null ? spec.toPredicate(root, cq, cb) : cb.conjunction();
        cq.where(predicate);

        if (pageable.getSort().isSorted()) {
            List<Order> orders = pageable.getSort().stream()
                    .map(order -> order.isAscending() ? cb.asc(root.get(order.getProperty()))
                            : cb.desc(root.get(order.getProperty())))
                    .toList();
            cq.orderBy(orders);
        }

        TypedQuery<T> query = em.createQuery(cq);
        if (entityGraph != null) {
            query.setHint("jakarta.persistence.loadgraph", entityGraph);
        }
        query.setFirstResult((int) pageable.getOffset());
        query.setMaxResults(pageable.getPageSize());

        List<T> content = query.getResultList();

        // Count
        CriteriaQuery<Long> countCq = cb.createQuery(Long.class);
        Root<T> countRoot = countCq.from(domainClass);
        countCq.select(cb.count(countRoot));
        if (spec != null) {
            countCq.where(spec.toPredicate(countRoot, countCq, cb));
        }

        Long total = em.createQuery(countCq).getSingleResult();

        return new PageImpl<>(content, pageable, total);
    }
}
```

### Обновление конфигурации `PaymentAnalyticRepository`

```java
public interface PaymentAnalyticRepository 
        extends BaseReadOnlyRepository<PaymentAnalyticEntity, UUID>,
                EntityGraphCustomRepository<PaymentAnalyticEntity>,
                JpaSpecificationExecutor<PaymentAnalyticEntity> {
}
```

`BaseReadOnlyRepository` должен быть помечен `@NoRepositoryBean`, если он абстрактный:

```java
@NoRepositoryBean
public interface BaseReadOnlyRepository<T, ID extends Serializable> 
        extends Repository<T, ID> {
}
```

### Включение кастомного базового класса репозиториев

В вашем `@EnableJpaRepositories` (обычно в конфигурационном классе Spring), укажите:

```java
@EnableJpaRepositories(
    basePackages = "your.package",
    repositoryBaseClass = EntityGraphCustomRepositoryImpl.class
)
```

Таким образом, Spring Data JPA будет использовать `EntityGraphCustomRepositoryImpl` как базовый класс для ваших репозиториев, и внедрит `JpaEntityInformation` и `EntityManager` автоматически.

### Сервис

В сервисе можно использовать ваш репозиторий напрямую:

```java
@Service
@RequiredArgsConstructor
public class PaymentAnalyticServiceImpl implements PaymentAnalyticService {

    private final PaymentAnalyticRepository repository;
    private final EntityManager entityManager;
    private final SortingService sortingService;

    public Page<PaymentAnalyticEntity> getWithGraph(Specification<PaymentAnalyticEntity> spec, Pageable pageable) {
        EntityGraph<PaymentAnalyticEntity> entityGraph = entityManager.createEntityGraph(PaymentAnalyticEntity.class);
        entityGraph.addAttributeNodes("paymentObjects"); // Пример

        return repository.findAllWithGraph(spec, pageable, entityGraph);
    }
}
```

### Итог

- Мы избавились от ручного конструктора, требующего `Class<T>`.
- Используем `JpaEntityInformation` и `EntityManager` для получения класса сущности.
- Через `@EnableJpaRepositories` настраиваем `repositoryBaseClass`, чтобы Spring использовал нашу кастомную реализацию.
- Теперь Spring сможет автоматически создать бин для репозитория без ошибок.


Если вы хотите использовать `EntityGraph` для подгрузки связанной структуры, а затем получить DTO, то более логичным подходом будет:

1. Сначала загрузить данные как сущности (`PaymentAnalyticEntity`), применяя `EntityGraph` для подгрузки нужных связей.
2. Затем, после получения списка сущностей, вручную (или с помощью маппера, вроде MapStruct) сконвертировать каждую сущность в `PaymentAnalyticDto`.

Таким образом вы сможете полноценно использовать возможности `EntityGraph` для управления графом загрузки сущностей, а потом уже "на уровне сервисного слоя" собрать DTO из загруженных сущностей.

Ниже приведён пример кода для этого подхода.

### Репозиторий

В репозитории мы откажемся от `cb.construct()` и будем возвращать сущности. Для этого можно использовать стандартный метод `findAll(Specification spec, Pageable pageable)` (если он у вас есть) или, если нужно, кастомный метод, который применит `EntityGraph`:

```java
public interface PaymentAnalyticRepository extends JpaRepository<PaymentAnalyticEntity, UUID>, JpaSpecificationExecutor<PaymentAnalyticEntity> {
}
```

Допустим, мы хотим использовать кастомный метод с графом. Тогда можно сделать так же, как и ранее, через кастомный репозиторий, только теперь без `cb.construct()`:

```java
public interface PaymentAnalyticCustomRepository {
    Page<PaymentAnalyticEntity> findAllWithGraphAsEntity(Specification<PaymentAnalyticEntity> spec,
                                                         Pageable pageable,
                                                         EntityGraph<PaymentAnalyticEntity> entityGraph);
}
```

Реализация:

```java
public class PaymentAnalyticCustomRepositoryImpl implements PaymentAnalyticCustomRepository {

    @PersistenceContext
    private EntityManager em;

    @Override
    public Page<PaymentAnalyticEntity> findAllWithGraphAsEntity(Specification<PaymentAnalyticEntity> spec,
                                                                Pageable pageable,
                                                                EntityGraph<PaymentAnalyticEntity> entityGraph) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<PaymentAnalyticEntity> cq = cb.createQuery(PaymentAnalyticEntity.class);
        Root<PaymentAnalyticEntity> root = cq.from(PaymentAnalyticEntity.class);

        Predicate predicate = spec != null ? spec.toPredicate(root, cq, cb) : cb.conjunction();
        cq.where(predicate);

        // Применим сортировку из pageable
        if (pageable.getSort().isSorted()) {
            List<Order> orders = pageable.getSort().stream()
                    .map(order -> order.isAscending() ? cb.asc(root.get(order.getProperty()))
                            : cb.desc(root.get(order.getProperty())))
                    .toList();
            cq.orderBy(orders);
        }

        TypedQuery<PaymentAnalyticEntity> query = em.createQuery(cq);
        query.setHint("jakarta.persistence.loadgraph", entityGraph);

        query.setFirstResult((int) pageable.getOffset());
        query.setMaxResults(pageable.getPageSize());
        List<PaymentAnalyticEntity> content = query.getResultList();

        // Count query
        CriteriaQuery<Long> countCq = cb.createQuery(Long.class);
        Root<PaymentAnalyticEntity> countRoot = countCq.from(PaymentAnalyticEntity.class);
        countCq.select(cb.count(countRoot)).where(spec != null ? spec.toPredicate(countRoot, countCq, cb) : cb.conjunction());
        Long total = em.createQuery(countCq).getSingleResult();

        return new PageImpl<>(content, pageable, total);
    }
}
```

### Сервис

В сервисе мы теперь получаем сущности, а затем мапим их в DTO. Предположим, что у вас есть статический метод или отдельный сервис для маппинга `PaymentAnalyticEntity` в `PaymentAnalyticDto`. Используем Lombok Builder для сборки DTO:

```java
@Service
public class PaymentAnalyticService {
    private final PaymentAnalyticRepository paymentAnalyticRepository;
    private final SortingService sortingService;

    @PersistenceContext
    private EntityManager entityManager;

    public PaymentAnalyticService(PaymentAnalyticRepository paymentAnalyticRepository,
                                  SortingService sortingService) {
        this.paymentAnalyticRepository = paymentAnalyticRepository;
        this.sortingService = sortingService;
    }

    @Transactional(readOnly = true)
    public PFLoanFundsRqRegistryResponse getFilteredSortingPageByRegistryCodes(Set<UUID> orgIds,
                                                                               PaginationRequestDto pagination,
                                                                               List<SortingRequestDto> sortingDtos,
                                                                               PFLoanFundsRqRegistryFilterDto requestFilter,
                                                                               List<RegistryCodes> fields) {

        // Создаём спецификации
        Specification<PaymentAnalyticEntity> orgIdsSpecification = (root, query, cb) ->
                (orgIds != null && !orgIds.isEmpty())
                        ? root.get(PaymentAnalyticEntity_.clientId).in(orgIds)
                        : cb.conjunction();

        Specification<PaymentAnalyticEntity> analyticSpec = new PFLoanFundsRqRegistryPaymentAnalyticFilterSpecification(requestFilter);
        Specification<PaymentAnalyticEntity> objectSpec = new PFLoanFundsRqRegistryPaymentObjectFilterSpecification(requestFilter);
        Specification<PaymentAnalyticEntity> ssrSpec = new PFLoanFundsRqRegistryPaymentSsrArticleFilterSpecification(requestFilter);

        Specification<PaymentAnalyticEntity> spec = new GenericSpecificationBuilder<PaymentAnalyticEntity>()
                .add(orgIdsSpecification)
                .add(analyticSpec)
                .add(objectSpec)
                .add(ssrSpec)
                .build();

        Sort sort = sortingService.getSort(sortingDtos);
        Pageable pageable = PageRequest.of(
                pagination != null ? pagination.getPageNumber() : 0,
                pagination != null ? pagination.getPageSize() : 10,
                sort
        );

        boolean needPaymentObject = fields.contains(RegistryCodes.PAYMENT_OBJECT);
        boolean needSsrArticle = fields.contains(RegistryCodes.SSR_ARTICLE);

        Page<PaymentAnalyticEntity> entityPage;

        if (needPaymentObject || needSsrArticle) {
            // Построим EntityGraph для сущности
            DynamicEntityGraphBuilder<PaymentAnalyticEntity> graphBuilder =
                    new DynamicEntityGraphBuilder<>(entityManager, PaymentAnalyticEntity.class);
            
            // Добавим базовую конфигурацию графа (например, только root поля)
            graphBuilder.addGraphConfiguration(get(RegistryCodes.DEFAULT));

            if (needPaymentObject) {
                graphBuilder.addGraphConfiguration(get(RegistryCodes.PAYMENT_OBJECT));
            }
            if (needSsrArticle) {
                graphBuilder.addGraphConfiguration(get(RegistryCodes.SSR_ARTICLE));
            }

            EntityGraph<PaymentAnalyticEntity> entityGraph = graphBuilder.build();

            entityPage = ((PaymentAnalyticCustomRepository)paymentAnalyticRepository)
                    .findAllWithGraphAsEntity(spec, pageable, entityGraph);

        } else {
            // Без графа можно использовать стандартный метод findAll c спецификацией:
            entityPage = paymentAnalyticRepository.findAll(spec, pageable);
        }

        // Теперь мапим сущности в DTO
        List<PaymentAnalyticDto> dtoList = entityPage.stream()
                .map(this::mapToDto)
                .toList();

        PFLoanFundsRqRegistryResponse response = new PFLoanFundsRqRegistryResponse();
        response.setTotalElements(entityPage.getTotalElements());
        response.setContent(dtoList);

        return response;
    }

    // Метод маппинга сущности в DTO
    private PaymentAnalyticDto mapToDto(PaymentAnalyticEntity entity) {
        // Строим DTO с помощью Lombok builder
        // Если PaymentObjectEntity и т.д. подгружены, их тоже мапим
        return PaymentAnalyticDto.builder()
                .id(entity.getId())
                .clientId(entity.getClientId())
                .paymentDocumentId(entity.getPaymentDocumentId())
                .number(entity.getNumber())
                .status(entity.getStatus())
                .date(entity.getDate())
                .fundsType(entity.getFundsType())
                .creditAgreementNumber(entity.getCreditAgreementNumber())
                .creditAgreementDate(entity.getCreditAgreementDate())
                .payerAccount(entity.getPayerAccount())
                .obcAccountFlag(entity.getObcAccountFlag())
                .trancheIssueDate(entity.getTrancheIssueDate())
                .amount(entity.getAmount())
                .paymentPurpose(entity.getPaymentPurpose())
                .recipientName(entity.getRecipientName())
                .recipientAccount(entity.getRecipientAccount())
                .dvruNumber(entity.getDvruNumber())
                .dvruDate(entity.getDvruDate())
                .paymentType(entity.getPaymentType())
                .paymentObjects(mapPaymentObjects(entity.getPaymentObjects()))
                .build();
    }

    private Set<PaymentAnalyticDto.PaymentObjectEntityDto> mapPaymentObjects(Set<PaymentObjectEntity> objects) {
        if (objects == null) return null;
        return objects.stream().map(o -> PaymentAnalyticDto.PaymentObjectEntityDto.builder()
                .name(o.getName())
                .projectName(o.getProjectName())
                .paymentObjectSsr(mapPaymentObjectSsr(o.getPaymentObjectSsr()))
                .build()
        ).collect(Collectors.toSet());
    }

    private PaymentAnalyticDto.PaymentObjectSsrEntityDto mapPaymentObjectSsr(PaymentObjectSsrEntity ssr) {
        if (ssr == null) return null;
        return PaymentAnalyticDto.PaymentObjectSsrEntityDto.builder()
                .paymentSsrArticles(mapPaymentSsrArticles(ssr.getPaymentSsrArticles()))
                .build();
    }

    private Set<PaymentAnalyticDto.PaymentSsrArticleDto> mapPaymentSsrArticles(Set<PaymentSsrArticleEntity> articles) {
        if (articles == null) return null;
        return articles.stream().map(a -> PaymentAnalyticDto.PaymentSsrArticleDto.builder()
                .code(a.getCode())
                .build()
        ).collect(Collectors.toSet());
    }

    private GraphConfiguration<PaymentAnalyticEntity> get(RegistryCodes code) {
        // Возвращаем конфигурацию графа
        // Примерно так:
        return switch (code) {
            case DEFAULT -> new GraphConfiguration<>(Set.of()); 
            case PAYMENT_OBJECT -> new GraphConfiguration<>(Set.of("paymentObjects", "paymentObjects.paymentObjectSsr"));
            case SSR_ARTICLE -> new GraphConfiguration<>(Set.of("paymentObjects.paymentObjectSsr.paymentSsrArticles"));
            default -> new GraphConfiguration<>(Set.of());
        };
    }
}
```

**Объяснение:**

- Мы отказываемся от `cb.construct(...)` в репозитории для DTO, вместо этого возвращаем сущности.
- Применяем `EntityGraph`, чтобы загрузить связанные сущности одним запросом.
- После получения сущностей в сервисном слое мапим их в `PaymentAnalyticDto` с помощью билдера.
- При отсутствии нужных полей или связей они просто будут `null`.
- Такой подход более гибкий: вы контролируете логику маппинга и не ограничены конструкторами или наличием всех полей в запросе.


import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageRequest;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.EntityGraph;
import jakarta.persistence.TypedQuery;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Root;
import jakarta.persistence.criteria.Predicate;

import java.util.List;
import java.util.Set;
import java.util.UUID;

@Service
public class PaymentAnalyticService {

    private final PaymentAnalyticRepository paymentAnalyticRepository;
    private final SortingService sortingService;
    @PersistenceContext
    private EntityManager entityManager;

    public PaymentAnalyticService(PaymentAnalyticRepository paymentAnalyticRepository,
                                  SortingService sortingService) {
        this.paymentAnalyticRepository = paymentAnalyticRepository;
        this.sortingService = sortingService;
    }

    @Transactional(readOnly = true)
    public PFLoanFundsRqRegistryResponse getFilteredSortingPageByRegistryCodes(Set<UUID> orgIds,
                                                                               PaginationRequestDto pagination,
                                                                               List<SortingRequestDto> sorting,
                                                                               PFLoanFundsRqRegistryFilterDto requestFilter,
                                                                               List<RegistryCodes> fields) {
        // 0. Спецификация по orgIds
        Specification<PaymentAnalyticEntity> orgIdsSpecification = (root, query, cb) ->
                orgIds != null && !orgIds.isEmpty()
                        ? root.get(PaymentAnalyticEntity_.clientId).in(orgIds)
                        : cb.conjunction();

        // 1. Спецификации из фильтров
        // Предположим, у вас есть классы спецификаций: 
        // PFLoanFundsRqRegistryPaymentAnalyticFilterSpecification,
        // PFLoanFundsRqRegistryPaymentObjectFilterSpecification,
        // PFLoanFundsRqRegistryPaymentSsrArticleFilterSpecification
        // которые реализуют Specification<PaymentAnalyticEntity> на основе requestFilter.
        
        Specification<PaymentAnalyticEntity> analyticSpec = new PFLoanFundsRqRegistryPaymentAnalyticFilterSpecification(requestFilter);
        Specification<PaymentAnalyticEntity> objectSpec = new PFLoanFundsRqRegistryPaymentObjectFilterSpecification(requestFilter);
        Specification<PaymentAnalyticEntity> ssrSpec = new PFLoanFundsRqRegistryPaymentSsrArticleFilterSpecification(requestFilter);

        // Собираем спецификации, которые не null и что-то фильтруют
        Specification<PaymentAnalyticEntity> builder = new GenericSpecificationBuilder<PaymentAnalyticEntity>()
                .add(orgIdsSpecification)
                .add(analyticSpec)
                .add(objectSpec)
                .add(ssrSpec)
                .build();

        // 2. Сортировка
        // Конвертируем DTO сортировки в Sort
        var sort = sortingService.getSort(sorting);

        // Pageable
        Pageable pageable = PageRequest.of(
                pagination != null ? pagination.getOffset() : 0,
                pagination != null ? pagination.getLimit() : 10,
                sort
        );

        // 3. Проверяем поля для загрузки графа
        boolean needPaymentObject = fields.contains(RegistryCodes.PAYMENT_OBJECT);
        boolean needSsrArticle = fields.contains(RegistryCodes.SSR_ARTICLE);

        // Если нужны вложенные сущности, строим динамический граф
        Page<PaymentAnalyticDto> resultPage;
        if (needPaymentObject || needSsrArticle) {
            // Построим EntityGraph динамически
            DynamicEntityGraphBuilder<PaymentAnalyticEntity> graphBuilder =
                    new DynamicEntityGraphBuilder<>(entityManager, PaymentAnalyticEntity.class);

            // Допустим, код DynamicEntityGraphBuilder таков, что вы можете добавить конфигурации
            // Если нужны paymentObjects
            if (needPaymentObject) {
                graphBuilder.addGraphConfiguration("paymentObjects");
                // Если нужно еще глубже:
                // graphBuilder.addGraphConfiguration("paymentObjects.paymentObjectSsr");
                // graphBuilder.addGraphConfiguration("paymentObjects.paymentObjectSsr.paymentSsrArticles");
            }

            if (needSsrArticle) {
                // Добавим атрибуты для ssrArticles
                graphBuilder.addGraphConfiguration("paymentObjects.paymentObjectSsr.paymentSsrArticles");
            }

            EntityGraph<PaymentAnalyticEntity> entityGraph = graphBuilder.build();

            // Выполняем запрос с использованием Specification и EntityGraph вручную, 
            // так как JpaSpecificationExecutor не дает напрямую добавить hints.
            // Но можно получить Predicate из Specification и построить TypedQuery вручную:

            CriteriaBuilder cb = entityManager.getCriteriaBuilder();
            CriteriaQuery<PaymentAnalyticDto> cq = cb.createQuery(PaymentAnalyticDto.class);
            Root<PaymentAnalyticEntity> root = cq.from(PaymentAnalyticEntity.class);

            Predicate pred = builder.toPredicate(root, cq, cb);
            cq.where(pred);

            // Projection в DTO через конструктор (аналогично тому, что в @Query репозитории)
            // Предположим, у PaymentAnalyticDto есть соответствующий @AllArgsConstructor или builder.
            // Для простоты покажем конструкцию через cb.construct:
            cq.select(cb.construct(
                    PaymentAnalyticDto.class,
                    root.get(PaymentAnalyticEntity_.id),
                    root.get(PaymentAnalyticEntity_.clientId),
                    root.get(PaymentAnalyticEntity_.paymentDocumentId),
                    root.get(PaymentAnalyticEntity_.number),
                    root.get(PaymentAnalyticEntity_.status),
                    root.get(PaymentAnalyticEntity_.date),
                    root.get(PaymentAnalyticEntity_.fundsType),
                    root.get(PaymentAnalyticEntity_.creditAgreementNumber),
                    root.get(PaymentAnalyticEntity_.creditAgreementDate),
                    root.get(PaymentAnalyticEntity_.payerAccount),
                    root.get(PaymentAnalyticEntity_.obcAccountFlag),
                    root.get(PaymentAnalyticEntity_.trancheIssueDate),
                    root.get(PaymentAnalyticEntity_.amount),
                    root.get(PaymentAnalyticEntity_.paymentPurpose),
                    root.get(PaymentAnalyticEntity_.recipientName),
                    root.get(PaymentAnalyticEntity_.recipientAccount),
                    root.get(PaymentAnalyticEntity_.dvruNumber),
                    root.get(PaymentAnalyticEntity_.dvruDate),
                    root.get(PaymentAnalyticEntity_.paymentType)
            ));

            // Добавим сортировки (Sort -> Orders)
            sort.forEach(order -> {
                if (order.isAscending()) {
                    cq.orderBy(cb.asc(root.get(order.getProperty())));
                } else {
                    cq.orderBy(cb.desc(root.get(order.getProperty())));
                }
            });

            TypedQuery<PaymentAnalyticDto> query = entityManager.createQuery(cq);
            query.setHint("jakarta.persistence.loadgraph", entityGraph);

            // Пагинация вручную
            query.setFirstResult((int) pageable.getOffset());
            query.setMaxResults(pageable.getPageSize());

            List<PaymentAnalyticDto> content = query.getResultList();

            // Получаем total count
            CriteriaQuery<Long> countCq = cb.createQuery(Long.class);
            Root<PaymentAnalyticEntity> countRoot = countCq.from(PaymentAnalyticEntity.class);
            countCq.select(cb.count(countRoot)).where(builder.toPredicate(countRoot, countCq, cb));
            Long total = entityManager.createQuery(countCq).getSingleResult();

            resultPage = new org.springframework.data.domain.PageImpl<>(content, pageable, total);
        } else {
            // Если граф не нужен, просто вызываем репозиторий
            resultPage = paymentAnalyticRepository.findAllAsDto(builder, pageable);
        }

        // Формируем ответ
        PFLoanFundsRqRegistryResponse response = new PFLoanFundsRqRegistryResponse();
        response.setTotalElements(resultPage.getTotalElements());
        response.setContent(resultPage.getContent());
        // Заполните остальные поля ответа по необходимости

        return response;
    }
}



public <X> GraphConfigurationBuilder<E> withSetSubgraph(SetAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
    // Явно приводим к PluralAttribute, чтобы компилятор распознал типы корректно.
    return withPluralSubgraph((PluralAttribute<E, X, ? extends Collection<X>>) field, builderConsumer);
}

public <X> GraphConfigurationBuilder<E> withListSubgraph(ListAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
    // Аналогично для ListAttribute
    return withPluralSubgraph((PluralAttribute<E, X, ? extends Collection<X>>) field, builderConsumer);
}

/**
 * Общий метод для обработки PluralAttribute (SetAttribute, ListAttribute)
 */
private <X, C extends Collection<X>> GraphConfigurationBuilder<E> withPluralSubgraph(
    PluralAttribute<E, X, C> field,
    Consumer<GraphConfigurationBuilder<X>> builderConsumer
) {
    @SuppressWarnings("unchecked")
    Class<X> elementClass = (Class<X>) field.getElementType().getJavaType();
    GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(elementClass);
    builderConsumer.accept(subBuilder);
    SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
    subgraphs.add(descriptor);
    return this;
}



public <X> GraphConfigurationBuilder<E> withSetSubgraph(SetAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
    return withPluralSubgraph(field, builderConsumer);
}

public <X> GraphConfigurationBuilder<E> withListSubgraph(ListAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
    return withPluralSubgraph(field, builderConsumer);
}

/**
 * Общий метод для обработки PluralAttribute (SetAttribute, ListAttribute)
 */
private <X, C extends Collection<X>> GraphConfigurationBuilder<E> withPluralSubgraph(
    PluralAttribute<E, X, C> field,
    Consumer<GraphConfigurationBuilder<X>> builderConsumer
) {
    @SuppressWarnings("unchecked")
    Class<X> elementClass = (Class<X>) field.getElementType().getJavaType();
    GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(elementClass);
    builderConsumer.accept(subBuilder);
    SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
    subgraphs.add(descriptor);
    return this;
}




Ниже представлен полный код решения с учётом всех предыдущих доработок. В нём:

- Используется строгая типизация без `? super E`.
- Реализованы методы для добавления сабграфов по одиночным атрибутам (`withSubgraph`), коллекционным атрибутам типа `Set` (`withSetSubgraph`) и `List` (`withListSubgraph`).
- `withAttributes` принимает параметры типа `SingularAttribute<E, ?>`, соответствующие текущему типу сущности.
- `SubgraphDescriptor` хранит конкретный тип T и соответствует атрибутам именно этой сущности.
- `DynamicEntityGraphBuilder` корректно обрабатывает корневой `EntityGraph` и вложенные `Subgraph`.

Вы можете адаптировать код под свои конкретные сущности и регистрировать конфигурации, как вам необходимо.

```java
import jakarta.persistence.EntityGraph;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Subgraph;
import jakarta.persistence.metamodel.CollectionAttribute;
import jakarta.persistence.metamodel.ListAttribute;
import jakarta.persistence.metamodel.PluralAttribute;
import jakarta.persistence.metamodel.SetAttribute;
import jakarta.persistence.metamodel.SingularAttribute;
import java.util.*;
import java.util.function.Consumer;

/**
 * Интерфейс конфигурации графа
 */
interface GraphConfiguration<T> {

    Class<T> getEntityClass();

    List<SingularAttribute<T, ?>> getAttributes();

    List<SubgraphDescriptor<?>> getSubgraphs();

    GraphConfiguration<T> merge(GraphConfiguration<T> other);

    static <E> GraphConfigurationBuilder<E> forEntity(Class<E> entityClass) {
        return new GraphConfigurationBuilder<>(entityClass);
    }
}

/**
 * Билдер для конфигураций графа
 */
class GraphConfigurationBuilder<E> implements GraphConfiguration<E> {

    private final Class<E> entityClass;
    private final List<SingularAttribute<E, ?>> attributes = new ArrayList<>();
    private final List<SubgraphDescriptor<?>> subgraphs = new ArrayList<>();

    public GraphConfigurationBuilder(Class<E> entityClass) {
        this.entityClass = entityClass;
    }

    @Override
    public Class<E> getEntityClass() {
        return entityClass;
    }

    @Override
    public List<SingularAttribute<E, ?>> getAttributes() {
        return attributes;
    }

    @Override
    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @Override
    public GraphConfiguration<E> merge(GraphConfiguration<E> other) {
        if (!other.getEntityClass().equals(this.entityClass)) {
            throw new IllegalArgumentException("Нельзя объединить конфигурации для разных сущностей");
        }
        // Объединяем атрибуты
        for (SingularAttribute<E, ?> attr : other.getAttributes()) {
            if (!attributes.contains(attr)) {
                attributes.add(attr);
            }
        }
        // Объединяем сабграфы
        mergeSubgraphs(this.subgraphs, other.getSubgraphs());
        return this;
    }

    private void mergeSubgraphs(List<SubgraphDescriptor<?>> target, List<SubgraphDescriptor<?>> source) {
        if (source == null) return;
        for (SubgraphDescriptor<?> sd : source) {
            Optional<SubgraphDescriptor<?>> existing = target.stream()
                .filter(t -> t.getField().equals(sd.getField()))
                .findFirst();
            if (existing.isPresent()) {
                existing.get().merge(sd);
            } else {
                target.add(sd);
            }
        }
    }

    @SafeVarargs
    public final GraphConfigurationBuilder<E> withAttributes(SingularAttribute<E, ?>... attrs) {
        for (SingularAttribute<E, ?> attr : attrs) {
            if (!attributes.contains(attr)) {
                attributes.add(attr);
            }
        }
        return this;
    }

    /**
     * Сабграф для одиночной связи (OneToOne/ManyToOne)
     */
    public <X> GraphConfigurationBuilder<E> withSubgraph(SingularAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getBindableJavaType());
        builderConsumer.accept(subBuilder);
        SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
        subgraphs.add(descriptor);
        return this;
    }

    /**
     * Сабграф для связи SetAttribute (OneToMany/ManyToMany, представленной как Set)
     */
    public <X> GraphConfigurationBuilder<E> withSetSubgraph(SetAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        return withPluralSubgraph(field, builderConsumer);
    }

    /**
     * Сабграф для связи ListAttribute (OneToMany/ManyToMany, представленной как List)
     */
    public <X> GraphConfigurationBuilder<E> withListSubgraph(ListAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        return withPluralSubgraph(field, builderConsumer);
    }

    /**
     * Общий метод для обработки PluralAttribute (SetAttribute, ListAttribute)
     */
    private <X, C extends Collection<X>> GraphConfigurationBuilder<E> withPluralSubgraph(PluralAttribute<E, X, C> field,
                                                                                         Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getElementType().getJavaType());
        builderConsumer.accept(subBuilder);
        SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
        subgraphs.add(descriptor);
        return this;
    }
}

/**
 * Описание сабграфа
 */
class SubgraphDescriptor<T> {
    private final Object field; // Может быть SingularAttribute или PluralAttribute
    private final List<SingularAttribute<T, ?>> attributes;
    private final List<SubgraphDescriptor<?>> subgraphs;

    public SubgraphDescriptor(Object field,
                              List<SingularAttribute<T, ?>> attributes,
                              List<SubgraphDescriptor<?>> subgraphs) {
        this.field = field;
        this.attributes = attributes == null ? new ArrayList<>() : new ArrayList<>(attributes);
        this.subgraphs = subgraphs == null ? new ArrayList<>() : new ArrayList<>(subgraphs);
    }

    public Object getField() {
        return field;
    }

    public List<SingularAttribute<T, ?>> getAttributes() {
        return attributes;
    }

    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @SuppressWarnings("unchecked")
    public void merge(SubgraphDescriptor<?> other) {
        // Объединение атрибутов
        for (SingularAttribute<?, ?> attr : other.attributes) {
            if (!this.attributes.contains(attr)) {
                this.attributes.add((SingularAttribute<T, ?>) attr);
            }
        }

        // Объединение сабграфов
        if (other.subgraphs != null) {
            for (SubgraphDescriptor<?> nested : other.subgraphs) {
                Optional<SubgraphDescriptor<?>> existing = this.subgraphs.stream()
                    .filter(sg -> sg.getField().equals(nested.getField()))
                    .findFirst();
                if (existing.isPresent()) {
                    existing.get().merge(nested);
                } else {
                    this.subgraphs.add(nested);
                }
            }
        }
    }
}

/**
 * Класс для динамического построения EntityGraph
 */
class DynamicEntityGraphBuilder<T> {
    private final EntityGraph<T> graph;
    private final Set<String> addedAttributes = new HashSet<>();
    private final Set<String> addedSubgraphs = new HashSet<>();

    public DynamicEntityGraphBuilder(EntityManager entityManager, Class<T> rootEntity) {
        this.graph = entityManager.createEntityGraph(rootEntity);
    }

    public DynamicEntityGraphBuilder<T> addGraphConfiguration(GraphConfiguration<T> configuration) {
        // Добавляем атрибуты
        if (configuration.getAttributes() != null) {
            for (SingularAttribute<T, ?> attribute : configuration.getAttributes()) {
                if (addedAttributes.add(attribute.getName())) {
                    graph.addAttributeNodes(attribute.getName());
                }
            }
        }

        // Добавляем сабграфы
        if (configuration.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> subgraphDescriptor : configuration.getSubgraphs()) {
                addSubgraph(graph, subgraphDescriptor);
            }
        }

        return this;
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private <X> void addSubgraph(Object parentGraph, SubgraphDescriptor<X> descriptor) {
        final String fieldName = (descriptor.getField() instanceof SingularAttribute)
            ? ((SingularAttribute) descriptor.getField()).getName()
            : ((PluralAttribute) descriptor.getField()).getName();

        String subgraphKey = parentGraph.getClass().getSimpleName() + ":" + fieldName;
        if (!addedSubgraphs.add(subgraphKey)) {
            return;
        }

        Subgraph<X> subgraph;
        if (parentGraph instanceof EntityGraph) {
            EntityGraph<?> entityGraph = (EntityGraph<?>) parentGraph;
            subgraph = (Subgraph<X>) entityGraph.addSubgraph(fieldName);
        } else if (parentGraph instanceof Subgraph) {
            Subgraph<?> parent = (Subgraph<?>) parentGraph;
            subgraph = (Subgraph<X>) parent.addSubgraph(fieldName);
        } else {
            throw new IllegalStateException("Unknown graph type: " + parentGraph.getClass());
        }

        if (descriptor.getAttributes() != null) {
            for (SingularAttribute<X, ?> attribute : descriptor.getAttributes()) {
                subgraph.addAttributeNodes(attribute.getName());
            }
        }

        if (descriptor.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> nestedDescriptor : descriptor.getSubgraphs()) {
                addSubgraph(subgraph, nestedDescriptor);
            }
        }
    }

    public EntityGraph<T> build() {
        return graph;
    }
}

/**
 * Пример использования:
 * 
 * configurations.put(RegistryCodes.PAYMENT_OBJECT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
 *     .withSetSubgraph(PaymentAnalyticEntity_.paymentObjects, subGraph -> subGraph
 *         .withAttributes(PaymentObjectEntity_.name, PaymentObjectEntity_.projectName)
 *     )
 * );
 * 
 * configurations.put(RegistryCodes.SSR_ARTICLE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
 *     .withSetSubgraph(PaymentAnalyticEntity_.paymentObjects, subGraph -> subGraph
 *         .withAttributes(PaymentObjectEntity_.name, PaymentObjectEntity_.projectName)
 *         .withSubgraph(PaymentObjectEntity_.paymentObjectSsr, ssrSubGraph -> ssrSubGraph
 *             .withSetSubgraph(PaymentObjectSsrEntity_.paymentSsrArticles, articlesSubGraph ->
 *                 articlesSubGraph.withAttributes(PaymentSsrArticleEntity_.code)
 *             )
 *         )
 *     )
 * );
 */

```

Данный код — основа решения. Вы можете расширять его и добавлять свои методы или изменять реализацию под ваши нужды.




Проблема возникает из-за использования ковариантных типов (`? super E`) в определении методов `withAttributes` и связанных с ними структур. В случае, когда мы строим граф для сущности `PaymentAnalyticEntity` и переходим к сабграфу для `PaymentObjectEntity`, нам нужны строго типизированные атрибуты без `? super`.

**Ключевая идея**:  
Каждый `GraphConfigurationBuilder<E>` оперирует строго атрибутами и сабграфами для типа `E`. Когда мы вызываем `withCollectionSubgraph` или `withSubgraph`, мы фактически "переходим" к новому билдеру для типа `X`, соответствующему целевой сущности сабграфа. Таким образом, в сабграфе можно безопасно использовать `SingularAttribute<X, ?>` без понижающих преобразований.

**Исправления**:

1. Уберите использование `? super E` в методе `withAttributes`. Пусть метод принимает строго `SingularAttribute<E, ?>... attrs`.

2. Аналогично уберите `? super` из сигнатур конструкторов сабграфов и `SubgraphDescriptor`. Там, где мы ранее писали `List<SingularAttribute<? super T, ?>>`, используйте `List<SingularAttribute<T, ?>>`. Это возможно, поскольку при создании сабграфа мы уже точно знаем тип сущности `T`.

**Пример исправленного кода фрагмента**:

```java
class GraphConfigurationBuilder<E> implements GraphConfiguration<E> {
    private final Class<E> entityClass;
    private final List<SingularAttribute<E, ?>> attributes = new ArrayList<>();
    private final List<SubgraphDescriptor<?>> subgraphs = new ArrayList<>();

    public GraphConfigurationBuilder(Class<E> entityClass) {
        this.entityClass = entityClass;
    }

    @Override
    public Class<E> getEntityClass() {
        return entityClass;
    }

    @Override
    public List<SingularAttribute<E, ?>> getAttributes() {
        return attributes;
    }

    @Override
    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @Override
    public GraphConfiguration<E> merge(GraphConfiguration<E> other) {
        if (!other.getEntityClass().equals(this.entityClass)) {
            throw new IllegalArgumentException("Невозможно объединить конфигурации для разных сущностей");
        }
        for (SingularAttribute<E, ?> attr : other.getAttributes()) {
            if (!this.attributes.contains(attr)) {
                this.attributes.add(attr);
            }
        }
        mergeSubgraphs(this.subgraphs, other.getSubgraphs());
        return this;
    }

    @SafeVarargs
    public final GraphConfigurationBuilder<E> withAttributes(SingularAttribute<E, ?>... attrs) {
        for (SingularAttribute<E, ?> attr : attrs) {
            if (!attributes.contains(attr)) {
                attributes.add(attr);
            }
        }
        return this;
    }

    public <X> GraphConfigurationBuilder<E> withSubgraph(SingularAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getBindableJavaType());
        builderConsumer.accept(subBuilder);
        SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
        subgraphs.add(descriptor);
        return this;
    }

    public <X> GraphConfigurationBuilder<E> withCollectionSubgraph(CollectionAttribute<E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getElementType().getJavaType());
        builderConsumer.accept(subBuilder);
        SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
        subgraphs.add(descriptor);
        return this;
    }

    private void mergeSubgraphs(List<SubgraphDescriptor<?>> target, List<SubgraphDescriptor<?>> source) {
        if (source == null) return;
        for (SubgraphDescriptor<?> sd : source) {
            Optional<SubgraphDescriptor<?>> existing = target.stream()
                    .filter(t -> t.getField().equals(sd.getField()))
                    .findFirst();
            if (existing.isPresent()) {
                existing.get().merge(sd);
            } else {
                target.add(sd);
            }
        }
    }
}

class SubgraphDescriptor<T> {
    private final Object field;
    private final List<SingularAttribute<T, ?>> attributes;
    private final List<SubgraphDescriptor<?>> subgraphs;

    public SubgraphDescriptor(Object field,
                              List<SingularAttribute<T, ?>> attributes,
                              List<SubgraphDescriptor<?>> subgraphs) {
        this.field = field;
        this.attributes = attributes == null ? new ArrayList<>() : new ArrayList<>(attributes);
        this.subgraphs = subgraphs == null ? new ArrayList<>() : new ArrayList<>(subgraphs);
    }

    public Object getField() {
        return field;
    }

    public List<SingularAttribute<T, ?>> getAttributes() {
        return attributes;
    }

    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @SuppressWarnings("unchecked")
    public void merge(SubgraphDescriptor<?> other) {
        for (SingularAttribute<?, ?> attr : other.attributes) {
            if (!this.attributes.contains(attr)) {
                this.attributes.add((SingularAttribute<T, ?>) attr);
            }
        }
        if (other.subgraphs != null) {
            for (SubgraphDescriptor<?> nested : other.subgraphs) {
                Optional<SubgraphDescriptor<?>> existing = this.subgraphs.stream()
                        .filter(sg -> sg.getField().equals(nested.getField()))
                        .findFirst();
                if (existing.isPresent()) {
                    existing.get().merge(nested);
                } else {
                    this.subgraphs.add(nested);
                }
            }
        }
    }
}
```

После этих изменений вы сможете писать:

```java
configurations.put(RegistryCodes.PAYMENT_OBJECT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
    .withCollectionSubgraph(PaymentAnalyticEntity_.paymentObjects, subGraph -> subGraph
        .withAttributes(PaymentObjectEntity_.name, PaymentObjectEntity_.projectName)
    )
);
```

Здесь `subGraph` — это `GraphConfigurationBuilder<PaymentObjectEntity>`, и вы передаете ему `SingularAttribute<PaymentObjectEntity, String>`, что полностью соответствует ожидаемым параметрам типа. Таким образом, проблема с несоответствием типов будет решена.


class PFLloanFundsRqRegistryGraphConfigurationRegistry {
    private final Map<RegistryCodes, GraphConfiguration<?>> configurations = new HashMap<>();

    public PFLloanFundsRqRegistryGraphConfigurationRegistry() {
        configurations.put(RegistryCodes.DEFAULT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(
                PaymentAnalyticEntity_.id,
                PaymentAnalyticEntity_.clientId,
                PaymentAnalyticEntity_.paymentDocumentId
            )
        );

        configurations.put(RegistryCodes.NUMBER, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.number));

        configurations.put(RegistryCodes.LOAN_FUNDS_REQUEST_STATUS, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.status));

        configurations.put(RegistryCodes.DATE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.date));

        configurations.put(RegistryCodes.FUNDS_TYPE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.fundsType));

        configurations.put(RegistryCodes.CREDIT_AGREEMENT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.creditAgreementNumber, PaymentAnalyticEntity_.creditAgreementDate));

        configurations.put(RegistryCodes.PAYER_ACCOUNT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.payerAccount, PaymentAnalyticEntity_.obcAccountFlag));

        configurations.put(RegistryCodes.TRANCHE_ISSUE_DATE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.trancheIssueDate));

        configurations.put(RegistryCodes.AMOUNT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.amount));

        configurations.put(RegistryCodes.PAYMENT_PURPOSE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.paymentPurpose));

        configurations.put(RegistryCodes.RECIPIENT_ACCOUNT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.recipientAccount));

        configurations.put(RegistryCodes.DVRU, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withAttributes(PaymentAnalyticEntity_.dvruNumber, PaymentAnalyticEntity_.dvruDate));

        // paymentObjects - коллекция, значит используем withCollectionSubgraph
        configurations.put(RegistryCodes.PAYMENT_OBJECT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withCollectionSubgraph(PaymentAnalyticEntity_.paymentObjects, subGraph -> subGraph
                .withAttributes(PaymentObjectEntity_.name, PaymentObjectEntity_.projectName)
            )
        );

        configurations.put(RegistryCodes.SSR_ARTICLE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
            .withCollectionSubgraph(PaymentAnalyticEntity_.paymentObjects, subGraph -> subGraph
                .withAttributes(PaymentObjectEntity_.name, PaymentObjectEntity_.projectName)
                // paymentObjectSsr - одиночная связь, используем withSubgraph
                .withSubgraph(PaymentObjectEntity_.paymentObjectSsr, objectSubGraph -> objectSubGraph
                    // paymentSsrArticles - коллекция
                    .withCollectionSubgraph(PaymentObjectSsrEntity_.paymentSsrArticles, paymentSsrArticlesSubGraph ->
                        paymentSsrArticlesSubGraph.withAttributes(PaymentSsrArticleEntity_.code)
                    )
                )
            )
        );
    }

    public boolean contains(RegistryCodes code) {
        return configurations.containsKey(code);
    }

    @SuppressWarnings("unchecked")
    public <T> GraphConfiguration<T> get(RegistryCodes code) {
        return (GraphConfiguration<T>) configurations.get(code);
    }
}


class DynamicEntityGraphBuilder<T> {

    private final EntityGraph<T> graph;
    private final Set<String> addedAttributes = new HashSet<>();
    private final Set<String> addedSubgraphs = new HashSet<>();

    public DynamicEntityGraphBuilder(EntityManager entityManager, Class<T> rootEntity) {
        this.graph = entityManager.createEntityGraph(rootEntity);
    }

    public DynamicEntityGraphBuilder<T> addGraphConfiguration(GraphConfiguration<T> configuration) {
        // Добавляем атрибуты
        if (configuration.getAttributes() != null) {
            for (SingularAttribute<? super T, ?> attribute : configuration.getAttributes()) {
                if (addedAttributes.add(attribute.getName())) {
                    graph.addAttributeNodes(attribute.getName());
                }
            }
        }

        // Добавляем сабграфы
        if (configuration.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> subgraphDescriptor : configuration.getSubgraphs()) {
                // Передаем graph (EntityGraph<T>) и subgraphDescriptor
                addSubgraph(graph, subgraphDescriptor);
            }
        }

        return this;
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private <X> void addSubgraph(Object parentGraph, SubgraphDescriptor<X> descriptor) {
        // Определяем имя поля по SingularAttribute или CollectionAttribute
        final String fieldName = (descriptor.getField() instanceof SingularAttribute)
                ? ((SingularAttribute) descriptor.getField()).getName()
                : ((CollectionAttribute) descriptor.getField()).getName();

        String subgraphKey = parentGraph.getClass().getSimpleName() + ":" + fieldName;
        if (!addedSubgraphs.add(subgraphKey)) {
            return; // Сабграф уже добавлен
        }

        // Создаем subgraph в зависимости от типа parentGraph
        Subgraph<X> subgraph;
        if (parentGraph instanceof EntityGraph) {
            // parentGraph - это корневой граф
            EntityGraph<?> entityGraph = (EntityGraph<?>) parentGraph;
            subgraph = (Subgraph<X>) entityGraph.addSubgraph(fieldName);
        } else if (parentGraph instanceof Subgraph) {
            // parentGraph - это вложенный субграф
            Subgraph<?> parent = (Subgraph<?>) parentGraph;
            subgraph = (Subgraph<X>) parent.addSubgraph(fieldName);
        } else {
            throw new IllegalStateException("Unknown graph type: " + parentGraph.getClass());
        }

        // Добавляем атрибуты в текущий сабграф
        if (descriptor.getAttributes() != null) {
            for (SingularAttribute<? super X, ?> attribute : descriptor.getAttributes()) {
                subgraph.addAttributeNodes(attribute.getName());
            }
        }

        // Рекурсивно добавляем вложенные сабграфы
        if (descriptor.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> nestedDescriptor : descriptor.getSubgraphs()) {
                addSubgraph(subgraph, nestedDescriptor);
            }
        }
    }

    public EntityGraph<T> build() {
        return graph;
    }
}


Ниже приведен доработанный вариант кода, который использует дженерики и ковариантность таким образом, чтобы избежать явных приведения типов (кастов). Основная идея:

1. **Использовать `? super E` для атрибутов**:  
   Вместо `List<SingularAttribute<E, ?>>` мы используем `List<SingularAttribute<? super E, ?>>`. Это позволит без проблем добавлять атрибуты для сущности `E` и её суперклассов и одновременно передавать их в `SubgraphDescriptor`, не нарушая типизацию.

2. **Единообразный подход к типам**:  
   - В `GraphConfigurationBuilder<E>` мы храним `List<SingularAttribute<? super E, ?>> attributes`.
   - При создании сабграфов (как для одиночных связей, так и для коллекционных) мы создаем новый `GraphConfigurationBuilder<X>` для подтипа `X` (определяемого через метамодель атрибута) и также используем `List<SingularAttribute<? super X, ?>>`.
   - В `SubgraphDescriptor<T>` тоже используем `List<SingularAttribute<? super T, ?>>`.  
   
   Благодаря этому у нас не будет проблем с несовпадающими дженериками, и мы сможем напрямую передавать списки атрибутов без кастов.

3. **Без явных кастов**:  
   Мы отказались от попытки строго ограничить дженерики до `E` и используем `? super E`, что дает больше гибкости. При этом мы не теряем типобезопасность, так как метамодельные классы сами по себе гарантируют корректную типизацию полей.

Ниже приведен пример полного решения с учетом данной логики.

```java
import jakarta.persistence.EntityGraph;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Subgraph;
import jakarta.persistence.metamodel.CollectionAttribute;
import jakarta.persistence.metamodel.SingularAttribute;
import java.util.*;
import java.util.function.Consumer;

/**
 * Конфигурация графа
 */
interface GraphConfiguration<T> {

    Class<T> getEntityClass();

    List<SingularAttribute<? super T, ?>> getAttributes();

    List<SubgraphDescriptor<?>> getSubgraphs();

    GraphConfiguration<T> merge(GraphConfiguration<T> other);

    static <E> GraphConfigurationBuilder<E> forEntity(Class<E> entityClass) {
        return new GraphConfigurationBuilder<>(entityClass);
    }
}


/**
 * Билдер для создания GraphConfiguration с DSL-подобным API
 */
class GraphConfigurationBuilder<E> implements GraphConfiguration<E> {

    private final Class<E> entityClass;
    private final List<SingularAttribute<? super E, ?>> attributes = new ArrayList<>();
    private final List<SubgraphDescriptor<?>> subgraphs = new ArrayList<>();

    public GraphConfigurationBuilder(Class<E> entityClass) {
        this.entityClass = entityClass;
    }

    @Override
    public Class<E> getEntityClass() {
        return entityClass;
    }

    @Override
    public List<SingularAttribute<? super E, ?>> getAttributes() {
        return attributes;
    }

    @Override
    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @Override
    public GraphConfiguration<E> merge(GraphConfiguration<E> other) {
        if (!other.getEntityClass().equals(this.entityClass)) {
            throw new IllegalArgumentException("Невозможно объединить конфигурации для разных сущностей");
        }
        // Добавляем атрибуты
        for (SingularAttribute<? super E, ?> attr : other.getAttributes()) {
            if (!this.attributes.contains(attr)) {
                this.attributes.add(attr);
            }
        }
        // Добавляем сабграфы
        mergeSubgraphs(this.subgraphs, other.getSubgraphs());
        return this;
    }

    private void mergeSubgraphs(List<SubgraphDescriptor<?>> target, List<SubgraphDescriptor<?>> source) {
        if (source == null) return;
        for (SubgraphDescriptor<?> sd : source) {
            Optional<SubgraphDescriptor<?>> existing = target.stream()
                    .filter(t -> t.getField().equals(sd.getField()))
                    .findFirst();
            if (existing.isPresent()) {
                existing.get().merge(sd);
            } else {
                target.add(sd);
            }
        }
    }

    @SafeVarargs
    public final GraphConfigurationBuilder<E> withAttributes(SingularAttribute<? super E, ?>... attrs) {
        for (SingularAttribute<? super E, ?> attr : attrs) {
            if (!attributes.contains(attr)) {
                attributes.add(attr);
            }
        }
        return this;
    }

    /**
     * Сабграф для одиночной ассоциации (OneToOne/ManyToOne)
     */
    public <X> GraphConfigurationBuilder<E> withSubgraph(SingularAttribute<? super E, X> field,
                                                         Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getBindableJavaType());
        builderConsumer.accept(subBuilder);
        SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
        subgraphs.add(descriptor);
        return this;
    }

    /**
     * Сабграф для коллекционной ассоциации (OneToMany/ManyToMany)
     */
    public <X> GraphConfigurationBuilder<E> withCollectionSubgraph(CollectionAttribute<? super E, X> field,
                                                                   Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
        GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getElementType().getJavaType());
        builderConsumer.accept(subBuilder);
        SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
        subgraphs.add(descriptor);
        return this;
    }
}


/**
 * Описание сабграфа
 */
class SubgraphDescriptor<T> {
    private final Object field; // Может быть SingularAttribute или CollectionAttribute
    private final List<SingularAttribute<? super T, ?>> attributes;
    private final List<SubgraphDescriptor<?>> subgraphs;

    public SubgraphDescriptor(Object field,
                              List<SingularAttribute<? super T, ?>> attributes,
                              List<SubgraphDescriptor<?>> subgraphs) {
        this.field = field;
        this.attributes = attributes == null ? new ArrayList<>() : new ArrayList<>(attributes);
        this.subgraphs = subgraphs == null ? new ArrayList<>() : new ArrayList<>(subgraphs);
    }

    public Object getField() {
        return field;
    }

    public List<SingularAttribute<? super T, ?>> getAttributes() {
        return attributes;
    }

    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @SuppressWarnings("unchecked")
    public void merge(SubgraphDescriptor<?> other) {
        for (SingularAttribute<?, ?> attr : other.attributes) {
            if (!this.attributes.contains(attr)) {
                // Здесь можно безопасно сделать приведение, так как типы согласованы метамоделью
                this.attributes.add((SingularAttribute<? super T, ?>) attr);
            }
        }

        if (other.subgraphs != null) {
            for (SubgraphDescriptor<?> nested : other.subgraphs) {
                Optional<SubgraphDescriptor<?>> existing = this.subgraphs.stream()
                        .filter(sg -> sg.getField().equals(nested.getField()))
                        .findFirst();
                if (existing.isPresent()) {
                    existing.get().merge(nested);
                } else {
                    this.subgraphs.add(nested);
                }
            }
        }
    }
}

/**
 * Строитель динамического графа
 */
class DynamicEntityGraphBuilder<T> {
    private final EntityGraph<T> graph;
    private final Set<String> addedAttributes = new HashSet<>();
    private final Set<String> addedSubgraphs = new HashSet<>();

    public DynamicEntityGraphBuilder(EntityManager entityManager, Class<T> rootEntity) {
        this.graph = entityManager.createEntityGraph(rootEntity);
    }

    public DynamicEntityGraphBuilder<T> addGraphConfiguration(GraphConfiguration<T> configuration) {
        // Добавляем атрибуты
        if (configuration.getAttributes() != null) {
            for (SingularAttribute<? super T, ?> attribute : configuration.getAttributes()) {
                if (addedAttributes.add(attribute.getName())) {
                    graph.addAttributeNodes(attribute.getName());
                }
            }
        }
        // Добавляем сабграфы
        if (configuration.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> subgraphDescriptor : configuration.getSubgraphs()) {
                addSubgraph(graph, subgraphDescriptor);
            }
        }

        return this;
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private <X> void addSubgraph(Subgraph<X> parentGraph, SubgraphDescriptor<X> descriptor) {
        final String fieldName = (descriptor.getField() instanceof SingularAttribute)
                ? ((SingularAttribute) descriptor.getField()).getName()
                : ((CollectionAttribute) descriptor.getField()).getName();

        String subgraphKey = parentGraph.getClass().getSimpleName() + ":" + fieldName;
        if (!addedSubgraphs.add(subgraphKey)) {
            return;
        }

        Subgraph<X> subgraph = parentGraph.addSubgraph(fieldName);
        if (descriptor.getAttributes() != null) {
            for (SingularAttribute<? super X, ?> attribute : descriptor.getAttributes()) {
                subgraph.addAttributeNodes(attribute.getName());
            }
        }

        if (descriptor.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> nestedDescriptor : descriptor.getSubgraphs()) {
                addSubgraph(subgraph, nestedDescriptor);
            }
        }
    }

    public EntityGraph<T> build() {
        return graph;
    }
}
```

**Что мы получили:**

- **Типобезопасный DSL**: 
  Мы можем вызывать `withAttributes(...)`, `withSubgraph(...)` или `withCollectionSubgraph(...)` без кастинга и ошибок типов.
  
- **Работа с вложенными коллекциями**: 
  Для коллекций (`SetAttribute`, `ListAttribute`) используем `withCollectionSubgraph(...)`, для одиночных ассоциаций — `withSubgraph(...)`.
  
- **Нет явных кастов при создании сабграфов**: 
  Мы ослабили ограничения типизации до `? super E`, что позволило обойтись без явных приведения типов.

Таким образом, это решение позволяет удобно и безопасно строить сложные графы для таких структур, как `PaymentAnalyticDto` с вложенными сущностями.






Ниже представлен скорректированный вариант подхода, учитывая проблему с типами атрибутов в сабграфах, а также различия между одиночными и коллекционными ассоциациями. Основная идея:  
- В `GraphConfigurationBuilder` добавить отдельные методы для сабграфов по одиночным (`SingularAttribute`) и коллекционным (`CollectionAttribute`) связям.  
- Убедиться, что метамодельные атрибуты (`_paymentObjects`, `_code`, `_name`, `_projectName`) соответствуют типам сущностей, в которых они определены.  
- Если `PaymentAnalyticEntity._paymentObjects` — это коллекция (например, `ListAttribute<PaymentAnalyticEntity, PaymentObjectEntity>`), то используем метод `withCollectionSubgraph(...)`, чтобы DSL корректно собрал конфигурацию для сабграфа коллекции.

**Основные изменения:**
1. Добавлен метод `withCollectionSubgraph` в билдер.  
2. Типы `withSubgraph` теперь чётко различают singular и collection атрибуты.  
3. В примере регистрации `RegistryCodes.PAYMENT_OBJECT` и `RegistryCodes.SSR_ARTICLE` используем `withCollectionSubgraph`, если `PaymentAnalyticEntity._paymentObjects` — это коллекция.
4. Проверить, что в вашем JPA метамоделе `PaymentObjectEntity._name` и `PaymentObjectEntity._projectName` являются `SingularAttribute<PaymentObjectEntity, String>`, а `PaymentSsrArticleEntity._code` — это `SingularAttribute<PaymentSsrArticleEntity, String>`.

```java
import jakarta.persistence.EntityGraph;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Subgraph;
import jakarta.persistence.metamodel.CollectionAttribute;
import jakarta.persistence.metamodel.SingularAttribute;
import java.util.*;
import java.util.function.Consumer;

enum RegistryCodes {
    DEFAULT,
    NUMBER,
    LOAN_FUNDS_REQUEST_STATUS,
    DATE,
    FUNDS_TYPE,
    CREDIT_AGREEMENT,
    PAYER_ACCOUNT,
    TRANCHE_ISSUE_DATE,
    AMOUNT,
    PAYMENT_PURPOSE,
    RECIPIENT_ACCOUNT,
    DVRU,
    PAYMENT_OBJECT,
    SSR_ARTICLE
}

interface GraphConfiguration<T> {

    Class<T> getEntityClass();
    List<SingularAttribute<?, ?>> getAttributes();
    List<SubgraphDescriptor<?>> getSubgraphs();

    GraphConfiguration<T> merge(GraphConfiguration<T> other);

    static <E> GraphConfigurationBuilder<E> forEntity(Class<E> entityClass) {
        return new GraphConfigurationBuilder<>(entityClass);
    }

    class GraphConfigurationBuilder<E> implements GraphConfiguration<E> {
        private final Class<E> entityClass;
        private final List<SingularAttribute<?, ?>> attributes = new ArrayList<>();
        private final List<SubgraphDescriptor<?>> subgraphs = new ArrayList<>();

        public GraphConfigurationBuilder(Class<E> entityClass) {
            this.entityClass = entityClass;
        }

        @Override
        public Class<E> getEntityClass() {
            return entityClass;
        }

        @Override
        public List<SingularAttribute<?, ?>> getAttributes() {
            return attributes;
        }

        @Override
        public List<SubgraphDescriptor<?>> getSubgraphs() {
            return subgraphs.isEmpty() ? null : subgraphs;
        }

        @Override
        public GraphConfiguration<E> merge(GraphConfiguration<E> other) {
            if (!other.getEntityClass().equals(this.entityClass)) {
                throw new IllegalArgumentException("Невозможно объединить конфигурации для разных сущностей");
            }
            // Добавляем атрибуты
            for (SingularAttribute<?, ?> attr : other.getAttributes()) {
                if (!this.attributes.contains(attr)) {
                    this.attributes.add(attr);
                }
            }
            // Добавляем сабграфы
            mergeSubgraphs(this.subgraphs, other.getSubgraphs());
            return this;
        }

        private void mergeSubgraphs(List<SubgraphDescriptor<?>> target, List<SubgraphDescriptor<?>> source) {
            if (source == null) return;

            for (SubgraphDescriptor<?> sd : source) {
                Optional<SubgraphDescriptor<?>> existing = target.stream()
                    .filter(t -> t.getField().equals(sd.getField()))
                    .findFirst();
                if (existing.isPresent()) {
                    existing.get().merge(sd);
                } else {
                    target.add(sd);
                }
            }
        }

        @SafeVarargs
        public final GraphConfigurationBuilder<E> withAttributes(SingularAttribute<? super E, ?>... attrs) {
            for (SingularAttribute<? super E, ?> attr : attrs) {
                if (!attributes.contains(attr)) {
                    attributes.add(attr);
                }
            }
            return this;
        }

        /**
         * Сабграф для одиночного атрибута (ManyToOne, OneToOne).
         */
        public <X> GraphConfigurationBuilder<E> withSubgraph(SingularAttribute<? super E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
            GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getBindableJavaType());
            builderConsumer.accept(subBuilder);
            SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
            subgraphs.add(descriptor);
            return this;
        }

        /**
         * Сабграф для коллекционного атрибута (OneToMany, ManyToMany, etc.).
         */
        public <X> GraphConfigurationBuilder<E> withCollectionSubgraph(CollectionAttribute<? super E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
            GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getElementType().getJavaType());
            builderConsumer.accept(subBuilder);
            SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
            subgraphs.add(descriptor);
            return this;
        }
    }
}

class SubgraphDescriptor<T> {
    private final Object field; // может быть SingularAttribute или CollectionAttribute
    private final List<SingularAttribute<T, ?>> attributes;
    private final List<SubgraphDescriptor<?>> subgraphs;

    public SubgraphDescriptor(Object field,
                              List<SingularAttribute<T, ?>> attributes,
                              List<SubgraphDescriptor<?>> subgraphs) {
        this.field = field;
        this.attributes = attributes == null ? new ArrayList<>() : new ArrayList<>(attributes);
        this.subgraphs = subgraphs == null ? new ArrayList<>() : new ArrayList<>(subgraphs);
    }

    public Object getField() {
        return field;
    }

    public List<SingularAttribute<T, ?>> getAttributes() {
        return attributes;
    }

    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @SuppressWarnings("unchecked")
    public void merge(SubgraphDescriptor<?> other) {
        for (SingularAttribute<?, ?> attr : other.attributes) {
            if (!this.attributes.contains(attr)) {
                this.attributes.add((SingularAttribute<T, ?>) attr);
            }
        }

        if (other.subgraphs != null) {
            for (SubgraphDescriptor<?> nested : other.subgraphs) {
                Optional<SubgraphDescriptor<?>> existing = this.subgraphs.stream()
                    .filter(sg -> sg.getField().equals(nested.getField()))
                    .findFirst();
                if (existing.isPresent()) {
                    existing.get().merge(nested);
                } else {
                    this.subgraphs.add(nested);
                }
            }
        }
    }
}

class DynamicEntityGraphBuilder<T> {

    private final EntityGraph<T> graph;
    private final Set<String> addedAttributes = new HashSet<>();
    private final Set<String> addedSubgraphs = new HashSet<>();

    public DynamicEntityGraphBuilder(EntityManager entityManager, Class<T> rootEntity) {
        this.graph = entityManager.createEntityGraph(rootEntity);
    }

    public DynamicEntityGraphBuilder<T> addGraphConfiguration(GraphConfiguration<T> configuration) {
        // Добавляем атрибуты
        if (configuration.getAttributes() != null) {
            for (SingularAttribute<?, ?> attribute : configuration.getAttributes()) {
                if (addedAttributes.add(attribute.getName())) {
                    graph.addAttributeNodes(attribute.getName());
                }
            }
        }
        // Добавляем сабграфы
        if (configuration.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> subgraphDescriptor : configuration.getSubgraphs()) {
                addSubgraph(graph, subgraphDescriptor);
            }
        }

        return this;
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private <X> void addSubgraph(Subgraph<X> parentGraph, SubgraphDescriptor<X> descriptor) {
        String fieldName;
        if (descriptor.getField() instanceof SingularAttribute) {
            fieldName = ((SingularAttribute) descriptor.getField()).getName();
        } else if (descriptor.getField() instanceof CollectionAttribute) {
            fieldName = ((CollectionAttribute) descriptor.getField()).getName();
        } else {
            throw new IllegalStateException("Unsupported attribute type for subgraph");
        }

        String subgraphKey = parentGraph.getClass().getSimpleName() + ":" + fieldName;
        if (!addedSubgraphs.add(subgraphKey)) {
            return;
        }

        Subgraph<X> subgraph = parentGraph.addSubgraph(fieldName);
        if (descriptor.getAttributes() != null) {
            for (SingularAttribute<X, ?> attribute : descriptor.getAttributes()) {
                subgraph.addAttributeNodes(attribute.getName());
            }
        }

        if (descriptor.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> nestedDescriptor : descriptor.getSubgraphs()) {
                addSubgraph(subgraph, nestedDescriptor);
            }
        }
    }

    public EntityGraph<T> build() {
        return graph;
    }
}

// Предположим, что у нас есть такие метамодельные поля:
// PaymentAnalyticEntity._paymentObjects - CollectionAttribute<PaymentAnalyticEntity, PaymentObjectEntity>
// PaymentObjectEntity._name, PaymentObjectEntity._projectName - SingularAttribute<PaymentObjectEntity, String>
// PaymentObjectEntity._paymentObjectSsr - SingularAttribute<PaymentObjectEntity, PaymentObjectSsrEntity>
// PaymentObjectSsrEntity._paymentSsrArticles - CollectionAttribute<PaymentObjectSsrEntity, PaymentSsrArticleEntity>
// PaymentSsrArticleEntity._code - SingularAttribute<PaymentSsrArticleEntity, String>


class PFLloanFundsRqRegistryGraphConfigurationRegistry {
    private final Map<RegistryCodes, GraphConfiguration<?>> configurations = new HashMap<>();

    public PFLloanFundsRqRegistryGraphConfigurationRegistry() {
        configurations.put(RegistryCodes.DEFAULT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._id, PaymentAnalyticEntity._clientId, PaymentAnalyticEntity._paymentDocumentId));

        configurations.put(RegistryCodes.NUMBER, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._number));

        configurations.put(RegistryCodes.LOAN_FUNDS_REQUEST_STATUS, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._status));

        configurations.put(RegistryCodes.DATE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._date));

        configurations.put(RegistryCodes.FUNDS_TYPE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._fundsType));

        configurations.put(RegistryCodes.CREDIT_AGREEMENT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._creditAgreementNumber, PaymentAnalyticEntity._creditAgreementDate));

        configurations.put(RegistryCodes.PAYER_ACCOUNT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._payerAccount, PaymentAnalyticEntity._obcAccountFlag));

        configurations.put(RegistryCodes.TRANCHE_ISSUE_DATE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._trancheIssueDate));

        configurations.put(RegistryCodes.AMOUNT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._amount));

        configurations.put(RegistryCodes.PAYMENT_PURPOSE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._paymentPurpose));

        configurations.put(RegistryCodes.RECIPIENT_ACCOUNT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._recipientAccount));

        configurations.put(RegistryCodes.DVRU, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withAttributes(PaymentAnalyticEntity._dvruNumber, PaymentAnalyticEntity._dvruDate));

        // Предположим, что PaymentAnalyticEntity._paymentObjects - это CollectionAttribute
        configurations.put(RegistryCodes.PAYMENT_OBJECT, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withCollectionSubgraph(PaymentAnalyticEntity._paymentObjects, subGraph -> subGraph
                        .withAttributes(PaymentObjectEntity._name, PaymentObjectEntity._projectName)
                ));

        configurations.put(RegistryCodes.SSR_ARTICLE, GraphConfiguration.forEntity(PaymentAnalyticEntity.class)
                .withCollectionSubgraph(PaymentAnalyticEntity._paymentObjects, subGraph -> subGraph
                        .withAttributes(PaymentObjectEntity._name, PaymentObjectEntity._projectName)
                        .withSubgraph(PaymentObjectEntity._paymentObjectSsr, objectSubGraph -> objectSubGraph
                                .withCollectionSubgraph(PaymentObjectSsrEntity._paymentSsrArticles, paymentSsrArticlesSubGraph ->
                                        paymentSsrArticlesSubGraph.withAttributes(PaymentSsrArticleEntity._code)
                                )
                        )
                ));
    }

    public boolean contains(RegistryCodes code) {
        return configurations.containsKey(code);
    }

    @SuppressWarnings("unchecked")
    public <T> GraphConfiguration<T> get(RegistryCodes code) {
        return (GraphConfiguration<T>) configurations.get(code);
    }
}

// Пример использования
class ExampleUsage {
    void example(EntityManager entityManager, List<RegistryCodes> requestCodes) {
        GraphConfiguration<PaymentAnalyticEntity> finalConfig = GraphConfiguration.forEntity(PaymentAnalyticEntity.class);
        PFLloanFundsRqRegistryGraphConfigurationRegistry registry = new PFLloanFundsRqRegistryGraphConfigurationRegistry();

        for (RegistryCodes code : requestCodes) {
            if (registry.contains(code)) {
                finalConfig.merge(registry.get(code));
            }
        }

        DynamicEntityGraphBuilder<PaymentAnalyticEntity> builder = new DynamicEntityGraphBuilder<>(entityManager, PaymentAnalyticEntity.class);
        builder.addGraphConfiguration(finalConfig);
        EntityGraph<PaymentAnalyticEntity> combinedGraph = builder.build();

        // Далее использовать combinedGraph в запросе
    }
}
```

**Ключевые моменты:**  
- Для коллекционных атрибутов мы используем `withCollectionSubgraph(...)`.  
- Для одиночных атрибутов (OneToOne, ManyToOne) используем `withSubgraph(...)`.  
- Метамодельные классы должны быть корректно сгенерированы.  
- Таким образом достигается корректная типизация и возможность добавить вложенные сабграфы без ошибок компиляции.



Ниже приведен пример переработанного решения с использованием более удобного DSL-подхода для построения конфигураций графов и проверки списка кодов.

Основные изменения:
1. **DSL-подход для `GraphConfiguration`**:  
   Создан статический метод `forEntity(...)`, возвращающий билдер для конфигурации.  
   Методы `withAttributes(...)`, `withSubgraph(...)` позволяют пошагово настраивать граф.
   
2. **Использование `enum RegistryCodes` вместо строковых кодов**:  
   Вместо строковых констант используем `enum`, что делает код более типобезопасным и удобным.

3. **Автоматическая регистрация конфигураций в `GraphConfigurationRegistry`**:  
   `GraphConfigurationRegistry` хранит карту `Map<RegistryCodes, GraphConfiguration<?>>`.  
   Добавляем метод `merge(...)` в `GraphConfiguration` для объединения нескольких конфигураций.

4. **Пример использования**:  
   Проверяем входящие коды, если они содержатся в реестре - мержим конфигурацию. В конце создаем итоговый граф через `DynamicEntityGraphBuilder`.

---

### Пример кода

```java
import jakarta.persistence.EntityGraph;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Subgraph;
import jakarta.persistence.metamodel.SingularAttribute;
import java.util.*;
import java.util.function.Consumer;

/**
 * Коды, на которые мы можем настроить наши конфигурации графов.
 */
enum RegistryCodes {
    DEFAULT,
    RECIPIENT,
    DVRU,
    OBJECT,
    SsrArticle_CODE
}

/**
 * Интерфейс для описания конфигурации графа.
 */
interface GraphConfiguration<T> {

    Class<T> getEntityClass();

    List<SingularAttribute<?, ?>> getAttributes();

    List<SubgraphDescriptor<?>> getSubgraphs();

    /**
     * Объединить текущую конфигурацию с другой. Возвращает новую конфигурацию.
     */
    GraphConfiguration<T> merge(GraphConfiguration<T> other);

    /**
     * Статический билдер для создания конфигурации с DSL.
     */
    static <E> GraphConfigurationBuilder<E> forEntity(Class<E> entityClass) {
        return new GraphConfigurationBuilder<>(entityClass);
    }

    class GraphConfigurationBuilder<E> implements GraphConfiguration<E> {
        private final Class<E> entityClass;
        private final List<SingularAttribute<?, ?>> attributes = new ArrayList<>();
        private final List<SubgraphDescriptor<?>> subgraphs = new ArrayList<>();

        public GraphConfigurationBuilder(Class<E> entityClass) {
            this.entityClass = entityClass;
        }

        @Override
        public Class<E> getEntityClass() {
            return entityClass;
        }

        @Override
        public List<SingularAttribute<?, ?>> getAttributes() {
            return attributes;
        }

        @Override
        public List<SubgraphDescriptor<?>> getSubgraphs() {
            return subgraphs.isEmpty() ? null : subgraphs;
        }

        @Override
        public GraphConfiguration<E> merge(GraphConfiguration<E> other) {
            if (!other.getEntityClass().equals(this.entityClass)) {
                throw new IllegalArgumentException("Невозможно объединить конфигурации для разных сущностей");
            }
            // Добавляем атрибуты
            for (SingularAttribute<?, ?> attr : other.getAttributes()) {
                if (!this.attributes.contains(attr)) {
                    this.attributes.add(attr);
                }
            }
            // Добавляем сабграфы
            mergeSubgraphs(this.subgraphs, other.getSubgraphs());
            return this;
        }

        private void mergeSubgraphs(List<SubgraphDescriptor<?>> target, List<SubgraphDescriptor<?>> source) {
            if (source == null) return;

            for (SubgraphDescriptor<?> sd : source) {
                Optional<SubgraphDescriptor<?>> existing = target.stream()
                    .filter(t -> t.getField().equals(sd.getField()))
                    .findFirst();
                if (existing.isPresent()) {
                    // Объединим атрибуты и вложенные сабграфы
                    SubgraphDescriptor<?> existingSd = existing.get();
                    existingSd.merge(sd);
                } else {
                    target.add(sd);
                }
            }
        }

        @SafeVarargs
        public final GraphConfigurationBuilder<E> withAttributes(SingularAttribute<? super E, ?>... attrs) {
            for (SingularAttribute<? super E, ?> attr : attrs) {
                if (!attributes.contains(attr)) {
                    attributes.add(attr);
                }
            }
            return this;
        }

        public <X> GraphConfigurationBuilder<E> withSubgraph(SingularAttribute<? super E, X> field, Consumer<GraphConfigurationBuilder<X>> builderConsumer) {
            GraphConfigurationBuilder<X> subBuilder = new GraphConfigurationBuilder<>(field.getBindableJavaType());
            builderConsumer.accept(subBuilder);
            SubgraphDescriptor<X> descriptor = new SubgraphDescriptor<>(field, subBuilder.getAttributes(), subBuilder.getSubgraphs());
            subgraphs.add(descriptor);
            return this;
        }
    }
}

/**
 * Класс для описания сабграфа.
 */
class SubgraphDescriptor<T> {
    private final SingularAttribute<?, ?> field;
    private final List<SingularAttribute<T, ?>> attributes;
    private final List<SubgraphDescriptor<?>> subgraphs;

    public SubgraphDescriptor(SingularAttribute<?, ?> field,
                              List<SingularAttribute<T, ?>> attributes,
                              List<SubgraphDescriptor<?>> subgraphs) {
        this.field = field;
        this.attributes = attributes == null ? new ArrayList<>() : new ArrayList<>(attributes);
        this.subgraphs = subgraphs == null ? new ArrayList<>() : new ArrayList<>(subgraphs);
    }

    public SingularAttribute<?, ?> getField() {
        return field;
    }

    public List<SingularAttribute<T, ?>> getAttributes() {
        return attributes;
    }

    public List<SubgraphDescriptor<?>> getSubgraphs() {
        return subgraphs.isEmpty() ? null : subgraphs;
    }

    @SuppressWarnings("unchecked")
    public void merge(SubgraphDescriptor<?> other) {
        // Объединение атрибутов
        for (SingularAttribute<?, ?> attr : other.attributes) {
            if (!this.attributes.contains(attr)) {
                this.attributes.add((SingularAttribute<T, ?>) attr);
            }
        }

        // Объединение вложенных сабграфов
        if (other.subgraphs != null) {
            for (SubgraphDescriptor<?> nested : other.subgraphs) {
                Optional<SubgraphDescriptor<?>> existing = this.subgraphs.stream()
                    .filter(sg -> sg.getField().equals(nested.getField()))
                    .findFirst();
                if (existing.isPresent()) {
                    existing.get().merge(nested);
                } else {
                    this.subgraphs.add(nested);
                }
            }
        }
    }
}

/**
 * Провайдер конфигураций (реестр).
 */
class GraphConfigurationRegistry {

    private final Map<RegistryCodes, GraphConfiguration<?>> configurations = new HashMap<>();

    public GraphConfigurationRegistry() {
        // Инициализация реестра.
        configurations.put(RegistryCodes.DEFAULT, GraphConfiguration.forEntity(PaymentAnalyticDto.class)
            .withAttributes(PaymentAnalyticDto_.id, PaymentAnalyticDto_.clientId, PaymentAnalyticDto_.paymentDocumentId));

        configurations.put(RegistryCodes.RECIPIENT, GraphConfiguration.forEntity(PaymentAnalyticDto.class)
            .withAttributes(PaymentAnalyticDto_.recipientName, PaymentAnalyticDto_.recipientAccount));

        // Пример с вложенным сабграфом
        configurations.put(RegistryCodes.SsrArticle_CODE,
            GraphConfiguration.forEntity(PaymentAnalyticDto.class)
                .withSubgraph(PaymentAnalyticDto_.paymentObjects, sg -> sg
                    .withAttributes(PaymentObjectEntityDto_.name, PaymentObjectEntityDto_.projectName)
                    .withSubgraph(PaymentObjectEntityDto_.paymentObjectSsr, ssg -> ssg
                        .withSubgraph(PaymentObjectSsrEntityDto_.paymentSsrArticles, sssg -> sssg
                            .withAttributes(PaymentSsrArticleDto_.code)
                        )
                    )
                )
        );
        // Аналогично можно добавить DVRU, OBJECT и др.
    }

    @SuppressWarnings("unchecked")
    public <T> GraphConfiguration<T> get(RegistryCodes code) {
        return (GraphConfiguration<T>) configurations.get(code);
    }

    public boolean contains(RegistryCodes code) {
        return configurations.containsKey(code);
    }
}

/**
 * Класс для динамического построения EntityGraph.
 */
class DynamicEntityGraphBuilder<T> {

    private final EntityGraph<T> graph;
    private final Set<String> addedAttributes = new HashSet<>();
    private final Set<String> addedSubgraphs = new HashSet<>();

    public DynamicEntityGraphBuilder(EntityManager entityManager, Class<T> rootEntity) {
        this.graph = entityManager.createEntityGraph(rootEntity);
    }

    public DynamicEntityGraphBuilder<T> addGraphConfiguration(GraphConfiguration<T> configuration) {
        // Добавляем атрибуты
        if (configuration.getAttributes() != null) {
            for (SingularAttribute<?, ?> attribute : configuration.getAttributes()) {
                if (addedAttributes.add(attribute.getName())) {
                    graph.addAttributeNodes(attribute.getName());
                }
            }
        }
        // Добавляем сабграфы
        if (configuration.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> subgraphDescriptor : configuration.getSubgraphs()) {
                addSubgraph(graph, subgraphDescriptor);
            }
        }

        return this;
    }

    @SuppressWarnings("unchecked")
    private <X> void addSubgraph(Subgraph<X> parentGraph, SubgraphDescriptor<X> descriptor) {
        String subgraphKey = parentGraph.getClass().getSimpleName() + ":" + descriptor.getField().getName();
        if (!addedSubgraphs.add(subgraphKey)) {
            return;
        }

        Subgraph<X> subgraph = parentGraph.addSubgraph(descriptor.getField().getName());
        if (descriptor.getAttributes() != null) {
            for (SingularAttribute<X, ?> attribute : descriptor.getAttributes()) {
                subgraph.addAttributeNodes(attribute.getName());
            }
        }

        if (descriptor.getSubgraphs() != null) {
            for (SubgraphDescriptor<?> nestedDescriptor : descriptor.getSubgraphs()) {
                addSubgraph(subgraph, nestedDescriptor);
            }
        }
    }

    public EntityGraph<T> build() {
        return graph;
    }
}

///////////////////////////////////////////////////////////////
// Ниже пример использования
///////////////////////////////////////////////////////////////
class ExampleUsage {
    void example(EntityManager entityManager, List<RegistryCodes> requestCodes) {

        // Базовая конфигурация (можно начать с пустой или с дефолтной)
        GraphConfiguration<PaymentAnalyticDto> finalConfig = GraphConfiguration.forEntity(PaymentAnalyticDto.class);

        GraphConfigurationRegistry registry = new GraphConfigurationRegistry();

        // Перебираем коды из запроса и если есть - мерджим конфигурацию
        for (RegistryCodes code : requestCodes) {
            if (registry.contains(code)) {
                finalConfig.merge(registry.get(code));
            }
        }

        // Строим EntityGraph на основе итоговой конфигурации
        DynamicEntityGraphBuilder<PaymentAnalyticDto> builder = new DynamicEntityGraphBuilder<>(entityManager, PaymentAnalyticDto.class);
        builder.addGraphConfiguration(finalConfig);
        EntityGraph<PaymentAnalyticDto> combinedGraph = builder.build();

        // Далее можно использовать combinedGraph в запросе
        // ...
    }
}
```

---

**Итог:**  
Мы получили удобный DSL для определения конфигураций графов, типобезопасные коды через `enum`, а также возможность динамически формировать итоговую конфигурацию путем объединения нескольких конфигураций по списку входящих кодов. В конце мы можем создать итоговый `EntityGraph`.






@Override
public Sort getSort(List<SortingRequestDto> sortingDtos) {
    List<Sort.Order> orders = new ArrayList<>();

    if (sortingDtos != null && !sortingDtos.isEmpty()) {
        for (SortingRequestDto dto : sortingDtos) {
            Sort.Direction direction = dto.getSortDescending() ? Sort.Direction.DESC : Sort.Direction.ASC;

            // Сопоставляем поля для сортировки через SingularAttribute
            switch (RegistryCodes.valueOf(dto.getSortField().toUpperCase())) {
                case NUMBER ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.number.getName()));
                case LOAN_FUNDS_REQUEST_STATUS ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.status.getName()));
                case DATE ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.date.getName()));
                case FUNDS_TYPE ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.fundsType.getName()));
                case CREDIT_AGREEMENT -> {
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.creditAgreementNumber.getName()));
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.creditAgreementDate.getName()));
                }
                case PAYER_ACCOUNT -> {
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.payerAccount.getName()));
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.obcAccountFlag.getName()));
                }
                case TRANCHE_ISSUE_DATE ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.trancheIssueDate.getName()));
                case AMOUNT ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.amount.getName()));
                case PAYMENT_PURPOSE ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.paymentPurpose.getName()));
                case RECIPIENT_NAME ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.recipientName.getName()));
                case RECIPIENT_ACCOUNT ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.recipientAccount.getName()));
                case DVRU -> {
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.dvruNumber.getName()));
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.dvruDate.getName()));
                }
                case PAYMENT_TYPE ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.paymentType.getName()));
                default ->
                    orders.add(new Sort.Order(direction, PaymentAnalyticEntity_.clientId.getName())); // Поле по умолчанию
            }
        }
    } else {
        // Сортировка по умолчанию, если DTO пуст
        orders.add(Sort.Order.desc(PaymentAnalyticEntity_.clientId.getName()));
    }

    return Sort.by(orders);
}


public interface SortingService {
    Sort getSort(List<SortingRequestDto> sortingDtos);
}

import org.springframework.data.domain.Sort;
import java.util.ArrayList;
import java.util.List;

@Service
public class SortingServiceImpl implements SortingService {

    @Override
    public Sort getSort(List<SortingRequestDto> sortingDtos) {
        List<Sort.Order> orders = new ArrayList<>();
        
        if (sortingDtos != null && !sortingDtos.isEmpty()) {
            for (SortingRequestDto dto : sortingDtos) {
                // Направление сортировки
                Sort.Direction direction = dto.getSortDescending() ? Sort.Direction.DESC : Sort.Direction.ASC;

                // Сопоставляем поля для сортировки
                switch (dto.getSortField().toUpperCase()) {
                    case "NUMBER" -> orders.add(new Sort.Order(direction, "number"));
                    case "LOAN_FUNDS_REQUEST_STATUS" -> orders.add(new Sort.Order(direction, "status"));
                    case "DATE" -> orders.add(new Sort.Order(direction, "date"));
                    case "FUNDS_TYPE" -> orders.add(new Sort.Order(direction, "fundsType"));
                    case "CREDIT_AGREEMENT" -> {
                        orders.add(new Sort.Order(direction, "creditAgreementNumber"));
                        orders.add(new Sort.Order(direction, "creditAgreementDate"));
                    }
                    case "PAYER_ACCOUNT" -> {
                        orders.add(new Sort.Order(direction, "payerAccount"));
                        orders.add(new Sort.Order(direction, "obcAccountFlag"));
                    }
                    case "TRANCHE_ISSUE_DATE" -> orders.add(new Sort.Order(direction, "trancheIssueDate"));
                    case "AMOUNT" -> orders.add(new Sort.Order(direction, "amount"));
                    case "PAYMENT_PURPOSE" -> orders.add(new Sort.Order(direction, "paymentPurpose"));
                    case "RECIPIENT_NAME" -> orders.add(new Sort.Order(direction, "recipientName"));
                    case "RECIPIENT_ACCOUNT" -> orders.add(new Sort.Order(direction, "recipientAccount"));
                    case "DVRU" -> {
                        orders.add(new Sort.Order(direction, "dvruNumber"));
                        orders.add(new Sort.Order(direction, "dvruDate"));
                    }
                    case "PAYMENT_TYPE" -> orders.add(new Sort.Order(direction, "paymentType"));
                    default -> orders.add(new Sort.Order(direction, "clientId")); // Поле по умолчанию
                }
            }
        } else {
            // Сортировка по умолчанию, если DTO пуст
            orders.add(Sort.Order.desc("clientId"));
        }

        return Sort.by(orders);
    }
}



public class GenericSpecificationBuilder<T> {
    private final List<Specification<T>> specifications = new ArrayList<>();

    public GenericSpecificationBuilder<T> add(Specification<T> spec) {
        if (spec != null) {
            specifications.add(spec);
        }
        return this;
    }

    public Specification<T> build() {
        Specification<T> result = Specification.where(null);
        for (Specification<T> spec : specifications) {
            result = result.and(spec);
        }
        return result;
    }
}




import jakarta.persistence.criteria.*;
import org.springframework.data.jpa.domain.Specification;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * ****************************************************************************
 * Класс: PaymentAnalyticFilterSpecification
 * Автор: Владислав Турукин
 * ****************************************************************************
 *
 * Описание:
 * Реализация спецификации для применения фильтрации к сущности PaymentAnalyticEntity
 * на основе DTO PFLoanFundsRqRegistryFilterDto.
 *
 * Поддерживаемые фильтры:
 * - Фильтрация по идентификаторам клиентов.
 * - Номер документа.
 * - Статусы заявки.
 * - Даты заявок.
 * - Счета плательщика и получателя.
 * - Сумма от/до.
 * - Назначение платежа.
 * - Кредитные договора.
 * - Прочие фильтры.
 *
 * Методы:
 * - toPredicate(...) - строит динамические условия фильтрации в запросе.
 */
public class PaymentAnalyticFilterSpecification implements Specification<PaymentAnalyticEntity> {

    private final PFLoanFundsRqRegistryFilterDto filter;

    public PaymentAnalyticFilterSpecification(PFLoanFundsRqRegistryFilterDto filter) {
        this.filter = filter;
    }

    @Override
    public Predicate toPredicate(Root<PaymentAnalyticEntity> root, CriteriaQuery<?> cq, CriteriaBuilder cb) {
        List<Predicate> predicates = new ArrayList<>();

        // Фильтрация по идентификаторам клиентов
        if (filter.getClientIds() != null && !filter.getClientIds().isEmpty()) {
            List<Long> clientIdsLong = filter.getClientIds().stream().map(Long::valueOf).collect(Collectors.toList());
            predicates.add(root.get(PaymentAnalyticEntity_.clientId).in(clientIdsLong));
        }

        // Фильтрация по номеру документа
        if (filter.getNumber() != null && !filter.getNumber().isEmpty()) {
            predicates.add(cb.like(cb.toString(root.get(PaymentAnalyticEntity_.number)), "%" + filter.getNumber() + "%"));
        }

        // Фильтрация по статусам заявки
        if (filter.getLoanFundsRequestStatuses() != null) {
            Set<PaymentAnalyticStatus> statuses = filter.getLoanFundsRequestStatuses().stream()
                    .map(PaymentAnalyticStatus::of)
                    .collect(Collectors.toSet());
            predicates.add(root.get(PaymentAnalyticEntity_.status).in(statuses));
        }

        // Фильтрация по датам заявки
        if (filter.getLoanFundsRequestDate() != null) {
            if (filter.getLoanFundsRequestDate().getFrom() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get(PaymentAnalyticEntity_.date), filter.getLoanFundsRequestDate().getFrom()));
            }
            if (filter.getLoanFundsRequestDate().getTo() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get(PaymentAnalyticEntity_.date), filter.getLoanFundsRequestDate().getTo()));
            }
        }

        // Фильтрация по счетам плательщика
        if (filter.getPayerAccounts() != null) {
            predicates.add(root.get(PaymentAnalyticEntity_.payerAccount).in(filter.getPayerAccounts()));
        }

        // Фильтрация по счетам получателя
        if (filter.getRecipientAccounts() != null) {
            predicates.add(root.get(PaymentAnalyticEntity_.recipientAccount).in(filter.getRecipientAccounts()));
        }

        // Фильтрация по сумме от
        if (filter.getAmountFrom() != null) {
            predicates.add(cb.greaterThanOrEqualTo(root.get(PaymentAnalyticEntity_.amount), filter.getAmountFrom()));
        }

        // Фильтрация по сумме до
        if (filter.getAmountTo() != null) {
            predicates.add(cb.lessThanOrEqualTo(root.get(PaymentAnalyticEntity_.amount), filter.getAmountTo()));
        }

        // Фильтрация по назначению платежа
        if (filter.getPaymentPurposeSearch() != null && !filter.getPaymentPurposeSearch().isEmpty()) {
            predicates.add(cb.like(cb.lower(root.get(PaymentAnalyticEntity_.paymentPurpose)),
                    "%" + filter.getPaymentPurposeSearch().toLowerCase() + "%"));
        }

        // Фильтрация по кредитным договорам
        if (filter.getCreditAgreementIds() != null) {
            Set<Long> creditAgreementIds = filter.getCreditAgreementIds().stream()
                    .map(Long::valueOf)
                    .collect(Collectors.toSet());
            predicates.add(root.get(PaymentAnalyticEntity_.creditAgreementId).in(creditAgreementIds));
        }

        // Фильтрация по дате транша
        if (filter.getTrancheIssueDate() != null) {
            if (filter.getTrancheIssueDate().getFrom() != null) {
                predicates.add(cb.greaterThanOrEqualTo(root.get(PaymentAnalyticEntity_.trancheIssueDate),
                        filter.getTrancheIssueDate().getFrom()));
            }
            if (filter.getTrancheIssueDate().getTo() != null) {
                predicates.add(cb.lessThanOrEqualTo(root.get(PaymentAnalyticEntity_.trancheIssueDate),
                        filter.getTrancheIssueDate().getTo()));
            }
        }

        // Фильтрация по ИНН или названию получателя
        if (filter.getRecipientNameOrInn() != null && !filter.getRecipientNameOrInn().isEmpty()) {
            if (filter.getRecipientNameOrInn().matches("^\\d{1,12}$")) {
                predicates.add(cb.like(root.get(PaymentAnalyticEntity_.recipientInn), "%" + filter.getRecipientNameOrInn() + "%"));
            } else {
                predicates.add(cb.like(cb.lower(root.get(PaymentAnalyticEntity_.recipientName)),
                        "%" + filter.getRecipientNameOrInn().toLowerCase() + "%"));
            }
        }

        // Фильтрация по типу средств
        if (filter.getFundsType() != null) {
            predicates.add(cb.equal(root.get(PaymentAnalyticEntity_.fundsType), FundsType.of(filter.getFundsType())));
        }

        // Фильтрация по наличию платёжного поручения
        if (filter.getHasPaymentOrder() != null) {
            if (filter.getHasPaymentOrder()) {
                predicates.add(cb.isNotNull(root.get(PaymentAnalyticEntity_.paymentDocumentId)));
            } else {
                predicates.add(cb.isNull(root.get(PaymentAnalyticEntity_.paymentDocumentId)));
            }
        }

        // Возврат комбинированного предиката
        return predicates.isEmpty() ? cb.conjunction() : cb.and(predicates.toArray(new Predicate[0]));
    }
}


Вот реализация метода с изменённым контрактом, где используются переданные спецификации фильтрации и сортировки:

### Метод `findAllWithDynamicGraph`

```java
@Override
public Page<T> findAllWithDynamicGraph(
        EntityGraph<T> graph,
        Specification<T> filterSpec,
        Specification<T> sortingSpec,
        Pageable pageable) {

    log.debug("Executing findAllWithDynamicGraph with graph: {}, filterSpec: {}, sortingSpec: {}, pageable: {}",
            graph, filterSpec, sortingSpec, pageable);

    if (graph == null || pageable == null) {
        throw new IllegalArgumentException("Graph and pageable cannot be null");
    }

    try {
        // Объединяем фильтрацию и сортировку в одну Specification
        Specification<T> combinedSpec = Specification.where(filterSpec).and(sortingSpec);

        // Создаём CriteriaQuery для получения данных
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<T> cq = cb.createQuery(graph.getEntityType());
        Root<T> root = cq.from(graph.getEntityType());

        // Применяем спецификацию (фильтрация и сортировка)
        if (combinedSpec != null) {
            Predicate predicate = combinedSpec.toPredicate(root, cq, cb);
            if (predicate != null) {
                cq.where(predicate);
            }
        }

        // Применяем сортировку из Pageable, если задано
        if (pageable.getSort().isSorted()) {
            cq.orderBy(QueryUtils.toOrders(pageable.getSort(), root, cb));
        }

        // Создаём TypedQuery для основного запроса
        TypedQuery<T> query = entityManager.createQuery(cq);
        query.setHint("javax.persistence.loadgraph", graph);

        // Пагинация
        query.setFirstResult((int) pageable.getOffset());
        query.setMaxResults(pageable.getPageSize());

        // Выполняем запрос
        List<T> resultList = query.getResultList();

        // Подсчёт общего количества записей
        long total = countTotalRecords(combinedSpec, graph);

        // Формируем Page с результатами
        return new PageImpl<>(resultList, pageable, total);

    } catch (Exception e) {
        log.error("Error executing findAllWithDynamicGraph: {}", e.getMessage(), e);
        throw new RuntimeException("Error fetching data with dynamic graph", e);
    }
}
```

---

### Метод для подсчёта общего количества записей

```java
private long countTotalRecords(Specification<T> spec, EntityGraph<T> graph) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Long> countQuery = cb.createQuery(Long.class);
    Root<T> countRoot = countQuery.from(graph.getEntityType());

    if (spec != null) {
        Predicate predicate = spec.toPredicate(countRoot, countQuery, cb);
        if (predicate != null) {
            countQuery.where(predicate);
        }
    }

    countQuery.select(cb.count(countRoot));
    return entityManager.createQuery(countQuery).getSingleResult();
}
```

---

### Контракт метода `findAllWithDynamicGraph`

```java
/**
 * Выполняет поиск сущностей с использованием динамического графа, фильтрации, сортировки и пагинации.
 *
 * @param graph       Динамический граф сущностей (EntityGraph), определяющий, какие ассоциации должны быть загружены.
 * @param filterSpec  Спецификация для фильтрации данных.
 * @param sortingSpec Спецификация для сортировки данных.
 * @param pageable    Параметры пагинации.
 * @return Страница результатов, содержащая сущности и метаданные пагинации.
 * @throws IllegalArgumentException Если переданы некорректные параметры.
 * @throws RuntimeException         Если возникает ошибка при выполнении запроса.
 */
Page<T> findAllWithDynamicGraph(
        EntityGraph<T> graph,
        Specification<T> filterSpec,
        Specification<T> sortingSpec,
        Pageable pageable);
```

---

### Объяснение
1. **Параметры метода:**
   - `EntityGraph<T> graph`: Определяет граф сущностей, который будет использоваться для загрузки данных.
   - `Specification<T> filterSpec`: Содержит условия фильтрации.
   - `Specification<T> sortingSpec`: Содержит условия сортировки.
   - `Pageable pageable`: Определяет параметры пагинации (offset, limit, сортировка).

2. **Порядок выполнения:**
   - Объединяются фильтрация и сортировка через `Specification.where(...)`.
   - Создаётся запрос с помощью Criteria API.
   - Применяются пагинация и сортировка.
   - Выполняется запрос для данных.
   - Выполняется отдельный запрос для подсчёта общего количества записей.

3. **Поддержка гибкости:** Метод допускает любую комбинацию фильтрации и сортировки, так как они передаются в виде `Specification`.

---

Если потребуется улучшение или добавление примера теста, дайте знать!



```java
package com.example.paymentanalytic.repository;

import com.example.paymentanalytic.PaymentAnalyticEntity;
import jakarta.persistence.EntityGraph;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.persistence.TypedQuery;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;

import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Root;
import jakarta.persistence.criteria.Predicate;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.List;

/**
 * ****************************************************************************
 * Интерфейс: PaymentAnalyticCustomRepository
 * Автор: Владислав Турукин
 * ****************************************************************************
 *
 * Описание:
 * Кастомный репозиторный интерфейс для расширения функциональности
 * PaymentAnalyticRepository.
 *
 * Предназначен для выполнения запросов с динамическим применением:
 * - Фильтрации (Specification)
 * - Динамического EntityGraph
 * - Сортировки и пагинации на уровне базы данных
 *
 * Методы:
 * - findAllWithGraph(...) - Выполнить поиск сущностей с учетом Specification,
 *   пагинации, сортировки и динамического EntityGraph.
 */
public interface PaymentAnalyticCustomRepository {

    /**
     * Выполнить поиск сущностей PaymentAnalyticEntity с учетом фильтрации, сортировки, пагинации
     * и динамического графа загрузки.
     *
     * @param spec    Спецификация (фильтр) для применения к запросу
     * @param pageable Параметры пагинации и сортировки
     * @param graph   Динамический граф сущностей, который определяет, какие поля и связи будут загружены
     * @return Страница результатов, включая список сущностей и метаданные пагинации
     * @throws IllegalArgumentException при некорректных параметрах
     * @throws RuntimeException при ошибках выполнения запроса к базе данных
     */
    Page<PaymentAnalyticEntity> findAllWithGraph(Specification<PaymentAnalyticEntity> spec, Pageable pageable, EntityGraph<PaymentAnalyticEntity> graph);
}


/**
 * ****************************************************************************
 * Класс: PaymentAnalyticRepositoryImpl
 * Автор: Владислав Турукин
 * ****************************************************************************
 *
 * Описание:
 * Реализация кастомного репозиторного интерфейса PaymentAnalyticCustomRepository.
 * Данный класс обеспечивает возможность выполнять запросы к базе данных с учетом:
 * - Динамических фильтров (Specification)
 * - Динамического графа сущностей (EntityGraph)
 * - Пагинации и сортировки на уровне БД
 *
 * Применяются меры к оптимизации:
 * - Предварительная фильтрация и сортировка через Criteria API
 * - Подсчет общего количества записей отдельным запросом
 * - Установка EntityGraph через хинт для оптимизации загрузки связанных сущностей
 *
 * Исключения:
 * - IllegalArgumentException при некорректных параметрах
 * - RuntimeException при ошибках доступа к базе
 *
 * Логирование:
 * - Логируется начало и окончание операции, а также любые исключительные ситуации.
 */
@Repository
@Slf4j
class PaymentAnalyticRepositoryImpl implements PaymentAnalyticCustomRepository {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Page<PaymentAnalyticEntity> findAllWithGraph(Specification<PaymentAnalyticEntity> spec, Pageable pageable, EntityGraph<PaymentAnalyticEntity> graph) {
        log.debug("Начало выполнения метода findAllWithGraph со спецификацией: {}, пагинацией: {}, графом: {}", spec, pageable, graph);

        if (spec == null) {
            throw new IllegalArgumentException("Спецификация не может быть null");
        }
        if (pageable == null) {
            throw new IllegalArgumentException("Параметры пагинации не могут быть null");
        }
        if (graph == null) {
            throw new IllegalArgumentException("EntityGraph не может быть null");
        }

        try {
            // Создание CriteriaQuery для основного запроса данных
            CriteriaBuilder cb = entityManager.getCriteriaBuilder();
            CriteriaQuery<PaymentAnalyticEntity> cq = cb.createQuery(PaymentAnalyticEntity.class);
            Root<PaymentAnalyticEntity> root = cq.from(PaymentAnalyticEntity.class);

            // Применяем спецификацию (фильтр)
            Predicate predicate = spec.toPredicate(root, cq, cb);
            if (predicate != null) {
                cq.where(predicate);
            }

            // Применяем сортировку из Pageable
            if (pageable.getSort().isSorted()) {
                cq.orderBy(QueryUtils.toOrders(pageable.getSort(), root, cb));
            }

            TypedQuery<PaymentAnalyticEntity> query = entityManager.createQuery(cq);
            query.setHint("javax.persistence.loadgraph", graph);

            // Пагинация
            query.setFirstResult((int) pageable.getOffset());
            query.setMaxResults(pageable.getPageSize());

            List<PaymentAnalyticEntity> content = query.getResultList();

            // Подсчет общего количества записей для формирования Page
            long total = executeCountQuery(spec);

            Page<PaymentAnalyticEntity> pageResult = new PageImpl<>(content, pageable, total);

            log.debug("Успешное выполнение метода findAllWithGraph. Найдено записей: {}, всего: {}", content.size(), total);
            return pageResult;
        } catch (IllegalArgumentException e) {
            log.error("Ошибка при валидации аргументов в findAllWithGraph: {}", e.getMessage(), e);
            throw e;
        } catch (Exception e) {
            log.error("Неожиданная ошибка при выполнении findAllWithGraph: {}", e.getMessage(), e);
            throw new RuntimeException("Ошибка при выполнении запроса к базе данных: " + e.getMessage(), e);
        }
    }

    /**
     * Выполнить запрос для подсчета общего количества записей, удовлетворяющих спецификации.
     *
     * @param spec Спецификация для фильтрации
     * @return количество записей, удовлетворяющих фильтру
     * @throws RuntimeException при ошибках выполнения count-запроса
     */
    private long executeCountQuery(Specification<PaymentAnalyticEntity> spec) {
        try {
            CriteriaBuilder cb = entityManager.getCriteriaBuilder();
            CriteriaQuery<Long> countCq = cb.createQuery(Long.class);
            Root<PaymentAnalyticEntity> countRoot = countCq.from(PaymentAnalyticEntity.class);

            Predicate predicate = spec.toPredicate(countRoot, countCq, cb);
            if (predicate != null) {
                countCq.where(predicate);
            }

            countCq.select(cb.count(countRoot));

            return entityManager.createQuery(countCq).getSingleResult();
        } catch (Exception e) {
            log.error("Ошибка при выполнении count-запроса: {}", e.getMessage(), e);
            throw new RuntimeException("Ошибка при подсчете общего количества записей: " + e.getMessage(), e);
        }
    }
}


/**
 * Вспомогательный класс для преобразования Spring Sort в JPA Order.
 * Данный код оптимизирован для работы с Criteria API.
 */
class QueryUtils {

    /**
     * Преобразовать Sort в список Order для CriteriaQuery.
     *
     * @param sort Sort из Pageable
     * @param root Корневой Root для Criteria
     * @param cb   CriteriaBuilder
     * @return Список Order для применения к CriteriaQuery
     * @throws IllegalArgumentException если поле для сортировки недоступно или некорректно
     */
    public static List<jakarta.persistence.criteria.Order> toOrders(org.springframework.data.domain.Sort sort,
                                                                    Root<PaymentAnalyticEntity> root,
                                                                    CriteriaBuilder cb) {
        List<jakarta.persistence.criteria.Order> orders = new ArrayList<>();
        sort.forEach(order -> {
            String property = order.getProperty();
            if (property == null || property.isEmpty()) {
                throw new IllegalArgumentException("Поле для сортировки не может быть пустым или null");
            }
            if (order.isAscending()) {
                orders.add(cb.asc(root.get(property)));
            } else {
                orders.add(cb.desc(root.get(property)));
            }
        });
        return orders;
    }
}
```



```java
import jakarta.persistence.EntityGraph;
import jakarta.persistence.metamodel.SingularAttribute;

import java.util.List;

public interface DynamicEntityGraphBuilderInterface<T> {

    /**
     * Добавляет атрибут к графу выборки.
     *
     * @param attribute Атрибут, который нужно добавить в граф.
     * @return Текущий экземпляр DynamicEntityGraphBuilderInterface для цепочки вызовов.
     */
    DynamicEntityGraphBuilderInterface<T> addAttribute(SingularAttribute<T, ?> attribute);

    /**
     * Добавляет подграф к графу выборки.
     *
     * @param attribute    Атрибут, к которому относится подграф.
     * @param subAttributes Список атрибутов, которые должны быть включены в подграф.
     * @param <X>          Тип сущности, относящейся к подграфу.
     * @return Текущий экземпляр DynamicEntityGraphBuilderInterface для цепочки вызовов.
     */
    <X> DynamicEntityGraphBuilderInterface<T> addSubgraph(SingularAttribute<T, List<X>> attribute, List<SingularAttribute<X, ?>> subAttributes);

    /**
     * Создает и возвращает граф сущностей.
     *
     * @return Построенный EntityGraph.
     */
    EntityGraph<T> build();
}



import jakarta.persistence.EntityGraph;
import jakarta.persistence.EntityManager;
import jakarta.persistence.Subgraph;
import jakarta.persistence.metamodel.SingularAttribute;

import java.util.List;

public class DynamicEntityGraphBuilder<T> implements DynamicEntityGraphBuilderInterface<T> {

    private final EntityGraph<T> graph;

    public DynamicEntityGraphBuilder(EntityManager entityManager, Class<T> rootEntity) {
        this.graph = entityManager.createEntityGraph(rootEntity);
    }

    public DynamicEntityGraphBuilder<T> addAttribute(SingularAttribute<T, ?> attribute) {
        graph.addAttributeNodes(attribute.getName());
        return this;
    }

    public <X> DynamicEntityGraphBuilder<T> addSubgraph(SingularAttribute<T, List<X>> attribute, List<SingularAttribute<X, ?>> subAttributes) {
        Subgraph<X> subgraph = graph.addSubgraph(attribute.getName());
        for (SingularAttribute<X, ?> subAttribute : subAttributes) {
            subgraph.addAttributeNodes(subAttribute.getName());
        }
        return this;
    }

    public EntityGraph<T> build() {
        return graph;
    }
}
```

* * *

#### 2\. **Использование утилиты в коде**

Пример: создание графа для `PaymentAnalyticEntity` с подгрузкой `PaymentObjects` и их `PaymentSsrArticles`.

```java
@Service
public class PaymentAnalyticService {

    private final EntityManager entityManager;

    public PaymentAnalyticService(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public EntityGraph<PaymentAnalyticEntity> buildGraph(boolean loadObjects, boolean loadArticles) {
        DynamicEntityGraphBuilder<PaymentAnalyticEntity> builder =
                new DynamicEntityGraphBuilder<>(entityManager, PaymentAnalyticEntity.class);

        // Добавляем корневой атрибут
        builder.addAttribute(PaymentAnalyticEntity_.clientName);

        // Условно добавляем вложенные графы
        if (loadObjects) {
            List<SingularAttribute<PaymentObjectEntity, ?>> subAttributes = List.of(
                    PaymentObjectEntity_.name,
                    PaymentObjectEntity_.projectName
            );

            if (loadArticles) {
                subAttributes.add(PaymentObjectEntity_.paymentSsrArticles);
            }

            builder.addSubgraph(PaymentAnalyticEntity_.paymentObjects, subAttributes);
        }

        return builder.build();
    }

    public List<PaymentAnalyticDto> findWithDynamicGraph(String clientName, boolean loadObjects, boolean loadArticles) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        QueryHelper<PaymentAnalyticEntity> helper = new QueryHelper<>(cb, PaymentAnalyticEntity.class);

        if (clientName != null) {
            helper.addLike(PaymentAnalyticEntity_.clientName, clientName);
        }

        // Создание динамического графа
        EntityGraph<PaymentAnalyticEntity> graph = buildGraph(loadObjects, loadArticles);

        // Выполнение запроса с графом
        TypedQuery<PaymentAnalyticEntity> query = helper.buildQuery(entityManager);
        query.setHint("javax.persistence.loadgraph", graph);

        List<PaymentAnalyticEntity> entities = query.getResultList();

        // Маппинг в DTO
        return entities.stream()
            .map(pa -> new PaymentAnalyticDto(
                pa.getId(),
                pa.getClientName(),
                pa.getPaymentObjects() != null ? pa.getPaymentObjects().stream()
                    .map(po -> new PaymentAnalyticDto.PaymentObjectDto(
                        po.getName(),
                        po.getProjectName(),
                        po.getPaymentSsrArticles() != null ? po.getPaymentSsrArticles().stream()
                            .map(PaymentSsrArticleEntity::getCode)
                            .collect(Collectors.toList()) : List.of()
                    ))
                    .collect(Collectors.toList()) : List.of()
            ))
            .collect(Collectors.toList());
    }
}





public class PaymentAnalyticSpecifications {

    public static Specification<PaymentAnalyticEntity> hasClientName(String clientName) {
        return (root, query, cb) -> cb.like(root.get(PaymentAnalyticEntity_.clientName), "%" + clientName + "%");
    }
}
@Service
public class PaymentAnalyticService {

    @PersistenceContext
    private EntityManager entityManager;

    public List<StatusCountDto> countByStatus(UUID clientId, Set<UUID> organizationIds) {
        if (organizationIds.isEmpty()) {
            throw new IllegalArgumentException("organizationIds не должен быть пустым");
        }

        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<Tuple> query = cb.createTupleQuery();
        Root<PaymentAnalyticEntity> root = query.from(PaymentAnalyticEntity.class);

        // Выражение для группировки
        Path<PaymentAnalyticStatus> groupBy = root.get(PaymentAnalyticEntity_.status);

        // Агрегация (COUNT)
        Expression<Long> countExpression = cb.count(root.get(PaymentAnalyticEntity_.id));

        // Построение фильтрации
        Predicate predicate = cb.conjunction();
        if (clientId != null) {
            predicate = cb.and(predicate, cb.equal(root.get(PaymentAnalyticEntity_.clientId), clientId));
        }
        predicate = cb.and(predicate, root.get(PaymentAnalyticEntity_.clientId).in(organizationIds));

        // Условие WHERE и GROUP BY
        query.multiselect(groupBy, countExpression)
             .where(predicate)
             .groupBy(groupBy);

        // Выполнение запроса
        List<Tuple> resultList = entityManager.createQuery(query).getResultList();

        // Маппинг результата в DTO
        return resultList.stream()
            .map(tuple -> new StatusCountDto(
                tuple.get(0, PaymentAnalyticStatus.class), // Статус
                tuple.get(1, Long.class)                  // Количество
            ))
            .collect(Collectors.toList());
    }
}



Set<SingularAttribute<?, ?>> attributes = Set.of(
    PaymentAnalyticEntity_.clientName,
    PaymentAnalyticEntity_.date
);

EntityGraph<?> graph = entityManager.createEntityGraph(PaymentAnalyticEntity.class);
applyEntityGraphFromMetamodel(graph, attributes);

TypedQuery<PaymentAnalyticEntity> query = entityManager.createQuery("SELECT p FROM PaymentAnalyticEntity p", PaymentAnalyticEntity.class);
query.setHint("javax.persistence.fetchgraph", graph);

List<PaymentAnalyticEntity> results = query.getResultList();

public void applyEntityGraphFromMetamodel(EntityGraph<?> graph, Set<SingularAttribute<?, ?>> attributes) {
    attributes.forEach(attribute -> graph.addAttributeNodes(attribute.getName()));
}


public List<T> findAllWithDynamicGraph(Class<T> entityClass, String graphName, List<String> attributes) {
    // Создаем CriteriaQuery на основе метамодели
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<T> query = cb.createQuery(entityClass);
    Root<T> root = query.from(entityClass);

    // Устанавливаем граф для запроса
    EntityGraph<?> entityGraph = entityManager.getEntityGraph(graphName);
    attributes.forEach(entityGraph::addAttributeNodes);
    query.select(root);

    // Выполняем запрос
    TypedQuery<T> typedQuery = entityManager.createQuery(query);
    typedQuery.setHint("javax.persistence.fetchgraph", entityGraph);

    return typedQuery.getResultList();
}
public List<PaymentAnalyticEntity> findByDynamicAttributes(Set<String> attributes) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<PaymentAnalyticEntity> query = cb.createQuery(PaymentAnalyticEntity.class);
    Root<PaymentAnalyticEntity> root = query.from(PaymentAnalyticEntity.class);

    // Используем атрибуты для настройки выборки
    query.select(root);

    // Пример фильтрации на основе метамодели
    if (attributes.contains("clientName")) {
        query.where(cb.like(root.get(PaymentAnalyticEntity_.clientName), "%Test%"));
    }

    // Пример сортировки
    query.orderBy(cb.desc(root.get(PaymentAnalyticEntity_.date)));

    // Создаём запрос и выполняем его
    return entityManager.createQuery(query).getResultList();
}








@Repository
public interface PaymentAnalyticRepository extends JpaRepository<PaymentAnalyticEntity, Long>, DynamicEntityGraphRepository<PaymentAnalyticEntity> {
}

public interface DynamicEntityGraphRepository<T> {
    List<T> findAllWithDynamicGraph(String graphName, List<String> attributes);
}

public class DynamicEntityGraphRepositoryImpl<T> implements DynamicEntityGraphRepository<T> {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<T> findAllWithDynamicGraph(String graphName, List<String> attributes) {
        EntityGraph<?> graph = entityManager.getEntityGraph(graphName);

        for (String attributePath : attributes) {
            String[] parts = attributePath.split("\\.");
            if (parts.length == 1) {
                graph.addAttributeNodes(parts[0]);
            } else {
                applySubgraph(graph, parts);
            }
        }

        TypedQuery<T> query = (TypedQuery<T>) entityManager.createQuery("SELECT e FROM " + graphName + " e", Object.class);
        query.setHint("javax.persistence.fetchgraph", graph);
        return query.getResultList();
    }

    private void applySubgraph(EntityGraph<?> graph, String[] parts) {
        Subgraph<?> currentSubgraph = graph.addSubgraph(parts[0]);
        for (int i = 1; i < parts.length; i++) {
            currentSubgraph = currentSubgraph.addSubgraph(parts[i]);
        }
    }
}





import jakarta.persistence.criteria.*;
import jakarta.persistence.metamodel.Attribute;
import jakarta.persistence.metamodel.CollectionAttribute;
import jakarta.persistence.metamodel.ListAttribute;
import jakarta.persistence.metamodel.MapAttribute;
import jakarta.persistence.metamodel.SetAttribute;
import jakarta.persistence.metamodel.SingularAttribute;
import jakarta.persistence.metamodel.PluralAttribute;
import jakarta.persistence.metamodel.Bindable;
import jakarta.persistence.metamodel.Attribute.PersistentAttributeType;

public interface UniversalJoiner {

    /**
     * Универсальный метод для JOIN с учетом типа атрибута.
     * <X> - тип корневой сущности (или типа, от которого мы джойним)
     * <Y> - тип целевого существа (или элемента коллекции), к которому делаем JOIN
     */
    @SuppressWarnings("unchecked")
    default <X, Y> Join<X, Y> join(From<X, ?> from,
                                   Attribute<? super X, ?> attribute,
                                   JoinType joinType) {
        // Проверяем тип атрибута и выполняем соответствующий JOIN
        if (attribute instanceof SingularAttribute) {
            // Одиночный атрибут (ManyToOne, OneToOne и т.д.)
            SingularAttribute<? super X, Y> singularAttribute = (SingularAttribute<? super X, Y>) attribute;
            return from.join(singularAttribute, joinType);

        } else if (attribute instanceof CollectionAttribute) {
            // Коллекция без порядка (Collection)
            CollectionAttribute<? super X, Y> collectionAttribute = (CollectionAttribute<? super X, Y>) attribute;
            return (Join<X, Y>) from.join(collectionAttribute, joinType);

        } else if (attribute instanceof SetAttribute) {
            // Множество (Set)
            SetAttribute<? super X, Y> setAttribute = (SetAttribute<? super X, Y>) attribute;
            return (Join<X, Y>) from.join(setAttribute, joinType);

        } else if (attribute instanceof ListAttribute) {
            // Список (List)
            ListAttribute<? super X, Y> listAttribute = (ListAttribute<? super X, Y>) attribute;
            return (Join<X, Y>) from.join(listAttribute, joinType);

        } else if (attribute instanceof MapAttribute) {
            // Карта (Map)
            MapAttribute<? super X, Object, Y> mapAttribute = (MapAttribute<? super X, Object, Y>) attribute;
            return (Join<X, Y>) from.join(mapAttribute, joinType);

        } else {
            // Если атрибут не поддерживается
            throw new IllegalArgumentException("Unsupported attribute type: " + attribute);
        }
    }
}



import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityGraph;
import jakarta.persistence.criteria.*;
import jakarta.persistence.metamodel.Attribute;
import jakarta.persistence.metamodel.PluralAttribute;
import jakarta.persistence.metamodel.SingularAttribute;
import java.util.*;
import java.util.function.Function;

/**
 * QueryBuilder - интерфейс для упрощенной и типобезопасной работы с Criteria API с интеграцией Jakarta API.
 * @param <T> Тип сущности, с которой работает запрос.
 */
public interface QueryBuilder<T> {

    CriteriaBuilder getCriteriaBuilder();

    CriteriaQuery<T> getCriteriaQuery();

    Root<T> getRoot();

    EntityManager getEntityManager();

    /**
     * Получение поля сущности через метамодель.
     */
    default <Y> Path<Y> get(SingularAttribute<T, Y> attribute) {
        return getRoot().get(attribute);
    }

    /**
     * Универсальный метод для JOIN.
     */
    default <X, Y> Join<X, Y> join(From<X, ?> from, Attribute<? super X, ?> attribute, JoinType joinType) {
        if (attribute instanceof SingularAttribute) {
            return from.join((SingularAttribute<? super X, Y>) attribute, joinType);
        } else if (attribute instanceof PluralAttribute) {
            return from.join((PluralAttribute<? super X, ?, Y>) attribute, joinType);
        } else {
            throw new IllegalArgumentException("Unsupported attribute type: " + attribute.getClass());
        }
    }

    /**
     * Перегрузка для JOIN с использованием строкового имени атрибута.
     */
    default <X, Y> Join<X, Y> join(From<X, ?> from, String attributeName, JoinType joinType) {
        return from.join(attributeName, joinType);
    }

    /**
     * Добавление условия (WHERE) к запросу.
     */
    default void addPredicate(Predicate predicate) {
        CriteriaQuery<T> query = getCriteriaQuery();
        Predicate existingPredicate = query.getRestriction();
        query.where(existingPredicate == null ? predicate : getCriteriaBuilder().and(existingPredicate, predicate));
    }

    /**
     * Добавление сортировки.
     */
    default void addOrder(SingularAttribute<T, ?> attribute, boolean ascending) {
        CriteriaQuery<T> query = getCriteriaQuery();
        Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
        query.orderBy(order);
    }

    /**
     * Динамическая настройка сложного EntityGraph.
     * @param entityGraphName Имя графа.
     * @param attributes Список полных путей (например, "paymentObjects.paymentSsrArticles").
     */
    default void applyComplexEntityGraph(String entityGraphName, List<String> attributes) {
        EntityGraph<?> entityGraph = getEntityManager().createEntityGraph(entityGraphName);
        for (String attributePath : attributes) {
            String[] parts = attributePath.split("\\.");
            if (parts.length == 1) {
                entityGraph.addAttributeNodes(parts[0]);
            } else {
                Subgraph<?> subgraph = entityGraph.addSubgraph(parts[0]);
                for (int i = 1; i < parts.length; i++) {
                    subgraph.addAttributeNodes(parts[i]);
                }
            }
        }
        getEntityManager().setProperty("javax.persistence.fetchgraph", entityGraph);
    }

    /**
     * Построение выражения SUM для указанного атрибута.
     */
    default <N extends Number> Expression<N> sum(SingularAttribute<? super T, N> attribute) {
        return getCriteriaBuilder().sum(get(attribute));
    }

    /**
     * Построение выражения AVG для указанного атрибута.
     */
    default <N extends Number> Expression<Double> avg(SingularAttribute<? super T, N> attribute) {
        return getCriteriaBuilder().avg(get(attribute));
    }

    /**
     * Упрощённое создание CASE WHEN выражения.
     */
    default <Y> Expression<Y> caseWhen(Function<CriteriaBuilder.Case<Y>, CriteriaBuilder.Case<Y>> caseLogic) {
        CriteriaBuilder.Case<Y> caseExpression = getCriteriaBuilder().selectCase();
        return caseLogic.apply(caseExpression);
    }

    /**
     * Динамическая сортировка по множеству полей.
     */
    default void addSorting(Map<SingularAttribute<? super T, ?>, Boolean> sortingRules) {
        List<Order> orders = new ArrayList<>();
        sortingRules.forEach((attribute, ascending) -> {
            Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
            orders.add(order);
        });
        getCriteriaQuery().orderBy(orders);
    }

    /**
     * Выполнение запроса через EntityManager.
     */
    default List<T> execute() {
        return getEntityManager().createQuery(getCriteriaQuery()).getResultList();
    }

    /**
     * Выполнение запроса с пагинацией.
     */
    default List<T> executeWithPagination(int offset, int limit) {
        return getEntityManager().createQuery(getCriteriaQuery())
                .setFirstResult(offset)
                .setMaxResults(limit)
                .getResultList();
    }
}




### Полное решение с учетом ваших требований

#### **1. Интерфейс `QueryBuilder` с поддержкой типобезопасного построения запросов**

```java
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityGraph;
import jakarta.persistence.criteria.*;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * QueryBuilder - интерфейс для упрощенной и типобезопасной работы с Criteria API с опциональной интеграцией QueryHelper.
 * @param <T> Тип сущности, с которой работает запрос.
 */
public interface QueryBuilder<T> {

    CriteriaBuilder getCriteriaBuilder();

    CriteriaQuery<T> getCriteriaQuery();

    Root<T> getRoot();

    EntityManager getEntityManager();

    /**
     * Получение поля сущности через метамодель.
     */
    default <Y> Path<Y> get(SingularAttribute<T, Y> attribute) {
        return getRoot().get(attribute);
    }

    /**
     * Выполнение join с другой сущностью.
     */
    default <Y> Join<T, Y> join(PluralAttribute<T, ?, Y> attribute, JoinType joinType) {
        return getRoot().join(attribute, joinType);
    }

    /**
     * Добавление условия (где) к запросу.
     */
    default void addPredicate(Predicate predicate) {
        CriteriaQuery<T> query = getCriteriaQuery();
        query.where(predicate);
    }

    /**
     * Добавление сортировки к запросу.
     */
    default void addOrder(SingularAttribute<T, ?> attribute, boolean ascending) {
        CriteriaQuery<T> query = getCriteriaQuery();
        Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
        query.orderBy(order);
    }

    /**
     * Динамическая настройка EntityGraph.
     * @param attributes Список полей для загрузки.
     */
    default void applyEntityGraph(List<String> attributes) {
        EntityGraph<?> entityGraph = getEntityManager().createEntityGraph(getRoot().getJavaType());
        attributes.forEach(entityGraph::addAttributeNodes);
        getEntityManager().setProperty("javax.persistence.fetchgraph", entityGraph);
    }

    /**
     * Построение агрегатного выражения (например, SUM).
     */
    default <Y> Expression<Y> sum(Expression<Y> expression) {
        return getCriteriaBuilder().sum(expression);
    }

    /**
     * Построение CASE WHEN выражения.
     */
    default <Y> Expression<Y> caseWhen(Consumer<CriteriaBuilder.Case<Y>> caseBuilder) {
        CriteriaBuilder.Case<Y> caseExpression = getCriteriaBuilder().selectCase();
        caseBuilder.accept(caseExpression);
        return caseExpression;
    }

    /**
     * Выполнение запроса через EntityManager.
     */
    default List<T> execute() {
        return getEntityManager().createQuery(getCriteriaQuery()).getResultList();
    }

    /**
     * Выполнение запроса с ограничением на количество записей (пагинация).
     */
    default List<T> executeWithPagination(int offset, int limit) {
        return getEntityManager().createQuery(getCriteriaQuery())
                .setFirstResult(offset)
                .setMaxResults(limit)
                .getResultList();
    }

    /**
     * Упрощённая сортировка по множеству полей.
     */
    default void addMultipleOrderBy(Map<SingularAttribute<T, ?>, Boolean> sortingMap) {
        List<Order> orders = new ArrayList<>();
        sortingMap.forEach((attribute, ascending) -> {
            Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
            orders.add(order);
        });
        getCriteriaQuery().orderBy(orders);
    }

    /**
     * Встроенные функции для полей метамодели (реализация RegistryCodes).
     */
    interface RegistryFields<T> {

        default Path<?> field(QueryBuilder<T> builder, SingularAttribute<T, ?> attribute) {
            return builder.get(attribute);
        }

        default Expression<Long> countField(QueryBuilder<T> builder, SingularAttribute<T, ?> attribute) {
            return builder.getCriteriaBuilder().count(builder.get(attribute));
        }

        default Expression<Double> averageField(QueryBuilder<T> builder, SingularAttribute<T, ? extends Number> attribute) {
            return builder.getCriteriaBuilder().avg(builder.get(attribute));
        }

        default <Y> Expression<Y> caseWhenField(QueryBuilder<T> builder, Consumer<CriteriaBuilder.Case<Y>> caseLogic) {
            return builder.caseWhen(caseLogic);
        }
    }
}
```

---

#### **2. Реализация `QueryBuilder`**

```java
public class QueryBuilderImpl<T> implements QueryBuilder<T> {

    private final EntityManager entityManager;
    private final CriteriaBuilder criteriaBuilder;
    private final CriteriaQuery<T> criteriaQuery;
    private final Root<T> root;

    public QueryBuilderImpl(EntityManager entityManager, Class<T> entityClass) {
        this.entityManager = entityManager;
        this.criteriaBuilder = entityManager.getCriteriaBuilder();
        this.criteriaQuery = criteriaBuilder.createQuery(entityClass);
        this.root = criteriaQuery.from(entityClass);
    }

    @Override
    public CriteriaBuilder getCriteriaBuilder() {
        return criteriaBuilder;
    }

    @Override
    public CriteriaQuery<T> getCriteriaQuery() {
        return criteriaQuery;
    }

    @Override
    public Root<T> getRoot() {
        return root;
    }

    @Override
    public EntityManager getEntityManager() {
        return entityManager;
    }
}
```

---

#### **3. Пример использования**

```java
EntityManager em = ...;

// Создаём QueryBuilder
QueryBuilder<PaymentAnalyticEntity> builder = new QueryBuilderImpl<>(em, PaymentAnalyticEntity.class);

// Пример фильтрации по статусу
builder.addPredicate(builder.getCriteriaBuilder().equal(builder.get(PaymentAnalyticEntity_.status), "ACTIVE"));

// Пример сортировки
builder.addOrder(PaymentAnalyticEntity_.date, false);

// Пример динамического EntityGraph
builder.applyEntityGraph(List.of("clientName", "paymentObjects"));

// Выполнение запроса
List<PaymentAnalyticEntity> results = builder.execute();

// Выполнение с пагинацией
List<PaymentAnalyticEntity> paginatedResults = builder.executeWithPagination(0, 10);
```

---

### Итоговые возможности

1. **Типобезопасная работа с запросами через Criteria API.**
2. **Динамическое создание запросов с EntityGraph.**
3. **Построение CASE WHEN, SUM и других выражений.**
4. **Динамическая сортировка и пагинация.**
5. **Возможность добавления новых методов в интерфейс через дефолтные методы.**

Если потребуется добавить дополнительные примеры или улучшения, пишите!


public enum RegistryCodesEnum {
    ID((helper) -> List.of(helper.get(PaymentAnalyticEntity_.id))),
    CLIENT_NAME((helper) -> List.of(helper.get(PaymentAnalyticEntity_.clientName))),
    CLIENT_TYPE((helper) -> List.of(helper.selectCase()
        .when(helper.like(PaymentAnalyticEntity_.clientName, "VIP%"), "VIP")
        .otherwise("Regular"))),
    DATE((helper) -> List.of(helper.get(PaymentAnalyticEntity_.date))),
    TOTAL_AMOUNT((helper) -> {
        JoinHelper<PaymentAnalyticEntity, PaymentObjectEntity> join = helper.join(PaymentAnalyticEntity_.paymentObjects);
        return List.of(join.sum(PaymentObjectEntity_.amount), helper.count(PaymentObjectEntity_.id));
    });

    private final Function<QueryHelper<PaymentAnalyticEntity>, List<Expression<?>>> expressionFunction;

    RegistryCodesEnum(Function<QueryHelper<PaymentAnalyticEntity>, List<Expression<?>>> expressionFunction) {
        this.expressionFunction = expressionFunction;
    }

    public List<Expression<?>> getExpressions(QueryHelper<PaymentAnalyticEntity> helper) {
        return expressionFunction.apply(helper);
    }
}




```java
private Map<RegistryCodes, Expression<?>> buildFieldExpressions(List<RegistryCodes> fields) {
    // Здесь мы для каждого поля через switch выбираем нужное поле Q-класса или nullExpression
    // В данном случае paymentAnalyticEntity — это Q-класс вашей сущности.
    // Предполагается, что paymentAnalyticEntity уже объявлен где-то выше как Q-поле.
    Map<RegistryCodes, Expression<?>> expressions = new HashMap<>();

    for (RegistryCodes code : fields) {
        Expression<?> expr = switch (code) {
            case ID -> paymentAnalyticEntity.id;
            case CLIENT_ID -> paymentAnalyticEntity.clientId;
            case PAYMENT_DOCUMENT_ID -> paymentAnalyticEntity.paymentDocumentId;
            case NUMBER -> paymentAnalyticEntity.number;
            case LOAN_FUNDS_REQUEST_STATUS -> paymentAnalyticEntity.status;
            case DATE -> paymentAnalyticEntity.date;
            case FUNDS_TYPE -> paymentAnalyticEntity.fundsType;
            case CREDIT_AGREEMENT -> paymentAnalyticEntity.creditAgreementNumber; 
            case CREDIT_AGREEMENT_DATE -> paymentAnalyticEntity.creditAgreementDate; 
            case PAYER_ACCOUNT -> paymentAnalyticEntity.payerAccount; 
            case OBC_ACCOUNT_FLAG -> paymentAnalyticEntity.obcAccountFlag;
            case TRANCHE_ISSUE_DATE -> paymentAnalyticEntity.trancheIssueDate; 
            case AMOUNT -> paymentAnalyticEntity.amount;
            case PAYMENT_PURPOSE -> paymentAnalyticEntity.paymentPurpose;
            case RECIPIENT_NAME -> paymentAnalyticEntity.recipientName;
            case RECIPIENT_ACCOUNT -> paymentAnalyticEntity.recipientAccount;
            case DVRU -> paymentAnalyticEntity.dvruNumber; // обратите внимание: DVRU включает dvruNumber и dvruDate
            case DVRU_DATE -> paymentAnalyticEntity.dvruDate;
            case PAYMENT_TYPE -> paymentAnalyticEntity.paymentType;
            case PAYMENT_OBJECT -> null; // обработаем отдельно
            case SSR_ARTICLE -> null; // обработается при сборе вложенных объектов
        };
        expressions.put(code, expr);
    }

    return expressions;
}

public List<PFLoanFundsRqRegistryItemBo> findResults(List<RegistryCodes> fields) {
    Map<RegistryCodes, Expression<?>> expressions = buildFieldExpressions(fields);

    // Если необходимо получить PAYMENT_OBJECT и SSR_ARTICLE в составе результатов,
    // нам потребуется использовать GroupBy для агрегирования связанных сущностей.
    boolean needPaymentObject = fields.contains(RegistryCodes.PAYMENT_OBJECT);

    JPAQuery<?> query = new JPAQuery<>(entityManager);
    query.from(paymentAnalyticEntity);

    // базовые поля (все, кроме PAYMENT_OBJECT и SSR_ARTICLE)
    // соберём параметры для конструктора
    List<Expression<?>> constructorArgs = new ArrayList<>();

    // Порядок аргументов в Projections.constructor должен соответствовать конструктору PFLoanFundsRqRegistryItemBo
    // Конструктор: (UUID id, UUID clientId, UUID paymentDocumentId, Integer number, PaymentAnalyticStatus status, 
    //  LocalDate date, FundsType fundsType, String creditAgreementNumber, LocalDate creditAgreementDate, String payerAccount,
    //  Boolean obcAccountFlag, LocalDate trancheIssueDate, BigDecimal amount, String paymentPurpose, 
    //  String recipientName, String recipientAccount, String dvruNumber, LocalDate dvruDate, PaymentType paymentType, 
    //  List<PaymentObjectEntityBo> paymentObjects)
    // Для отсутствующих полей будем подставлять nullExpression соответствующего класса.
    constructorArgs.add(fields.contains(RegistryCodes.ID) ? (Expression<?>)expressions.get(RegistryCodes.ID) : Expressions.nullExpression(UUID.class));
    constructorArgs.add(fields.contains(RegistryCodes.CLIENT_ID) ? (Expression<?>)expressions.get(RegistryCodes.CLIENT_ID) : Expressions.nullExpression(UUID.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYMENT_DOCUMENT_ID) ? (Expression<?>)expressions.get(RegistryCodes.PAYMENT_DOCUMENT_ID) : Expressions.nullExpression(UUID.class));
    constructorArgs.add(fields.contains(RegistryCodes.NUMBER) ? (Expression<?>)expressions.get(RegistryCodes.NUMBER) : Expressions.nullExpression(Integer.class));
    constructorArgs.add(fields.contains(RegistryCodes.LOAN_FUNDS_REQUEST_STATUS) ? (Expression<?>)expressions.get(RegistryCodes.LOAN_FUNDS_REQUEST_STATUS) : Expressions.nullExpression(PaymentAnalyticStatus.class));
    constructorArgs.add(fields.contains(RegistryCodes.DATE) ? (Expression<?>)expressions.get(RegistryCodes.DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.FUNDS_TYPE) ? (Expression<?>)expressions.get(RegistryCodes.FUNDS_TYPE) : Expressions.nullExpression(FundsType.class));
    constructorArgs.add(fields.contains(RegistryCodes.CREDIT_AGREEMENT) ? (Expression<?>)expressions.get(RegistryCodes.CREDIT_AGREEMENT) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.CREDIT_AGREEMENT_DATE) ? (Expression<?>)expressions.get(RegistryCodes.CREDIT_AGREEMENT_DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYER_ACCOUNT) ? (Expression<?>)expressions.get(RegistryCodes.PAYER_ACCOUNT) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.OBC_ACCOUNT_FLAG) ? (Expression<?>)expressions.get(RegistryCodes.OBC_ACCOUNT_FLAG) : Expressions.nullExpression(Boolean.class));
    constructorArgs.add(fields.contains(RegistryCodes.TRANCHE_ISSUE_DATE) ? (Expression<?>)expressions.get(RegistryCodes.TRANCHE_ISSUE_DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.AMOUNT) ? (Expression<?>)expressions.get(RegistryCodes.AMOUNT) : Expressions.nullExpression(BigDecimal.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYMENT_PURPOSE) ? (Expression<?>)expressions.get(RegistryCodes.PAYMENT_PURPOSE) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.RECIPIENT_NAME) ? (Expression<?>)expressions.get(RegistryCodes.RECIPIENT_NAME) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.RECIPIENT_ACCOUNT) ? (Expression<?>)expressions.get(RegistryCodes.RECIPIENT_ACCOUNT) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.DVRU) ? (Expression<?>)expressions.get(RegistryCodes.DVRU) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.DVRU_DATE) ? (Expression<?>)expressions.get(RegistryCodes.DVRU_DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYMENT_TYPE) ? (Expression<?>)expressions.get(RegistryCodes.PAYMENT_TYPE) : Expressions.nullExpression(PaymentType.class));

    if (needPaymentObject) {
        // Если нужно поле PAYMENT_OBJECT — используем GroupBy для сборки коллекций
        // Предполагается, что QPaymentObjectEntity paymentObject и QPaymentSsrArticleEntity paymentSsrArticle 
        // являются Q-классами для связанных сущностей.
        
        // Делаем left join для получения paymentObjects
        QPaymentObjectEntity paymentObject = QPaymentObjectEntity.paymentObjectEntity;
        QPaymentSsrArticleEntity paymentSsrArticle = QPaymentSsrArticleEntity.paymentSsrArticleEntity;

        query.leftJoin(paymentAnalyticEntity.paymentObjects, paymentObject);
        query.leftJoin(paymentObject.paymentObjectSsr.paymentSsrArticles, paymentSsrArticle);

        // Сформируем конструктор для вложенных объектов
        Expression<List<PFLoanFundsRqRegistryItemBo.PaymentObjectEntityBo>> paymentObjectsExpression = list(
            Projections.constructor(
                PFLoanFundsRqRegistryItemBo.PaymentObjectEntityBo.class,
                fields.contains(RegistryCodes.PAYMENT_OBJECT) ? paymentObject.name : Expressions.nullExpression(String.class),
                fields.contains(RegistryCodes.PAYMENT_OBJECT) ? paymentObject.projectName : Expressions.nullExpression(String.class),
                Projections.constructor(
                    PFLoanFundsRqRegistryItemBo.PaymentObjectSsrEntityBo.class,
                    list(
                        Projections.constructor(
                            PFLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo.class,
                            fields.contains(RegistryCodes.SSR_ARTICLE) ? paymentSsrArticle.code : Expressions.nullExpression(String.class)
                        )
                    )
                )
            )
        );

        constructorArgs.add(paymentObjectsExpression);

        Map<UUID, PFLoanFundsRqRegistryItemBo> map = query
            .select(paymentAnalyticEntity.id,
                    paymentAnalyticEntity.clientId,
                    paymentAnalyticEntity.paymentDocumentId,
                    paymentAnalyticEntity.number,
                    paymentAnalyticEntity.status,
                    paymentAnalyticEntity.date,
                    paymentAnalyticEntity.fundsType,
                    paymentAnalyticEntity.creditAgreementNumber,
                    paymentAnalyticEntity.creditAgreementDate,
                    paymentAnalyticEntity.payerAccount,
                    paymentAnalyticEntity.obcAccountFlag,
                    paymentAnalyticEntity.trancheIssueDate,
                    paymentAnalyticEntity.amount,
                    paymentAnalyticEntity.paymentPurpose,
                    paymentAnalyticEntity.recipientName,
                    paymentAnalyticEntity.recipientAccount,
                    paymentAnalyticEntity.dvruNumber,
                    paymentAnalyticEntity.dvruDate,
                    paymentAnalyticEntity.paymentType,
                    paymentObject.name,
                    paymentObject.projectName,
                    paymentSsrArticle.code)
            .transform(
                groupBy(paymentAnalyticEntity.id).as(
                    Projections.constructor(
                        PFLoanFundsRqRegistryItemBo.class,
                        constructorArgs.toArray(new Expression[0])
                    )
                )
            );
        return new ArrayList<>(map.values());

    } else {
        // Если PAYMENT_OBJECT не требуется, просто делаем обычную проекцию без groupBy
        // Подставляем null для paymentObjects так как оно не нужно
        constructorArgs.add(Expressions.nullExpression(List.class));

        return query
            .select(Projections.constructor(
                PFLoanFundsRqRegistryItemBo.class,
                constructorArgs.toArray(new Expression[0])
            ))
            .fetch();
    }
}
```

**Объяснения:**  
- В методе `buildFieldExpressions` мы используем `switch` с лямбдами (Java 14+) для выбора соответствующих полей Q-класса или `null`.
- В основном методе `findResults` мы сначала проверяем, нужно ли поле `PAYMENT_OBJECT`. Если оно требуется, то используем `GroupBy` для агрегирования результатов и получения списков. Если нет, делаем простой запрос с конструкторной проекцией.
- Для формирования конструктора DTO используется `List<Expression<?>> constructorArgs`, куда мы добавляем необходимые выражения в нужном порядке.
- При отсутствии определённого поля вставляем `Expressions.nullExpression(Тип.class)`.
- Таким образом устраняется необходимость в тернарном операторе (используется switch + предварительная проверка `fields.contains(...)`), а также динамически включаются или исключаются нужные поля.
  
Официальную документацию по Querydsl GroupBy можно найти по ссылке:  
[Querydsl GroupBy документация](https://querydsl.github.io/)





import static com.querydsl.core.group.GroupBy.*;

Map<UUID, PFLoanFundsRqRegistryItemBo> results = query
    .select(paymentAnalyticEntity.id,
            paymentAnalyticEntity.clientId,
            paymentAnalyticEntity.paymentDocumentId,
            paymentAnalyticEntity.number,
            paymentAnalyticEntity.status,
            paymentAnalyticEntity.date,
            paymentAnalyticEntity.fundsType,
            paymentAnalyticEntity.creditAgreementNumber,
            paymentAnalyticEntity.creditAgreementDate,
            paymentAnalyticEntity.payerAccount,
            paymentAnalyticEntity.obcAccountFlag,
            paymentAnalyticEntity.trancheIssueDate,
            paymentAnalyticEntity.amount,
            paymentAnalyticEntity.paymentPurpose,
            paymentAnalyticEntity.recipientName,
            paymentAnalyticEntity.recipientAccount,
            paymentAnalyticEntity.dvruNumber,
            paymentAnalyticEntity.dvruDate,
            paymentAnalyticEntity.paymentType,
            paymentObject.name,
            paymentObject.projectName,
            paymentSsrArticle.code)
    .from(paymentAnalyticEntity)
    .leftJoin(paymentAnalyticEntity.paymentObjects, paymentObject)
    .leftJoin(paymentObject.paymentObjectSsr.paymentSsrArticles, paymentSsrArticle)
    // Группировка по ID главной сущности
    .transform(
        groupBy(paymentAnalyticEntity.id).as(
            Projections.constructor(
                PFLoanFundsRqRegistryItemBo.class,
                paymentAnalyticEntity.id,
                paymentAnalyticEntity.clientId,
                paymentAnalyticEntity.paymentDocumentId,
                paymentAnalyticEntity.number,
                paymentAnalyticEntity.status,
                paymentAnalyticEntity.date,
                paymentAnalyticEntity.fundsType,
                paymentAnalyticEntity.creditAgreementNumber,
                paymentAnalyticEntity.creditAgreementDate,
                paymentAnalyticEntity.payerAccount,
                paymentAnalyticEntity.obcAccountFlag,
                paymentAnalyticEntity.trancheIssueDate,
                paymentAnalyticEntity.amount,
                paymentAnalyticEntity.paymentPurpose,
                paymentAnalyticEntity.recipientName,
                paymentAnalyticEntity.recipientAccount,
                paymentAnalyticEntity.dvruNumber,
                paymentAnalyticEntity.dvruDate,
                paymentAnalyticEntity.paymentType,
                // Используем GroupBy для сбора объектов
                list(
                    Projections.constructor(
                        PFLoanFundsRqRegistryItemBo.PaymentObjectEntityBo.class,
                        paymentObject.name,
                        paymentObject.projectName,
                        Projections.constructor(
                            PFLoanFundsRqRegistryItemBo.PaymentObjectSsrEntityBo.class,
                            // Для SSR статей тоже собираем список
                            list(
                                Projections.constructor(
                                    PFLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo.class,
                                    paymentSsrArticle.code
                                )
                            )
                        )
                    )
                )
            )
        )
    );






@Repository
public class PaymentAnalyticRepository {

    private final JPAQueryFactory queryFactory;
    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    public PaymentAnalyticRepository(EntityManager entityManager) {
        this.queryFactory = new JPAQueryFactory(entityManager);
    }

    /**
     * Выполняет запрос и группирует результаты по pa.id.
     * Для каждого поля используется list(...), чтобы получить значения в список.
     * Для скалярных полей будет список с одним элементом.
     * Для коллекционных полей - список всех элементов.
     */
    public List<Group> fetchAnalyticsGrouped(
            Expression<?>[] expressions,
            List<OrderSpecifier<?>> orderSpecifiers,
            Pageable pageable,
            Predicate predicate
    ) {
        Integer limit = (pageable != null && pageable.getPageSize() > 0) ? pageable.getPageSize() : null;
        Integer offset = null;
        if (pageable != null && pageable.getOffset() > 0) {
            long off = pageable.getOffset();
            offset = (off <= Integer.MAX_VALUE) ? (int) off : Integer.MAX_VALUE;
        }

        var query = queryFactory.select(expressions).from(pa);

        if (predicate != null) {
            query.where(predicate);
        }

        if (orderSpecifiers != null && !orderSpecifiers.isEmpty()) {
            query.orderBy(orderSpecifiers.toArray(new OrderSpecifier[0]));
        }

        if (limit != null && limit > 0) {
            query.limit(limit);
        }

        if (offset != null && offset >= 0) {
            query.offset(offset);
        }

        // Создание базового GroupByBuilder
        var groupByBuilder = GroupBy.groupBy(pa.id);

        // Список всех агрегаторов
        List<GroupExpression<?, ?>> aggregators = new ArrayList<>();

        // Собираем все агрегаторы
        for (Expression<?> expr : expressions) {
            aggregators.add(createListGroupExpression(expr));
        }

        // Если агрегаторы пусты, добавляем хотя бы id
        if (aggregators.isEmpty()) {
            aggregators.add(createListGroupExpression(pa.id));
        }

        // Завершаем построение GroupByBuilder
        var resultTransformer = groupByBuilder.as(aggregators.toArray(new GroupExpression[0]));

        // Выполняем запрос и трансформацию
        Map<UUID, Group> resultMap = query.transform(resultTransformer);
        return new ArrayList<>(resultMap.values());
    }

    /**
     * Создаёт безопасное выражение для группировки данных в список.
     * @param expr выражение, которое требуется сгруппировать
     * @return GroupExpression для списка
     */
    private <T> GroupExpression<T, List<T>> createListGroupExpression(Expression<T> expr) {
        return GroupBy.list(expr);
    }
}


@Service
public class PaymentAnalyticMapper {

    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    public List<PfLoanFundsRqRegistryItemBo> mapGroupsToDto(Set<RegistryCodes> fields, List<Group> groups, boolean needGrouping) {
        List<PfLoanFundsRqRegistryItemBo> dtos = new ArrayList<>();

        for (Group group : groups) {
            PfLoanFundsRqRegistryItemBo dto = new PfLoanFundsRqRegistryItemBo();

            // Пример для обязательных полей:
            dto.setId(getSingleValue(group, pa.id, Long.class));
            dto.setClientId(getSingleValue(group, pa.clientId, Long.class));
            dto.setPaymentDocumentId(getSingleValue(group, pa.paymentDocumentId, Long.class));

            // Аналогично для других скалярных полей:
            if (fields.contains(RegistryCodes.NUMBER)) {
                dto.setNumber(getSingleValue(group, pa.number, Integer.class));
            }
            if (fields.contains(RegistryCodes.DATE)) {
                dto.setDate(getSingleValue(group, pa.date, java.time.LocalDate.class));
            }
            if (fields.contains(RegistryCodes.FUNDS_TYPE)) {
                dto.setFundsType(getSingleValue(group, pa.fundsType, FundsType.class));
            }
            // И так далее для каждого скалярного поля...

            // Для DVRU (два поля) извлекаем отдельно:
            if (fields.contains(RegistryCodes.DVRU)) {
                dto.setDvruNumber(getSingleValue(group, pa.dvruNumber, String.class));
                dto.setDvruDate(getSingleValue(group, pa.dvruDate, java.time.LocalDate.class));
            }

            // Для PAYMENT_OBJECT (коллекция):
            List<String> paymentObjectNames = null;
            List<String> paymentObjectProjectNames = null;
            if (fields.contains(RegistryCodes.PAYMENT_OBJECT)) {
                paymentObjectNames = group.getList(pa.paymentObjects.any().name);
                paymentObjectProjectNames = group.getList(pa.paymentObjects.any().projectName);
            }

            // Для SSR_ARTICLE (коллекция):
            List<String> ssrArticleCodes = null;
            if (fields.contains(RegistryCodes.SSR_ARTICLE)) {
                ssrArticleCodes = group.getList(pa.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);
            }

            // Собираем paymentObjects
            dto.setPaymentObjects(buildPaymentObjects(paymentObjectNames, paymentObjectProjectNames, ssrArticleCodes));

            dtos.add(dto);
        }

        return dtos;
    }

    /**
     * Для скалярных полей, где ожидается один элемент в списке, извлекаем первый или null.
     */
    private <T> T getSingleValue(Group group, Expression<?> expr, Class<T> type) {
        List<?> values = group.getList(expr);
        if (values == null || values.isEmpty()) {
            return null;
        }
        Object val = values.get(0);
        return type.isInstance(val) ? type.cast(val) : null;
    }

    /**
     * Формируем paymentObjects из списков имён, projectName и кодов статей.
     */
    private List<PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo> buildPaymentObjects(
            List<String> names, List<String> projectNames, List<String> ssrCodes) {
        if (names == null || projectNames == null) {
            return null;
        }
        List<PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo> objects = new ArrayList<>();
        int size = Math.min(names.size(), projectNames.size());

        for (int i = 0; i < size; i++) {
            PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo obj = new PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo(
                names.get(i),
                projectNames.get(i),
                buildPaymentObjectSsr(ssrCodes)
            );
            objects.add(obj);
        }
        return objects.isEmpty() ? null : objects;
    }

    private PfLoanFundsRqRegistryItemBo.PaymentObjectsSsrEntityBo buildPaymentObjectSsr(List<String> ssrCodes) {
        PfLoanFundsRqRegistryItemBo.PaymentObjectsSsrEntityBo ssrDto = new PfLoanFundsRqRegistryItemBo.PaymentObjectsSsrEntityBo(
            buildSsrArticles(ssrCodes)
        );
        return ssrDto;
    }

    private List<PfLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo> buildSsrArticles(List<String> codes) {
        if (codes == null) return null;
        List<PfLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo> articles = new ArrayList<>();
        for (String c : codes) {
            articles.add(new PfLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo(c));
        }
        return articles.isEmpty() ? null : articles;
    }
}





package com.example.repository;

import com.querydsl.jpa.impl.JPAQueryFactory;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.group.Group;
import com.querydsl.core.group.GroupBy;
import com.example.entity.QPaymentAnalyticEntity;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Repository
public class PaymentAnalyticRepository {

    private final JPAQueryFactory queryFactory;
    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    public PaymentAnalyticRepository(javax.persistence.EntityManager entityManager) {
        this.queryFactory = new JPAQueryFactory(entityManager);
    }

    /**
     * Выполняет запрос с динамическими полями (Expression<?>), сортировкой (OrderSpecifier<?>),
     * фильтрацией (Predicate), пагинацией (Pageable) и группировкой.
     * Предполагается, что в expressions присутствуют pa.id, pa.clientId, pa.paymentDocumentId.
     * Возвращает List<Group>.
     */
    public List<Group> fetchAnalyticsGrouped(
            Expression<?>[] expressions,
            List<OrderSpecifier<?>> orderSpecifiers,
            Pageable pageable,
            Predicate predicate,
            boolean needGrouping
    ) {
        Integer limit = (pageable != null && pageable.getPageSize() > 0) ? pageable.getPageSize() : null;
        Integer offset = null;
        if (pageable != null && pageable.getOffset() > 0) {
            long off = pageable.getOffset();
            offset = (off <= Integer.MAX_VALUE) ? (int) off : Integer.MAX_VALUE;
        }

        var query = queryFactory.select(expressions).from(pa);

        if (predicate != null) {
            query.where(predicate);
        }

        if (orderSpecifiers != null && !orderSpecifiers.isEmpty()) {
            query.orderBy(orderSpecifiers.toArray(new OrderSpecifier[0]));
        }

        if (limit != null && limit > 0) {
            query.limit(limit);
        }

        if (offset != null && offset >= 0) {
            query.offset(offset);
        }

        var groupByBuilder = GroupBy.groupBy(pa.id);

        boolean firstAggregator = true;
        for (Expression<?> expr : expressions) {
            if (expr.equals(pa.id)) {
                var aggregator = GroupBy.first(expr).as(expr.toString());
                if (firstAggregator) {
                    groupByBuilder = groupByBuilder.as(aggregator);
                    firstAggregator = false;
                } else {
                    groupByBuilder = groupByBuilder.and(aggregator);
                }
                continue;
            }

            if (expr.equals(pa.clientId) || expr.equals(pa.paymentDocumentId)) {
                var aggregator = GroupBy.first(expr).as(expr.toString());
                if (firstAggregator) {
                    groupByBuilder = groupByBuilder.as(aggregator);
                    firstAggregator = false;
                } else {
                    groupByBuilder = groupByBuilder.and(aggregator);
                }
                continue;
            }

            // Если needGrouping=true, считаем, что это может быть коллекционное поле -> list
            // Иначе first.
            var aggregator = needGrouping ? GroupBy.list(expr) : GroupBy.first(expr);
            aggregator = aggregator.as(expr.toString());
            if (firstAggregator) {
                groupByBuilder = groupByBuilder.as(aggregator);
                firstAggregator = false;
            } else {
                groupByBuilder = groupByBuilder.and(aggregator);
            }
        }

        if (firstAggregator) {
            groupByBuilder = groupByBuilder.as(GroupBy.first(pa.id).as("id"));
        }

        Map<Long, Group> resultMap = query.transform(groupByBuilder);
        return new ArrayList<>(resultMap.values());
    }
}




Ниже представлен улучшенный вариант сервисного слоя, учитывающий принципы SOLID, улучшенную тестируемость и гибкость. Изменения:

1. **Отделение логики сортировки**:  
   Вместо того, чтобы держать логику сортировки в сервисе, она инкапсулирована в отдельном сервисе/компоненте `SortingService`, который использует `SortOrderBuilder`. Это упростит тестирование: можно отдельно тестировать логику формирования сортировки, подавая разные входные данные и проверяя выходные `OrderSpecifier<?>`.

2. **Отделение логики маппинга**:  
   Создан отдельный маппер `PaymentAnalyticMapper` для преобразования `List<Group>` в `List<PaymentAnalyticDto>` и сборки коллекций в объекты DTO. Это соответствует принципу единственной ответственности (SRP). Теперь `PaymentAnalyticService` не знает деталей о том, как именно маппить поля или коллекции, его задача — orchestrate процесс: получить данные от репозитория, запросить у `SortingService` сортировку, передать их мапперу для преобразования. Это упрощает тестирование, потому что можно отдельно тестировать маппер и отдельно тестировать сервис.

3. **S.O.L.I.D.**:  
   - **S (Single Responsibility)**: Сервис отвечает за общий поток: получить параметры, вызвать репозиторий, отсортировать, замаппить. Логику сортировки и маппинга вынесли в отдельные классы.  
   - **O (Open-Closed)**: Добавить новый вид сортировки или изменить маппинг можно, не меняя код сервисного слоя.  
   - **L (Liskov Substitution)**: Не нарушается, так как мы не меняем иерархии.  
   - **I (Interface Segregation)**: Можно при необходимости выделить интерфейсы для `SortingService`, `PaymentAnalyticMapper`.  
   - **D (Dependency Inversion)**: Сервис зависит от абстракций (например, интерфейсов маппера и сортировщика, если их выделить), а не от конкретных реализаций.

4. **Тестируемость**:  
   - Можно замокать `SortingService` и `PaymentAnalyticMapper` и тестировать `PaymentAnalyticService` изолированно.  
   - Можно отдельно протестировать `PaymentAnalyticMapper` и `SortingService`.

### Код примера

#### PaymentAnalyticMapper.java
```java
package com.example.mapper;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.PaymentAnalyticDto;
import com.example.dto.PaymentAnalyticDto.PaymentObjectEntityDto;
import com.example.dto.PaymentAnalyticDto.PaymentObjectSsrEntityDto;
import com.example.dto.PaymentAnalyticDto.PaymentSsrArticleDto;
import com.example.entity.PaymentAnalyticStatus;
import com.example.entity.PaymentType;
import com.example.entity.FundsType;
import com.example.entity.QPaymentAnalyticEntity;
import com.querydsl.core.group.Group;
import com.querydsl.core.types.Expression;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class PaymentAnalyticMapper {

    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    /**
     * Маппит результаты выборки (List<Group>) в List<PaymentAnalyticDto>.
     * @param fields выбранные поля (содержит ID, CLIENT_ID, PAYMENT_DOCUMENT_ID)
     * @param groups результат запроса
     * @param needGrouping true, если нужны коллекции
     */
    public List<PaymentAnalyticDto> mapGroupsToDto(Set<RegistryCodes> fields, List<Group> groups, boolean needGrouping) {
        List<PaymentAnalyticDto> dtos = new ArrayList<>();

        for (Group g : groups) {
            PaymentAnalyticDto dto = new PaymentAnalyticDto();
            dto.setId((Long) g.get(pa.id));
            dto.setClientId((Long) g.get(pa.clientId));
            dto.setPaymentDocumentId((Long) g.get(pa.paymentDocumentId));

            List<String> paymentObjectNames = null;
            List<String> paymentObjectProjectNames = null;
            List<String> ssrArticleCodes = null;

            // Проходим по полям и маппим скалярные значения
            for (RegistryCodes code : fields) {
                CodeDefinition cd = RegistryCodeDefinitions.getCodeDefinition(code);
                if (cd == null) continue;

                for (Expression<?> expr : cd.getProjections()) {
                    Object value = g.get(expr);
                    if (value == null) continue;

                    switch (code) {
                        case NUMBER -> dto.setNumber((Integer) value);
                        case DATE -> dto.setDate((LocalDate) value);
                        case LOAN_FUNDS_REQUEST_STATUS -> dto.setStatus((PaymentAnalyticStatus) value);
                        case FUNDS_TYPE -> dto.setFundsType((FundsType) value);
                        case CREDIT_AGREEMENT -> {
                            if (expr.equals(pa.creditAgreementNumber)) {
                                dto.setCreditAgreementNumber((String) value);
                            } else if (expr.equals(pa.creditAgreementDate)) {
                                dto.setCreditAgreementDate((LocalDate) value);
                            }
                        }
                        case PAYER_ACCOUNT -> {
                            if (expr.equals(pa.payerAccount)) {
                                dto.setPayerAccount((String) value);
                            } else if (expr.equals(pa.obcAccountFlag)) {
                                dto.setObcAccountFlag((Boolean) value);
                            }
                        }
                        case TRANCHE_ISSUE_DATE -> dto.setTrancheIssueDate((LocalDate) value);
                        case AMOUNT -> dto.setAmount((BigDecimal) value);
                        case PAYMENT_PURPOSE -> dto.setPaymentPurpose((String) value);
                        case RECIPIENT_NAME -> dto.setRecipientName((String) value);
                        case RECIPIENT_ACCOUNT -> dto.setRecipientAccount((String) value);
                        case DVRU -> {
                            if (expr.equals(pa.dvruNumber)) {
                                dto.setDvruNumber((String) value);
                            } else if (expr.equals(pa.dvruDate)) {
                                dto.setDvruDate((LocalDate) value);
                            }
                        }
                        case PAYMENT_TYPE -> dto.setPaymentType((PaymentType) value);
                        case PAYMENT_OBJECT -> {
                            // Коллекции имён и projectName
                            if (expr.toString().contains("projectName")) {
                                paymentObjectProjectNames = (List<String>) value;
                            } else if (expr.toString().contains("name")) {
                                paymentObjectNames = (List<String>) value;
                            }
                        }
                        case SSR_ARTICLE -> {
                            ssrArticleCodes = (List<String>) value;
                        }
                        default -> {
                            // Остальные игнорируем
                        }
                    }
                }
            }

            // Сборка paymentObjects из списков
            dto.setPaymentObjects(buildPaymentObjects(paymentObjectNames, paymentObjectProjectNames, ssrArticleCodes));

            dtos.add(dto);
        }

        return dtos;
    }

    /**
     * Строим список PaymentObjectEntityDto из списков строк.
     */
    private List<PaymentObjectEntityDto> buildPaymentObjects(List<String> names, List<String> projectNames, List<String> ssrCodes) {
        if (names == null || projectNames == null) {
            return null;
        }

        List<PaymentObjectEntityDto> objects = new ArrayList<>();
        int size = Math.min(names.size(), projectNames.size());
        for (int i = 0; i < size; i++) {
            PaymentObjectEntityDto obj = new PaymentObjectEntityDto();
            obj.setName(names.get(i));
            obj.setProjectName(projectNames.get(i));

            PaymentObjectSsrEntityDto ssr = new PaymentObjectSsrEntityDto();
            ssr.setPaymentSsrArticles(buildSsrArticles(ssrCodes));
            obj.setPaymentObjectSsr(ssr);

            objects.add(obj);
        }

        return objects.isEmpty() ? null : objects;
    }

    /**
     * Строим список PaymentSsrArticleDto из списка кодов.
     */
    private List<PaymentSsrArticleDto> buildSsrArticles(List<String> codes) {
        if (codes == null) return null;
        List<PaymentSsrArticleDto> articles = new ArrayList<>();
        for (String c : codes) {
            PaymentSsrArticleDto a = new PaymentSsrArticleDto();
            a.setCode(c);
            articles.add(a);
        }
        return articles.isEmpty() ? null : articles;
    }
}
```

#### SortingService.java
```java
package com.example.service;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.SortingDto;
import com.example.util.SortOrderBuilder;
import com.querydsl.core.types.OrderSpecifier;

import java.util.List;

public class SortingService {

    /**
     * Возвращает список OrderSpecifier для сортировки на основании SortingDto.
     */
    public List<OrderSpecifier<?>> getOrderSpecifiers(SortingDto sortingDto) {
        String sortField = sortingDto != null ? sortingDto.getSortField() : null;
        Boolean sortDescending = sortingDto != null ? sortingDto.getSortDescending() : Boolean.TRUE;

        return SortOrderBuilder.buildOrderSpecifiers(sortField, sortDescending);
    }
}
```

#### PaymentAnalyticService.java
```java
package com.example.service;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.PaymentAnalyticDto;
import com.example.dto.SortingDto;
import com.example.entity.QPaymentAnalyticEntity;
import com.example.mapper.PaymentAnalyticMapper;
import com.example.repository.PaymentAnalyticRepository;
import com.querydsl.core.group.Group;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.OrderSpecifier;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class PaymentAnalyticService {

    private final PaymentAnalyticRepository repository;
    private final SortingService sortingService;
    private final PaymentAnalyticMapper mapper;

    public PaymentAnalyticService(PaymentAnalyticRepository repository, SortingService sortingService, PaymentAnalyticMapper mapper) {
        this.repository = repository;
        this.sortingService = sortingService;
        this.mapper = mapper;
    }

    public List<PaymentAnalyticDto> getPaymentAnalytics(
            List<RegistryCodes> fields,
            SortingDto sortingDto,
            Pageable pageable,
            Predicate predicate
    ) {
        boolean needGrouping = fields.contains(RegistryCodes.PAYMENT_OBJECT)
                            || fields.contains(RegistryCodes.SSR_ARTICLE);

        // Всегда добавляем обязательные поля
        Set<RegistryCodes> extendedFields = new LinkedHashSet<>(fields);
        extendedFields.add(RegistryCodes.ID);
        extendedFields.add(RegistryCodes.CLIENT_ID);
        extendedFields.add(RegistryCodes.PAYMENT_DOCUMENT_ID);

        // Формируем projections
        List<Expression<?>> exprs = new ArrayList<>();
        for (RegistryCodes code : extendedFields) {
            CodeDefinition cd = RegistryCodeDefinitions.getCodeDefinition(code);
            if (cd != null && !cd.getProjections().isEmpty()) {
                exprs.addAll(cd.getProjections());
            }
        }

        // Получаем сортировку от SortingService
        List<OrderSpecifier<?>> orderSpecifiers = sortingService.getOrderSpecifiers(sortingDto);

        Expression<?>[] expressionsArray = exprs.toArray(new Expression[0]);
        List<Group> groups = repository.fetchAnalyticsGrouped(
                expressionsArray,
                orderSpecifiers,
                pageable,
                predicate,
                needGrouping
        );

        // Маппим результаты в DTO
        return mapper.mapGroupsToDto(extendedFields, groups, needGrouping);
    }
}
```

---

**Комментарии:**

- **PaymentAnalyticService**:  
  - Зависит от `PaymentAnalyticRepository` (получение данных),  
  - `SortingService` (получение списков сортировок),  
  - `PaymentAnalyticMapper` (маппинг результатов).
  
  Так мы можем легко замокать эти зависимости в тестах и протестировать логику `PaymentAnalyticService` изолированно.

- **SortingService**:  
  Использует `SortOrderBuilder` для получения `OrderSpecifier`. Можно добавить интерфейс для `SortingService`, чтобы при необходимости использовать разные реализации.

- **PaymentAnalyticMapper**:  
  Инкапсулирует всю логику маппинга `Group` в `PaymentAnalyticDto`. Можно тестировать отдельно: подать на вход тестовые `Group` и проверить корректность сформированных DTO.

Таким образом, код стал более модульным, соответствующим принципам SOLID, упрощенным для тестирования и расширяемости.




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
import com.querydsl.core.types.Order;
import com.querydsl.core.types.OrderSpecifier;

import java.util.ArrayList;
import java.util.List;

public class SortOrderBuilder {
    
    // Поле по умолчанию для сортировки
    private static final OrderSpecifier<?> DEFAULT_ORDER = QPaymentAnalyticEntity.paymentAnalyticEntity.date.desc();
    
    /**
     * Формируем список сортировок на основании входного сортировочного запроса.
     * @param sortField        Строковое значение поля сортировки, соответствует одному из RegistryCodes (или null)
     * @param sortDescending   Если true - сортируем по убыванию, иначе по возрастанию.
     * @return список OrderSpecifier для применения в запросе QueryDSL
     */
    public static List<OrderSpecifier<?>> buildOrderSpecifiers(String sortField, Boolean sortDescending) {
        List<OrderSpecifier<?>> orderSpecifiers = new ArrayList<>();

        RegistryCodes code = null;
        if (sortField != null && !sortField.isBlank()) {
            try {
                code = RegistryCodes.valueOf(sortField.toUpperCase());
            } catch (IllegalArgumentException e) {
                // Если не удалось сопоставить sortField с RegistryCodes, code остаётся null
            }
        }
        
        // Если код не найден или не задан, применяем сортировку по умолчанию
        if (code == null) {
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        CodeDefinition definition = RegistryCodeDefinitions.getCodeDefinition(code);
        if (definition == null) {
            // Если для данного code нет определения - сортируем по умолчанию
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        // Берём orderSpecifiers из определения
        List<OrderSpecifier<?>> baseOrderSpecifiers = definition.getOrderSpecifiers();
        if (baseOrderSpecifiers.isEmpty()) {
            // Если нет явно заданных сортировок в CodeDefinition, сортируем по умолчанию
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        // Инвертируем направление при необходимости
        if (Boolean.TRUE.equals(sortDescending)) {
            // Если нужно сортировать по убыванию, то для каждого поля применяем descending
            for (OrderSpecifier<?> os : baseOrderSpecifiers) {
                orderSpecifiers.add(os.getTarget().desc());
            }
        } else {
            // Если нужно сортировать по возрастанию - используем baseOrderSpecifiers как есть, предполагая что они уже asc.
            // Если в базе CodeDefinition хранились Asc, то просто добавляем их.
            // Если нужно более гибко, можно хранить исходные поля без OrderSpecifier и здесь формировать нужный Order.
            for (OrderSpecifier<?> os : baseOrderSpecifiers) {
                orderSpecifiers.add(os.getTarget().asc());
            }
        }

        return orderSpecifiers;
    }
}






package com.example.config;

import com.querydsl.core.group.GroupBy;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.dsl.ComparableExpressionBase;
import com.querydsl.core.types.dsl.DatePath;
import com.querydsl.core.types.dsl.NumberExpression;
import com.querydsl.core.types.dsl.StringExpression;
import com.example.entity.QPaymentAnalyticEntity;
import com.example.entity.QPaymentObjectEntityBo;
import com.example.entity.QPaymentObjectsSsrEntityBo;
import com.example.entity.QPaymentSsrArticleEntityBo;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.querydsl.core.group.GroupBy.list;

public class RegistryCodeDefinitions {

    private static final QPaymentAnalyticEntity paymentAnalyticEntity = QPaymentAnalyticEntity.paymentAnalyticEntity;
    private static final QPaymentObjectEntityBo paymentObjectEntityBo = QPaymentObjectEntityBo.paymentObjectEntityBo;
    private static final QPaymentObjectsSsrEntityBo paymentObjectsSsrEntityBo = QPaymentObjectsSsrEntityBo.paymentObjectsSsrEntityBo;
    private static final QPaymentSsrArticleEntityBo paymentSsrArticleEntityBo = QPaymentSsrArticleEntityBo.paymentSsrArticleEntityBo;

    private static final Map<RegistryCodes, CodeDefinition> CODE_DEFINITIONS = new HashMap<>();

    static {
        // Обязательные поля
        CODE_DEFINITIONS.put(
            RegistryCodes.ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.id),
                List.of(paymentAnalyticEntity.id.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.CLIENT_ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.clientId),
                List.of(paymentAnalyticEntity.clientId.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_DOCUMENT_ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentDocumentId),
                List.of(paymentAnalyticEntity.paymentDocumentId.asc())
            )
        );

        // Примитивные поля
        CODE_DEFINITIONS.put(
            RegistryCodes.NUMBER,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.number),
                List.of(paymentAnalyticEntity.number.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.date),
                List.of(paymentAnalyticEntity.date.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.LOAN_FUNDS_REQUEST_STATUS,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.status),
                List.of(paymentAnalyticEntity.status.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.FUNDS_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.fundsType),
                List.of(paymentAnalyticEntity.fundsType.asc())
            )
        );

        // CREDIT_AGREEMENT: два поля (номер, дата)
        CODE_DEFINITIONS.put(
            RegistryCodes.CREDIT_AGREEMENT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.creditAgreementNumber, paymentAnalyticEntity.creditAgreementDate),
                List.of(paymentAnalyticEntity.creditAgreementNumber.asc(), paymentAnalyticEntity.creditAgreementDate.asc())
            )
        );

        // PAYER_ACCOUNT: два поля (payerAccount, obcAccountFlag)
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYER_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.payerAccount, paymentAnalyticEntity.obcAccountFlag),
                List.of(paymentAnalyticEntity.payerAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.TRANCHE_ISSUE_DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.trancheIssueDate),
                List.of(paymentAnalyticEntity.trancheIssueDate.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.AMOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.amount),
                List.of(paymentAnalyticEntity.amount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_PURPOSE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentPurpose),
                List.of(paymentAnalyticEntity.paymentPurpose.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_NAME,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientName),
                List.of(paymentAnalyticEntity.recipientName.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientAccount),
                List.of(paymentAnalyticEntity.recipientAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentType),
                List.of(paymentAnalyticEntity.paymentType.asc())
            )
        );

        // DVRU: два поля (dvruNumber, dvruDate)
        CODE_DEFINITIONS.put(
            RegistryCodes.DVRU,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.dvruNumber, paymentAnalyticEntity.dvruDate),
                List.of(paymentAnalyticEntity.dvruNumber.asc(), paymentAnalyticEntity.dvruDate.asc())
            )
        );

        // PAYMENT_OBJECT: Коллекция paymentObjects (name, projectName).
        // Возвращаем List<String> для имен и List<String> для projectName
        Expression<List<String>> paymentObjectNames = list(paymentAnalyticEntity.paymentObjects.any().name);
        Expression<List<String>> paymentObjectProjectNames = list(paymentAnalyticEntity.paymentObjects.any().projectName);

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_OBJECT,
            new CodeDefinition(
                List.of(paymentObjectNames, paymentObjectProjectNames),
                Collections.emptyList()
            )
        );

        // SSR_ARTICLE: Коллекция кодов статей
        Expression<List<String>> ssrArticleCodes = list(paymentAnalyticEntity.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);

        CODE_DEFINITIONS.put(
            RegistryCodes.SSR_ARTICLE,
            new CodeDefinition(
                List.of(ssrArticleCodes),
                Collections.emptyList()
            )
        );
    }

    public static CodeDefinition getCodeDefinition(RegistryCodes code) {
        return CODE_DEFINITIONS.get(code);
    }
}





import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;

import java.util.List;

/**
 * CodeDefinition будет хранить Expressions для проекций и OrderSpecifiers для сортировки.
 * В дальнейшем мы будем наполнять эти структуры конкретными значениями для каждого RegistryCodes.
 */
public class CodeDefinition {
    private final List<Expression<?>> projections;
    private final List<OrderSpecifier<?>> orderSpecifiers;

}

    public CodeDefinition(List<Expression<?>> projections, List<OrderSpecifier<?>> orderSpecifiers) {
        this.projections = projections;
        this.orderSpecifiers = orderSpecifiers;
    }

    public List<Expression<?>> getProjections() {
        return projections;
    }

    public List<OrderSpecifier<?>> getOrderSpecifiers() {
        return orderSpecifiers;
    }
import com.querydsl.core.group.GroupBy;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.dsl.ComparableExpressionBase;
import com.querydsl.core.types.dsl.DatePath;
import com.querydsl.core.types.dsl.NumberExpression;
import com.querydsl.core.types.dsl.StringExpression;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.querydsl.core.group.GroupBy.list;

public class RegistryCodeDefinitions {

    private static final QPaymentAnalyticEntity paymentAnalyticEntity = QPaymentAnalyticEntity.paymentAnalyticEntity;
    private static final QPaymentObjectEntityBo paymentObjectEntityBo = QPaymentObjectEntityBo.paymentObjectEntityBo;
    private static final QPaymentObjectsSsrEntityBo paymentObjectsSsrEntityBo = QPaymentObjectsSsrEntityBo.paymentObjectsSsrEntityBo;
    private static final QPaymentSsrArticleEntityBo paymentSsrArticleEntityBo = QPaymentSsrArticleEntityBo.paymentSsrArticleEntityBo;

    private static final Map<RegistryCodes, CodeDefinition> CODE_DEFINITIONS = new HashMap<>();

    static {
        // Пример для простых полей
        CODE_DEFINITIONS.put(
            RegistryCodes.NUMBER,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.number),
                List.of(paymentAnalyticEntity.number.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.date),
                List.of(paymentAnalyticEntity.date.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.LOAN_FUNDS_REQUEST_STATUS,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.status),
                List.of(paymentAnalyticEntity.status.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.FUNDS_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.fundsType),
                List.of(paymentAnalyticEntity.fundsType.asc())
            )
        );

        // CREDIT_AGREEMENT: два поля (номер, дата)
        CODE_DEFINITIONS.put(
            RegistryCodes.CREDIT_AGREEMENT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.creditAgreementNumber, paymentAnalyticEntity.creditAgreementDate),
                List.of(paymentAnalyticEntity.creditAgreementNumber.asc(), paymentAnalyticEntity.creditAgreementDate.asc())
            )
        );

        // PAYER_ACCOUNT: два поля (payerAccount, obcAccountFlag)
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYER_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.payerAccount, paymentAnalyticEntity.obcAccountFlag),
                List.of(paymentAnalyticEntity.payerAccount.asc()) // сортируем по payerAccount
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.TRANCHE_ISSUE_DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.trancheIssueDate),
                List.of(paymentAnalyticEntity.trancheIssueDate.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.AMOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.amount),
                List.of(paymentAnalyticEntity.amount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_PURPOSE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentPurpose),
                List.of(paymentAnalyticEntity.paymentPurpose.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_NAME,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientName),
                List.of(paymentAnalyticEntity.recipientName.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientAccount),
                List.of(paymentAnalyticEntity.recipientAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentType),
                List.of(paymentAnalyticEntity.paymentType.asc())
            )
        );

        // DVRU: два поля (dvruNumber, dvruDate)
        CODE_DEFINITIONS.put(
            RegistryCodes.DVRU,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.dvruNumber, paymentAnalyticEntity.dvruDate),
                List.of(paymentAnalyticEntity.dvruNumber.asc(), paymentAnalyticEntity.dvruDate.asc())
            )
        );

        // PAYMENT_OBJECT: Коллекция paymentObjects с полями name, projectName.
        // Для агрегации используем list(...) из GroupBy.
        Expression<List<String>> paymentObjectNames = list(paymentAnalyticEntity.paymentObjects.any().name);
        Expression<List<String>> paymentObjectProjectNames = list(paymentAnalyticEntity.paymentObjects.any().projectName);

        // Здесь сортировка для коллекций не предусмотрена, оставляем пустой список
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_OBJECT,
            new CodeDefinition(
                List.of(paymentObjectNames, paymentObjectProjectNames),
                Collections.emptyList()
            )
        );

        // SSR_ARTICLE: Коллекция кодов articles через paymentObjectSsr -> paymentSsrArticles
        Expression<List<String>> ssrArticleCodes = list(paymentAnalyticEntity.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);

        CODE_DEFINITIONS.put(
            RegistryCodes.SSR_ARTICLE,
            new CodeDefinition(
                List.of(ssrArticleCodes),
                Collections.emptyList() // Нет сортировки по коллекциям
            )
        );
    }

    public static CodeDefinition getCodeDefinition(RegistryCodes code) {
        return CODE_DEFINITIONS.get(code);
    }
}
