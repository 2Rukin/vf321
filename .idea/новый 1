import jakarta.persistence.criteria.*;
import jakarta.persistence.metamodel.Attribute;
import jakarta.persistence.metamodel.CollectionAttribute;
import jakarta.persistence.metamodel.ListAttribute;
import jakarta.persistence.metamodel.MapAttribute;
import jakarta.persistence.metamodel.SetAttribute;
import jakarta.persistence.metamodel.SingularAttribute;
import jakarta.persistence.metamodel.PluralAttribute;
import jakarta.persistence.metamodel.Bindable;
import jakarta.persistence.metamodel.Attribute.PersistentAttributeType;

public interface UniversalJoiner {

    /**
     * Универсальный метод для JOIN с учетом типа атрибута.
     * <X> - тип корневой сущности (или типа, от которого мы джойним)
     * <Y> - тип целевого существа (или элемента коллекции), к которому делаем JOIN
     */
    @SuppressWarnings("unchecked")
    default <X, Y> Join<X, Y> join(From<X, ?> from,
                                   Attribute<? super X, ?> attribute,
                                   JoinType joinType) {
        // Проверяем тип атрибута и выполняем соответствующий JOIN
        if (attribute instanceof SingularAttribute) {
            // Одиночный атрибут (ManyToOne, OneToOne и т.д.)
            SingularAttribute<? super X, Y> singularAttribute = (SingularAttribute<? super X, Y>) attribute;
            return from.join(singularAttribute, joinType);

        } else if (attribute instanceof CollectionAttribute) {
            // Коллекция без порядка (Collection)
            CollectionAttribute<? super X, Y> collectionAttribute = (CollectionAttribute<? super X, Y>) attribute;
            return (Join<X, Y>) from.join(collectionAttribute, joinType);

        } else if (attribute instanceof SetAttribute) {
            // Множество (Set)
            SetAttribute<? super X, Y> setAttribute = (SetAttribute<? super X, Y>) attribute;
            return (Join<X, Y>) from.join(setAttribute, joinType);

        } else if (attribute instanceof ListAttribute) {
            // Список (List)
            ListAttribute<? super X, Y> listAttribute = (ListAttribute<? super X, Y>) attribute;
            return (Join<X, Y>) from.join(listAttribute, joinType);

        } else if (attribute instanceof MapAttribute) {
            // Карта (Map)
            MapAttribute<? super X, Object, Y> mapAttribute = (MapAttribute<? super X, Object, Y>) attribute;
            return (Join<X, Y>) from.join(mapAttribute, joinType);

        } else {
            // Если атрибут не поддерживается
            throw new IllegalArgumentException("Unsupported attribute type: " + attribute);
        }
    }
}



import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityGraph;
import jakarta.persistence.criteria.*;
import jakarta.persistence.metamodel.Attribute;
import jakarta.persistence.metamodel.PluralAttribute;
import jakarta.persistence.metamodel.SingularAttribute;
import java.util.*;
import java.util.function.Function;

/**
 * QueryBuilder - интерфейс для упрощенной и типобезопасной работы с Criteria API с интеграцией Jakarta API.
 * @param <T> Тип сущности, с которой работает запрос.
 */
public interface QueryBuilder<T> {

    CriteriaBuilder getCriteriaBuilder();

    CriteriaQuery<T> getCriteriaQuery();

    Root<T> getRoot();

    EntityManager getEntityManager();

    /**
     * Получение поля сущности через метамодель.
     */
    default <Y> Path<Y> get(SingularAttribute<T, Y> attribute) {
        return getRoot().get(attribute);
    }

    /**
     * Универсальный метод для JOIN.
     */
    default <X, Y> Join<X, Y> join(From<X, ?> from, Attribute<? super X, ?> attribute, JoinType joinType) {
        if (attribute instanceof SingularAttribute) {
            return from.join((SingularAttribute<? super X, Y>) attribute, joinType);
        } else if (attribute instanceof PluralAttribute) {
            return from.join((PluralAttribute<? super X, ?, Y>) attribute, joinType);
        } else {
            throw new IllegalArgumentException("Unsupported attribute type: " + attribute.getClass());
        }
    }

    /**
     * Перегрузка для JOIN с использованием строкового имени атрибута.
     */
    default <X, Y> Join<X, Y> join(From<X, ?> from, String attributeName, JoinType joinType) {
        return from.join(attributeName, joinType);
    }

    /**
     * Добавление условия (WHERE) к запросу.
     */
    default void addPredicate(Predicate predicate) {
        CriteriaQuery<T> query = getCriteriaQuery();
        Predicate existingPredicate = query.getRestriction();
        query.where(existingPredicate == null ? predicate : getCriteriaBuilder().and(existingPredicate, predicate));
    }

    /**
     * Добавление сортировки.
     */
    default void addOrder(SingularAttribute<T, ?> attribute, boolean ascending) {
        CriteriaQuery<T> query = getCriteriaQuery();
        Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
        query.orderBy(order);
    }

    /**
     * Динамическая настройка сложного EntityGraph.
     * @param entityGraphName Имя графа.
     * @param attributes Список полных путей (например, "paymentObjects.paymentSsrArticles").
     */
    default void applyComplexEntityGraph(String entityGraphName, List<String> attributes) {
        EntityGraph<?> entityGraph = getEntityManager().createEntityGraph(entityGraphName);
        for (String attributePath : attributes) {
            String[] parts = attributePath.split("\\.");
            if (parts.length == 1) {
                entityGraph.addAttributeNodes(parts[0]);
            } else {
                Subgraph<?> subgraph = entityGraph.addSubgraph(parts[0]);
                for (int i = 1; i < parts.length; i++) {
                    subgraph.addAttributeNodes(parts[i]);
                }
            }
        }
        getEntityManager().setProperty("javax.persistence.fetchgraph", entityGraph);
    }

    /**
     * Построение выражения SUM для указанного атрибута.
     */
    default <N extends Number> Expression<N> sum(SingularAttribute<? super T, N> attribute) {
        return getCriteriaBuilder().sum(get(attribute));
    }

    /**
     * Построение выражения AVG для указанного атрибута.
     */
    default <N extends Number> Expression<Double> avg(SingularAttribute<? super T, N> attribute) {
        return getCriteriaBuilder().avg(get(attribute));
    }

    /**
     * Упрощённое создание CASE WHEN выражения.
     */
    default <Y> Expression<Y> caseWhen(Function<CriteriaBuilder.Case<Y>, CriteriaBuilder.Case<Y>> caseLogic) {
        CriteriaBuilder.Case<Y> caseExpression = getCriteriaBuilder().selectCase();
        return caseLogic.apply(caseExpression);
    }

    /**
     * Динамическая сортировка по множеству полей.
     */
    default void addSorting(Map<SingularAttribute<? super T, ?>, Boolean> sortingRules) {
        List<Order> orders = new ArrayList<>();
        sortingRules.forEach((attribute, ascending) -> {
            Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
            orders.add(order);
        });
        getCriteriaQuery().orderBy(orders);
    }

    /**
     * Выполнение запроса через EntityManager.
     */
    default List<T> execute() {
        return getEntityManager().createQuery(getCriteriaQuery()).getResultList();
    }

    /**
     * Выполнение запроса с пагинацией.
     */
    default List<T> executeWithPagination(int offset, int limit) {
        return getEntityManager().createQuery(getCriteriaQuery())
                .setFirstResult(offset)
                .setMaxResults(limit)
                .getResultList();
    }
}




### Полное решение с учетом ваших требований

#### **1. Интерфейс `QueryBuilder` с поддержкой типобезопасного построения запросов**

```java
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityGraph;
import jakarta.persistence.criteria.*;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * QueryBuilder - интерфейс для упрощенной и типобезопасной работы с Criteria API с опциональной интеграцией QueryHelper.
 * @param <T> Тип сущности, с которой работает запрос.
 */
public interface QueryBuilder<T> {

    CriteriaBuilder getCriteriaBuilder();

    CriteriaQuery<T> getCriteriaQuery();

    Root<T> getRoot();

    EntityManager getEntityManager();

    /**
     * Получение поля сущности через метамодель.
     */
    default <Y> Path<Y> get(SingularAttribute<T, Y> attribute) {
        return getRoot().get(attribute);
    }

    /**
     * Выполнение join с другой сущностью.
     */
    default <Y> Join<T, Y> join(PluralAttribute<T, ?, Y> attribute, JoinType joinType) {
        return getRoot().join(attribute, joinType);
    }

    /**
     * Добавление условия (где) к запросу.
     */
    default void addPredicate(Predicate predicate) {
        CriteriaQuery<T> query = getCriteriaQuery();
        query.where(predicate);
    }

    /**
     * Добавление сортировки к запросу.
     */
    default void addOrder(SingularAttribute<T, ?> attribute, boolean ascending) {
        CriteriaQuery<T> query = getCriteriaQuery();
        Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
        query.orderBy(order);
    }

    /**
     * Динамическая настройка EntityGraph.
     * @param attributes Список полей для загрузки.
     */
    default void applyEntityGraph(List<String> attributes) {
        EntityGraph<?> entityGraph = getEntityManager().createEntityGraph(getRoot().getJavaType());
        attributes.forEach(entityGraph::addAttributeNodes);
        getEntityManager().setProperty("javax.persistence.fetchgraph", entityGraph);
    }

    /**
     * Построение агрегатного выражения (например, SUM).
     */
    default <Y> Expression<Y> sum(Expression<Y> expression) {
        return getCriteriaBuilder().sum(expression);
    }

    /**
     * Построение CASE WHEN выражения.
     */
    default <Y> Expression<Y> caseWhen(Consumer<CriteriaBuilder.Case<Y>> caseBuilder) {
        CriteriaBuilder.Case<Y> caseExpression = getCriteriaBuilder().selectCase();
        caseBuilder.accept(caseExpression);
        return caseExpression;
    }

    /**
     * Выполнение запроса через EntityManager.
     */
    default List<T> execute() {
        return getEntityManager().createQuery(getCriteriaQuery()).getResultList();
    }

    /**
     * Выполнение запроса с ограничением на количество записей (пагинация).
     */
    default List<T> executeWithPagination(int offset, int limit) {
        return getEntityManager().createQuery(getCriteriaQuery())
                .setFirstResult(offset)
                .setMaxResults(limit)
                .getResultList();
    }

    /**
     * Упрощённая сортировка по множеству полей.
     */
    default void addMultipleOrderBy(Map<SingularAttribute<T, ?>, Boolean> sortingMap) {
        List<Order> orders = new ArrayList<>();
        sortingMap.forEach((attribute, ascending) -> {
            Order order = ascending ? getCriteriaBuilder().asc(get(attribute)) : getCriteriaBuilder().desc(get(attribute));
            orders.add(order);
        });
        getCriteriaQuery().orderBy(orders);
    }

    /**
     * Встроенные функции для полей метамодели (реализация RegistryCodes).
     */
    interface RegistryFields<T> {

        default Path<?> field(QueryBuilder<T> builder, SingularAttribute<T, ?> attribute) {
            return builder.get(attribute);
        }

        default Expression<Long> countField(QueryBuilder<T> builder, SingularAttribute<T, ?> attribute) {
            return builder.getCriteriaBuilder().count(builder.get(attribute));
        }

        default Expression<Double> averageField(QueryBuilder<T> builder, SingularAttribute<T, ? extends Number> attribute) {
            return builder.getCriteriaBuilder().avg(builder.get(attribute));
        }

        default <Y> Expression<Y> caseWhenField(QueryBuilder<T> builder, Consumer<CriteriaBuilder.Case<Y>> caseLogic) {
            return builder.caseWhen(caseLogic);
        }
    }
}
```

---

#### **2. Реализация `QueryBuilder`**

```java
public class QueryBuilderImpl<T> implements QueryBuilder<T> {

    private final EntityManager entityManager;
    private final CriteriaBuilder criteriaBuilder;
    private final CriteriaQuery<T> criteriaQuery;
    private final Root<T> root;

    public QueryBuilderImpl(EntityManager entityManager, Class<T> entityClass) {
        this.entityManager = entityManager;
        this.criteriaBuilder = entityManager.getCriteriaBuilder();
        this.criteriaQuery = criteriaBuilder.createQuery(entityClass);
        this.root = criteriaQuery.from(entityClass);
    }

    @Override
    public CriteriaBuilder getCriteriaBuilder() {
        return criteriaBuilder;
    }

    @Override
    public CriteriaQuery<T> getCriteriaQuery() {
        return criteriaQuery;
    }

    @Override
    public Root<T> getRoot() {
        return root;
    }

    @Override
    public EntityManager getEntityManager() {
        return entityManager;
    }
}
```

---

#### **3. Пример использования**

```java
EntityManager em = ...;

// Создаём QueryBuilder
QueryBuilder<PaymentAnalyticEntity> builder = new QueryBuilderImpl<>(em, PaymentAnalyticEntity.class);

// Пример фильтрации по статусу
builder.addPredicate(builder.getCriteriaBuilder().equal(builder.get(PaymentAnalyticEntity_.status), "ACTIVE"));

// Пример сортировки
builder.addOrder(PaymentAnalyticEntity_.date, false);

// Пример динамического EntityGraph
builder.applyEntityGraph(List.of("clientName", "paymentObjects"));

// Выполнение запроса
List<PaymentAnalyticEntity> results = builder.execute();

// Выполнение с пагинацией
List<PaymentAnalyticEntity> paginatedResults = builder.executeWithPagination(0, 10);
```

---

### Итоговые возможности

1. **Типобезопасная работа с запросами через Criteria API.**
2. **Динамическое создание запросов с EntityGraph.**
3. **Построение CASE WHEN, SUM и других выражений.**
4. **Динамическая сортировка и пагинация.**
5. **Возможность добавления новых методов в интерфейс через дефолтные методы.**

Если потребуется добавить дополнительные примеры или улучшения, пишите!


public enum RegistryCodesEnum {
    ID((helper) -> List.of(helper.get(PaymentAnalyticEntity_.id))),
    CLIENT_NAME((helper) -> List.of(helper.get(PaymentAnalyticEntity_.clientName))),
    CLIENT_TYPE((helper) -> List.of(helper.selectCase()
        .when(helper.like(PaymentAnalyticEntity_.clientName, "VIP%"), "VIP")
        .otherwise("Regular"))),
    DATE((helper) -> List.of(helper.get(PaymentAnalyticEntity_.date))),
    TOTAL_AMOUNT((helper) -> {
        JoinHelper<PaymentAnalyticEntity, PaymentObjectEntity> join = helper.join(PaymentAnalyticEntity_.paymentObjects);
        return List.of(join.sum(PaymentObjectEntity_.amount), helper.count(PaymentObjectEntity_.id));
    });

    private final Function<QueryHelper<PaymentAnalyticEntity>, List<Expression<?>>> expressionFunction;

    RegistryCodesEnum(Function<QueryHelper<PaymentAnalyticEntity>, List<Expression<?>>> expressionFunction) {
        this.expressionFunction = expressionFunction;
    }

    public List<Expression<?>> getExpressions(QueryHelper<PaymentAnalyticEntity> helper) {
        return expressionFunction.apply(helper);
    }
}




```java
private Map<RegistryCodes, Expression<?>> buildFieldExpressions(List<RegistryCodes> fields) {
    // Здесь мы для каждого поля через switch выбираем нужное поле Q-класса или nullExpression
    // В данном случае paymentAnalyticEntity — это Q-класс вашей сущности.
    // Предполагается, что paymentAnalyticEntity уже объявлен где-то выше как Q-поле.
    Map<RegistryCodes, Expression<?>> expressions = new HashMap<>();

    for (RegistryCodes code : fields) {
        Expression<?> expr = switch (code) {
            case ID -> paymentAnalyticEntity.id;
            case CLIENT_ID -> paymentAnalyticEntity.clientId;
            case PAYMENT_DOCUMENT_ID -> paymentAnalyticEntity.paymentDocumentId;
            case NUMBER -> paymentAnalyticEntity.number;
            case LOAN_FUNDS_REQUEST_STATUS -> paymentAnalyticEntity.status;
            case DATE -> paymentAnalyticEntity.date;
            case FUNDS_TYPE -> paymentAnalyticEntity.fundsType;
            case CREDIT_AGREEMENT -> paymentAnalyticEntity.creditAgreementNumber; 
            case CREDIT_AGREEMENT_DATE -> paymentAnalyticEntity.creditAgreementDate; 
            case PAYER_ACCOUNT -> paymentAnalyticEntity.payerAccount; 
            case OBC_ACCOUNT_FLAG -> paymentAnalyticEntity.obcAccountFlag;
            case TRANCHE_ISSUE_DATE -> paymentAnalyticEntity.trancheIssueDate; 
            case AMOUNT -> paymentAnalyticEntity.amount;
            case PAYMENT_PURPOSE -> paymentAnalyticEntity.paymentPurpose;
            case RECIPIENT_NAME -> paymentAnalyticEntity.recipientName;
            case RECIPIENT_ACCOUNT -> paymentAnalyticEntity.recipientAccount;
            case DVRU -> paymentAnalyticEntity.dvruNumber; // обратите внимание: DVRU включает dvruNumber и dvruDate
            case DVRU_DATE -> paymentAnalyticEntity.dvruDate;
            case PAYMENT_TYPE -> paymentAnalyticEntity.paymentType;
            case PAYMENT_OBJECT -> null; // обработаем отдельно
            case SSR_ARTICLE -> null; // обработается при сборе вложенных объектов
        };
        expressions.put(code, expr);
    }

    return expressions;
}

public List<PFLoanFundsRqRegistryItemBo> findResults(List<RegistryCodes> fields) {
    Map<RegistryCodes, Expression<?>> expressions = buildFieldExpressions(fields);

    // Если необходимо получить PAYMENT_OBJECT и SSR_ARTICLE в составе результатов,
    // нам потребуется использовать GroupBy для агрегирования связанных сущностей.
    boolean needPaymentObject = fields.contains(RegistryCodes.PAYMENT_OBJECT);

    JPAQuery<?> query = new JPAQuery<>(entityManager);
    query.from(paymentAnalyticEntity);

    // базовые поля (все, кроме PAYMENT_OBJECT и SSR_ARTICLE)
    // соберём параметры для конструктора
    List<Expression<?>> constructorArgs = new ArrayList<>();

    // Порядок аргументов в Projections.constructor должен соответствовать конструктору PFLoanFundsRqRegistryItemBo
    // Конструктор: (UUID id, UUID clientId, UUID paymentDocumentId, Integer number, PaymentAnalyticStatus status, 
    //  LocalDate date, FundsType fundsType, String creditAgreementNumber, LocalDate creditAgreementDate, String payerAccount,
    //  Boolean obcAccountFlag, LocalDate trancheIssueDate, BigDecimal amount, String paymentPurpose, 
    //  String recipientName, String recipientAccount, String dvruNumber, LocalDate dvruDate, PaymentType paymentType, 
    //  List<PaymentObjectEntityBo> paymentObjects)
    // Для отсутствующих полей будем подставлять nullExpression соответствующего класса.
    constructorArgs.add(fields.contains(RegistryCodes.ID) ? (Expression<?>)expressions.get(RegistryCodes.ID) : Expressions.nullExpression(UUID.class));
    constructorArgs.add(fields.contains(RegistryCodes.CLIENT_ID) ? (Expression<?>)expressions.get(RegistryCodes.CLIENT_ID) : Expressions.nullExpression(UUID.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYMENT_DOCUMENT_ID) ? (Expression<?>)expressions.get(RegistryCodes.PAYMENT_DOCUMENT_ID) : Expressions.nullExpression(UUID.class));
    constructorArgs.add(fields.contains(RegistryCodes.NUMBER) ? (Expression<?>)expressions.get(RegistryCodes.NUMBER) : Expressions.nullExpression(Integer.class));
    constructorArgs.add(fields.contains(RegistryCodes.LOAN_FUNDS_REQUEST_STATUS) ? (Expression<?>)expressions.get(RegistryCodes.LOAN_FUNDS_REQUEST_STATUS) : Expressions.nullExpression(PaymentAnalyticStatus.class));
    constructorArgs.add(fields.contains(RegistryCodes.DATE) ? (Expression<?>)expressions.get(RegistryCodes.DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.FUNDS_TYPE) ? (Expression<?>)expressions.get(RegistryCodes.FUNDS_TYPE) : Expressions.nullExpression(FundsType.class));
    constructorArgs.add(fields.contains(RegistryCodes.CREDIT_AGREEMENT) ? (Expression<?>)expressions.get(RegistryCodes.CREDIT_AGREEMENT) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.CREDIT_AGREEMENT_DATE) ? (Expression<?>)expressions.get(RegistryCodes.CREDIT_AGREEMENT_DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYER_ACCOUNT) ? (Expression<?>)expressions.get(RegistryCodes.PAYER_ACCOUNT) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.OBC_ACCOUNT_FLAG) ? (Expression<?>)expressions.get(RegistryCodes.OBC_ACCOUNT_FLAG) : Expressions.nullExpression(Boolean.class));
    constructorArgs.add(fields.contains(RegistryCodes.TRANCHE_ISSUE_DATE) ? (Expression<?>)expressions.get(RegistryCodes.TRANCHE_ISSUE_DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.AMOUNT) ? (Expression<?>)expressions.get(RegistryCodes.AMOUNT) : Expressions.nullExpression(BigDecimal.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYMENT_PURPOSE) ? (Expression<?>)expressions.get(RegistryCodes.PAYMENT_PURPOSE) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.RECIPIENT_NAME) ? (Expression<?>)expressions.get(RegistryCodes.RECIPIENT_NAME) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.RECIPIENT_ACCOUNT) ? (Expression<?>)expressions.get(RegistryCodes.RECIPIENT_ACCOUNT) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.DVRU) ? (Expression<?>)expressions.get(RegistryCodes.DVRU) : Expressions.nullExpression(String.class));
    constructorArgs.add(fields.contains(RegistryCodes.DVRU_DATE) ? (Expression<?>)expressions.get(RegistryCodes.DVRU_DATE) : Expressions.nullExpression(LocalDate.class));
    constructorArgs.add(fields.contains(RegistryCodes.PAYMENT_TYPE) ? (Expression<?>)expressions.get(RegistryCodes.PAYMENT_TYPE) : Expressions.nullExpression(PaymentType.class));

    if (needPaymentObject) {
        // Если нужно поле PAYMENT_OBJECT — используем GroupBy для сборки коллекций
        // Предполагается, что QPaymentObjectEntity paymentObject и QPaymentSsrArticleEntity paymentSsrArticle 
        // являются Q-классами для связанных сущностей.
        
        // Делаем left join для получения paymentObjects
        QPaymentObjectEntity paymentObject = QPaymentObjectEntity.paymentObjectEntity;
        QPaymentSsrArticleEntity paymentSsrArticle = QPaymentSsrArticleEntity.paymentSsrArticleEntity;

        query.leftJoin(paymentAnalyticEntity.paymentObjects, paymentObject);
        query.leftJoin(paymentObject.paymentObjectSsr.paymentSsrArticles, paymentSsrArticle);

        // Сформируем конструктор для вложенных объектов
        Expression<List<PFLoanFundsRqRegistryItemBo.PaymentObjectEntityBo>> paymentObjectsExpression = list(
            Projections.constructor(
                PFLoanFundsRqRegistryItemBo.PaymentObjectEntityBo.class,
                fields.contains(RegistryCodes.PAYMENT_OBJECT) ? paymentObject.name : Expressions.nullExpression(String.class),
                fields.contains(RegistryCodes.PAYMENT_OBJECT) ? paymentObject.projectName : Expressions.nullExpression(String.class),
                Projections.constructor(
                    PFLoanFundsRqRegistryItemBo.PaymentObjectSsrEntityBo.class,
                    list(
                        Projections.constructor(
                            PFLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo.class,
                            fields.contains(RegistryCodes.SSR_ARTICLE) ? paymentSsrArticle.code : Expressions.nullExpression(String.class)
                        )
                    )
                )
            )
        );

        constructorArgs.add(paymentObjectsExpression);

        Map<UUID, PFLoanFundsRqRegistryItemBo> map = query
            .select(paymentAnalyticEntity.id,
                    paymentAnalyticEntity.clientId,
                    paymentAnalyticEntity.paymentDocumentId,
                    paymentAnalyticEntity.number,
                    paymentAnalyticEntity.status,
                    paymentAnalyticEntity.date,
                    paymentAnalyticEntity.fundsType,
                    paymentAnalyticEntity.creditAgreementNumber,
                    paymentAnalyticEntity.creditAgreementDate,
                    paymentAnalyticEntity.payerAccount,
                    paymentAnalyticEntity.obcAccountFlag,
                    paymentAnalyticEntity.trancheIssueDate,
                    paymentAnalyticEntity.amount,
                    paymentAnalyticEntity.paymentPurpose,
                    paymentAnalyticEntity.recipientName,
                    paymentAnalyticEntity.recipientAccount,
                    paymentAnalyticEntity.dvruNumber,
                    paymentAnalyticEntity.dvruDate,
                    paymentAnalyticEntity.paymentType,
                    paymentObject.name,
                    paymentObject.projectName,
                    paymentSsrArticle.code)
            .transform(
                groupBy(paymentAnalyticEntity.id).as(
                    Projections.constructor(
                        PFLoanFundsRqRegistryItemBo.class,
                        constructorArgs.toArray(new Expression[0])
                    )
                )
            );
        return new ArrayList<>(map.values());

    } else {
        // Если PAYMENT_OBJECT не требуется, просто делаем обычную проекцию без groupBy
        // Подставляем null для paymentObjects так как оно не нужно
        constructorArgs.add(Expressions.nullExpression(List.class));

        return query
            .select(Projections.constructor(
                PFLoanFundsRqRegistryItemBo.class,
                constructorArgs.toArray(new Expression[0])
            ))
            .fetch();
    }
}
```

**Объяснения:**  
- В методе `buildFieldExpressions` мы используем `switch` с лямбдами (Java 14+) для выбора соответствующих полей Q-класса или `null`.
- В основном методе `findResults` мы сначала проверяем, нужно ли поле `PAYMENT_OBJECT`. Если оно требуется, то используем `GroupBy` для агрегирования результатов и получения списков. Если нет, делаем простой запрос с конструкторной проекцией.
- Для формирования конструктора DTO используется `List<Expression<?>> constructorArgs`, куда мы добавляем необходимые выражения в нужном порядке.
- При отсутствии определённого поля вставляем `Expressions.nullExpression(Тип.class)`.
- Таким образом устраняется необходимость в тернарном операторе (используется switch + предварительная проверка `fields.contains(...)`), а также динамически включаются или исключаются нужные поля.
  
Официальную документацию по Querydsl GroupBy можно найти по ссылке:  
[Querydsl GroupBy документация](https://querydsl.github.io/)





import static com.querydsl.core.group.GroupBy.*;

Map<UUID, PFLoanFundsRqRegistryItemBo> results = query
    .select(paymentAnalyticEntity.id,
            paymentAnalyticEntity.clientId,
            paymentAnalyticEntity.paymentDocumentId,
            paymentAnalyticEntity.number,
            paymentAnalyticEntity.status,
            paymentAnalyticEntity.date,
            paymentAnalyticEntity.fundsType,
            paymentAnalyticEntity.creditAgreementNumber,
            paymentAnalyticEntity.creditAgreementDate,
            paymentAnalyticEntity.payerAccount,
            paymentAnalyticEntity.obcAccountFlag,
            paymentAnalyticEntity.trancheIssueDate,
            paymentAnalyticEntity.amount,
            paymentAnalyticEntity.paymentPurpose,
            paymentAnalyticEntity.recipientName,
            paymentAnalyticEntity.recipientAccount,
            paymentAnalyticEntity.dvruNumber,
            paymentAnalyticEntity.dvruDate,
            paymentAnalyticEntity.paymentType,
            paymentObject.name,
            paymentObject.projectName,
            paymentSsrArticle.code)
    .from(paymentAnalyticEntity)
    .leftJoin(paymentAnalyticEntity.paymentObjects, paymentObject)
    .leftJoin(paymentObject.paymentObjectSsr.paymentSsrArticles, paymentSsrArticle)
    // Группировка по ID главной сущности
    .transform(
        groupBy(paymentAnalyticEntity.id).as(
            Projections.constructor(
                PFLoanFundsRqRegistryItemBo.class,
                paymentAnalyticEntity.id,
                paymentAnalyticEntity.clientId,
                paymentAnalyticEntity.paymentDocumentId,
                paymentAnalyticEntity.number,
                paymentAnalyticEntity.status,
                paymentAnalyticEntity.date,
                paymentAnalyticEntity.fundsType,
                paymentAnalyticEntity.creditAgreementNumber,
                paymentAnalyticEntity.creditAgreementDate,
                paymentAnalyticEntity.payerAccount,
                paymentAnalyticEntity.obcAccountFlag,
                paymentAnalyticEntity.trancheIssueDate,
                paymentAnalyticEntity.amount,
                paymentAnalyticEntity.paymentPurpose,
                paymentAnalyticEntity.recipientName,
                paymentAnalyticEntity.recipientAccount,
                paymentAnalyticEntity.dvruNumber,
                paymentAnalyticEntity.dvruDate,
                paymentAnalyticEntity.paymentType,
                // Используем GroupBy для сбора объектов
                list(
                    Projections.constructor(
                        PFLoanFundsRqRegistryItemBo.PaymentObjectEntityBo.class,
                        paymentObject.name,
                        paymentObject.projectName,
                        Projections.constructor(
                            PFLoanFundsRqRegistryItemBo.PaymentObjectSsrEntityBo.class,
                            // Для SSR статей тоже собираем список
                            list(
                                Projections.constructor(
                                    PFLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo.class,
                                    paymentSsrArticle.code
                                )
                            )
                        )
                    )
                )
            )
        )
    );






@Repository
public class PaymentAnalyticRepository {

    private final JPAQueryFactory queryFactory;
    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    public PaymentAnalyticRepository(EntityManager entityManager) {
        this.queryFactory = new JPAQueryFactory(entityManager);
    }

    /**
     * Выполняет запрос и группирует результаты по pa.id.
     * Для каждого поля используется list(...), чтобы получить значения в список.
     * Для скалярных полей будет список с одним элементом.
     * Для коллекционных полей - список всех элементов.
     */
    public List<Group> fetchAnalyticsGrouped(
            Expression<?>[] expressions,
            List<OrderSpecifier<?>> orderSpecifiers,
            Pageable pageable,
            Predicate predicate
    ) {
        Integer limit = (pageable != null && pageable.getPageSize() > 0) ? pageable.getPageSize() : null;
        Integer offset = null;
        if (pageable != null && pageable.getOffset() > 0) {
            long off = pageable.getOffset();
            offset = (off <= Integer.MAX_VALUE) ? (int) off : Integer.MAX_VALUE;
        }

        var query = queryFactory.select(expressions).from(pa);

        if (predicate != null) {
            query.where(predicate);
        }

        if (orderSpecifiers != null && !orderSpecifiers.isEmpty()) {
            query.orderBy(orderSpecifiers.toArray(new OrderSpecifier[0]));
        }

        if (limit != null && limit > 0) {
            query.limit(limit);
        }

        if (offset != null && offset >= 0) {
            query.offset(offset);
        }

        // Создание базового GroupByBuilder
        var groupByBuilder = GroupBy.groupBy(pa.id);

        // Список всех агрегаторов
        List<GroupExpression<?, ?>> aggregators = new ArrayList<>();

        // Собираем все агрегаторы
        for (Expression<?> expr : expressions) {
            aggregators.add(createListGroupExpression(expr));
        }

        // Если агрегаторы пусты, добавляем хотя бы id
        if (aggregators.isEmpty()) {
            aggregators.add(createListGroupExpression(pa.id));
        }

        // Завершаем построение GroupByBuilder
        var resultTransformer = groupByBuilder.as(aggregators.toArray(new GroupExpression[0]));

        // Выполняем запрос и трансформацию
        Map<UUID, Group> resultMap = query.transform(resultTransformer);
        return new ArrayList<>(resultMap.values());
    }

    /**
     * Создаёт безопасное выражение для группировки данных в список.
     * @param expr выражение, которое требуется сгруппировать
     * @return GroupExpression для списка
     */
    private <T> GroupExpression<T, List<T>> createListGroupExpression(Expression<T> expr) {
        return GroupBy.list(expr);
    }
}


@Service
public class PaymentAnalyticMapper {

    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    public List<PfLoanFundsRqRegistryItemBo> mapGroupsToDto(Set<RegistryCodes> fields, List<Group> groups, boolean needGrouping) {
        List<PfLoanFundsRqRegistryItemBo> dtos = new ArrayList<>();

        for (Group group : groups) {
            PfLoanFundsRqRegistryItemBo dto = new PfLoanFundsRqRegistryItemBo();

            // Пример для обязательных полей:
            dto.setId(getSingleValue(group, pa.id, Long.class));
            dto.setClientId(getSingleValue(group, pa.clientId, Long.class));
            dto.setPaymentDocumentId(getSingleValue(group, pa.paymentDocumentId, Long.class));

            // Аналогично для других скалярных полей:
            if (fields.contains(RegistryCodes.NUMBER)) {
                dto.setNumber(getSingleValue(group, pa.number, Integer.class));
            }
            if (fields.contains(RegistryCodes.DATE)) {
                dto.setDate(getSingleValue(group, pa.date, java.time.LocalDate.class));
            }
            if (fields.contains(RegistryCodes.FUNDS_TYPE)) {
                dto.setFundsType(getSingleValue(group, pa.fundsType, FundsType.class));
            }
            // И так далее для каждого скалярного поля...

            // Для DVRU (два поля) извлекаем отдельно:
            if (fields.contains(RegistryCodes.DVRU)) {
                dto.setDvruNumber(getSingleValue(group, pa.dvruNumber, String.class));
                dto.setDvruDate(getSingleValue(group, pa.dvruDate, java.time.LocalDate.class));
            }

            // Для PAYMENT_OBJECT (коллекция):
            List<String> paymentObjectNames = null;
            List<String> paymentObjectProjectNames = null;
            if (fields.contains(RegistryCodes.PAYMENT_OBJECT)) {
                paymentObjectNames = group.getList(pa.paymentObjects.any().name);
                paymentObjectProjectNames = group.getList(pa.paymentObjects.any().projectName);
            }

            // Для SSR_ARTICLE (коллекция):
            List<String> ssrArticleCodes = null;
            if (fields.contains(RegistryCodes.SSR_ARTICLE)) {
                ssrArticleCodes = group.getList(pa.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);
            }

            // Собираем paymentObjects
            dto.setPaymentObjects(buildPaymentObjects(paymentObjectNames, paymentObjectProjectNames, ssrArticleCodes));

            dtos.add(dto);
        }

        return dtos;
    }

    /**
     * Для скалярных полей, где ожидается один элемент в списке, извлекаем первый или null.
     */
    private <T> T getSingleValue(Group group, Expression<?> expr, Class<T> type) {
        List<?> values = group.getList(expr);
        if (values == null || values.isEmpty()) {
            return null;
        }
        Object val = values.get(0);
        return type.isInstance(val) ? type.cast(val) : null;
    }

    /**
     * Формируем paymentObjects из списков имён, projectName и кодов статей.
     */
    private List<PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo> buildPaymentObjects(
            List<String> names, List<String> projectNames, List<String> ssrCodes) {
        if (names == null || projectNames == null) {
            return null;
        }
        List<PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo> objects = new ArrayList<>();
        int size = Math.min(names.size(), projectNames.size());

        for (int i = 0; i < size; i++) {
            PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo obj = new PfLoanFundsRqRegistryItemBo.PaymentObjectEntityBo(
                names.get(i),
                projectNames.get(i),
                buildPaymentObjectSsr(ssrCodes)
            );
            objects.add(obj);
        }
        return objects.isEmpty() ? null : objects;
    }

    private PfLoanFundsRqRegistryItemBo.PaymentObjectsSsrEntityBo buildPaymentObjectSsr(List<String> ssrCodes) {
        PfLoanFundsRqRegistryItemBo.PaymentObjectsSsrEntityBo ssrDto = new PfLoanFundsRqRegistryItemBo.PaymentObjectsSsrEntityBo(
            buildSsrArticles(ssrCodes)
        );
        return ssrDto;
    }

    private List<PfLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo> buildSsrArticles(List<String> codes) {
        if (codes == null) return null;
        List<PfLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo> articles = new ArrayList<>();
        for (String c : codes) {
            articles.add(new PfLoanFundsRqRegistryItemBo.PaymentSsrArticleEntityBo(c));
        }
        return articles.isEmpty() ? null : articles;
    }
}





package com.example.repository;

import com.querydsl.jpa.impl.JPAQueryFactory;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.group.Group;
import com.querydsl.core.group.GroupBy;
import com.example.entity.QPaymentAnalyticEntity;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Repository
public class PaymentAnalyticRepository {

    private final JPAQueryFactory queryFactory;
    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    public PaymentAnalyticRepository(javax.persistence.EntityManager entityManager) {
        this.queryFactory = new JPAQueryFactory(entityManager);
    }

    /**
     * Выполняет запрос с динамическими полями (Expression<?>), сортировкой (OrderSpecifier<?>),
     * фильтрацией (Predicate), пагинацией (Pageable) и группировкой.
     * Предполагается, что в expressions присутствуют pa.id, pa.clientId, pa.paymentDocumentId.
     * Возвращает List<Group>.
     */
    public List<Group> fetchAnalyticsGrouped(
            Expression<?>[] expressions,
            List<OrderSpecifier<?>> orderSpecifiers,
            Pageable pageable,
            Predicate predicate,
            boolean needGrouping
    ) {
        Integer limit = (pageable != null && pageable.getPageSize() > 0) ? pageable.getPageSize() : null;
        Integer offset = null;
        if (pageable != null && pageable.getOffset() > 0) {
            long off = pageable.getOffset();
            offset = (off <= Integer.MAX_VALUE) ? (int) off : Integer.MAX_VALUE;
        }

        var query = queryFactory.select(expressions).from(pa);

        if (predicate != null) {
            query.where(predicate);
        }

        if (orderSpecifiers != null && !orderSpecifiers.isEmpty()) {
            query.orderBy(orderSpecifiers.toArray(new OrderSpecifier[0]));
        }

        if (limit != null && limit > 0) {
            query.limit(limit);
        }

        if (offset != null && offset >= 0) {
            query.offset(offset);
        }

        var groupByBuilder = GroupBy.groupBy(pa.id);

        boolean firstAggregator = true;
        for (Expression<?> expr : expressions) {
            if (expr.equals(pa.id)) {
                var aggregator = GroupBy.first(expr).as(expr.toString());
                if (firstAggregator) {
                    groupByBuilder = groupByBuilder.as(aggregator);
                    firstAggregator = false;
                } else {
                    groupByBuilder = groupByBuilder.and(aggregator);
                }
                continue;
            }

            if (expr.equals(pa.clientId) || expr.equals(pa.paymentDocumentId)) {
                var aggregator = GroupBy.first(expr).as(expr.toString());
                if (firstAggregator) {
                    groupByBuilder = groupByBuilder.as(aggregator);
                    firstAggregator = false;
                } else {
                    groupByBuilder = groupByBuilder.and(aggregator);
                }
                continue;
            }

            // Если needGrouping=true, считаем, что это может быть коллекционное поле -> list
            // Иначе first.
            var aggregator = needGrouping ? GroupBy.list(expr) : GroupBy.first(expr);
            aggregator = aggregator.as(expr.toString());
            if (firstAggregator) {
                groupByBuilder = groupByBuilder.as(aggregator);
                firstAggregator = false;
            } else {
                groupByBuilder = groupByBuilder.and(aggregator);
            }
        }

        if (firstAggregator) {
            groupByBuilder = groupByBuilder.as(GroupBy.first(pa.id).as("id"));
        }

        Map<Long, Group> resultMap = query.transform(groupByBuilder);
        return new ArrayList<>(resultMap.values());
    }
}




Ниже представлен улучшенный вариант сервисного слоя, учитывающий принципы SOLID, улучшенную тестируемость и гибкость. Изменения:

1. **Отделение логики сортировки**:  
   Вместо того, чтобы держать логику сортировки в сервисе, она инкапсулирована в отдельном сервисе/компоненте `SortingService`, который использует `SortOrderBuilder`. Это упростит тестирование: можно отдельно тестировать логику формирования сортировки, подавая разные входные данные и проверяя выходные `OrderSpecifier<?>`.

2. **Отделение логики маппинга**:  
   Создан отдельный маппер `PaymentAnalyticMapper` для преобразования `List<Group>` в `List<PaymentAnalyticDto>` и сборки коллекций в объекты DTO. Это соответствует принципу единственной ответственности (SRP). Теперь `PaymentAnalyticService` не знает деталей о том, как именно маппить поля или коллекции, его задача — orchestrate процесс: получить данные от репозитория, запросить у `SortingService` сортировку, передать их мапперу для преобразования. Это упрощает тестирование, потому что можно отдельно тестировать маппер и отдельно тестировать сервис.

3. **S.O.L.I.D.**:  
   - **S (Single Responsibility)**: Сервис отвечает за общий поток: получить параметры, вызвать репозиторий, отсортировать, замаппить. Логику сортировки и маппинга вынесли в отдельные классы.  
   - **O (Open-Closed)**: Добавить новый вид сортировки или изменить маппинг можно, не меняя код сервисного слоя.  
   - **L (Liskov Substitution)**: Не нарушается, так как мы не меняем иерархии.  
   - **I (Interface Segregation)**: Можно при необходимости выделить интерфейсы для `SortingService`, `PaymentAnalyticMapper`.  
   - **D (Dependency Inversion)**: Сервис зависит от абстракций (например, интерфейсов маппера и сортировщика, если их выделить), а не от конкретных реализаций.

4. **Тестируемость**:  
   - Можно замокать `SortingService` и `PaymentAnalyticMapper` и тестировать `PaymentAnalyticService` изолированно.  
   - Можно отдельно протестировать `PaymentAnalyticMapper` и `SortingService`.

### Код примера

#### PaymentAnalyticMapper.java
```java
package com.example.mapper;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.PaymentAnalyticDto;
import com.example.dto.PaymentAnalyticDto.PaymentObjectEntityDto;
import com.example.dto.PaymentAnalyticDto.PaymentObjectSsrEntityDto;
import com.example.dto.PaymentAnalyticDto.PaymentSsrArticleDto;
import com.example.entity.PaymentAnalyticStatus;
import com.example.entity.PaymentType;
import com.example.entity.FundsType;
import com.example.entity.QPaymentAnalyticEntity;
import com.querydsl.core.group.Group;
import com.querydsl.core.types.Expression;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class PaymentAnalyticMapper {

    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    /**
     * Маппит результаты выборки (List<Group>) в List<PaymentAnalyticDto>.
     * @param fields выбранные поля (содержит ID, CLIENT_ID, PAYMENT_DOCUMENT_ID)
     * @param groups результат запроса
     * @param needGrouping true, если нужны коллекции
     */
    public List<PaymentAnalyticDto> mapGroupsToDto(Set<RegistryCodes> fields, List<Group> groups, boolean needGrouping) {
        List<PaymentAnalyticDto> dtos = new ArrayList<>();

        for (Group g : groups) {
            PaymentAnalyticDto dto = new PaymentAnalyticDto();
            dto.setId((Long) g.get(pa.id));
            dto.setClientId((Long) g.get(pa.clientId));
            dto.setPaymentDocumentId((Long) g.get(pa.paymentDocumentId));

            List<String> paymentObjectNames = null;
            List<String> paymentObjectProjectNames = null;
            List<String> ssrArticleCodes = null;

            // Проходим по полям и маппим скалярные значения
            for (RegistryCodes code : fields) {
                CodeDefinition cd = RegistryCodeDefinitions.getCodeDefinition(code);
                if (cd == null) continue;

                for (Expression<?> expr : cd.getProjections()) {
                    Object value = g.get(expr);
                    if (value == null) continue;

                    switch (code) {
                        case NUMBER -> dto.setNumber((Integer) value);
                        case DATE -> dto.setDate((LocalDate) value);
                        case LOAN_FUNDS_REQUEST_STATUS -> dto.setStatus((PaymentAnalyticStatus) value);
                        case FUNDS_TYPE -> dto.setFundsType((FundsType) value);
                        case CREDIT_AGREEMENT -> {
                            if (expr.equals(pa.creditAgreementNumber)) {
                                dto.setCreditAgreementNumber((String) value);
                            } else if (expr.equals(pa.creditAgreementDate)) {
                                dto.setCreditAgreementDate((LocalDate) value);
                            }
                        }
                        case PAYER_ACCOUNT -> {
                            if (expr.equals(pa.payerAccount)) {
                                dto.setPayerAccount((String) value);
                            } else if (expr.equals(pa.obcAccountFlag)) {
                                dto.setObcAccountFlag((Boolean) value);
                            }
                        }
                        case TRANCHE_ISSUE_DATE -> dto.setTrancheIssueDate((LocalDate) value);
                        case AMOUNT -> dto.setAmount((BigDecimal) value);
                        case PAYMENT_PURPOSE -> dto.setPaymentPurpose((String) value);
                        case RECIPIENT_NAME -> dto.setRecipientName((String) value);
                        case RECIPIENT_ACCOUNT -> dto.setRecipientAccount((String) value);
                        case DVRU -> {
                            if (expr.equals(pa.dvruNumber)) {
                                dto.setDvruNumber((String) value);
                            } else if (expr.equals(pa.dvruDate)) {
                                dto.setDvruDate((LocalDate) value);
                            }
                        }
                        case PAYMENT_TYPE -> dto.setPaymentType((PaymentType) value);
                        case PAYMENT_OBJECT -> {
                            // Коллекции имён и projectName
                            if (expr.toString().contains("projectName")) {
                                paymentObjectProjectNames = (List<String>) value;
                            } else if (expr.toString().contains("name")) {
                                paymentObjectNames = (List<String>) value;
                            }
                        }
                        case SSR_ARTICLE -> {
                            ssrArticleCodes = (List<String>) value;
                        }
                        default -> {
                            // Остальные игнорируем
                        }
                    }
                }
            }

            // Сборка paymentObjects из списков
            dto.setPaymentObjects(buildPaymentObjects(paymentObjectNames, paymentObjectProjectNames, ssrArticleCodes));

            dtos.add(dto);
        }

        return dtos;
    }

    /**
     * Строим список PaymentObjectEntityDto из списков строк.
     */
    private List<PaymentObjectEntityDto> buildPaymentObjects(List<String> names, List<String> projectNames, List<String> ssrCodes) {
        if (names == null || projectNames == null) {
            return null;
        }

        List<PaymentObjectEntityDto> objects = new ArrayList<>();
        int size = Math.min(names.size(), projectNames.size());
        for (int i = 0; i < size; i++) {
            PaymentObjectEntityDto obj = new PaymentObjectEntityDto();
            obj.setName(names.get(i));
            obj.setProjectName(projectNames.get(i));

            PaymentObjectSsrEntityDto ssr = new PaymentObjectSsrEntityDto();
            ssr.setPaymentSsrArticles(buildSsrArticles(ssrCodes));
            obj.setPaymentObjectSsr(ssr);

            objects.add(obj);
        }

        return objects.isEmpty() ? null : objects;
    }

    /**
     * Строим список PaymentSsrArticleDto из списка кодов.
     */
    private List<PaymentSsrArticleDto> buildSsrArticles(List<String> codes) {
        if (codes == null) return null;
        List<PaymentSsrArticleDto> articles = new ArrayList<>();
        for (String c : codes) {
            PaymentSsrArticleDto a = new PaymentSsrArticleDto();
            a.setCode(c);
            articles.add(a);
        }
        return articles.isEmpty() ? null : articles;
    }
}
```

#### SortingService.java
```java
package com.example.service;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.SortingDto;
import com.example.util.SortOrderBuilder;
import com.querydsl.core.types.OrderSpecifier;

import java.util.List;

public class SortingService {

    /**
     * Возвращает список OrderSpecifier для сортировки на основании SortingDto.
     */
    public List<OrderSpecifier<?>> getOrderSpecifiers(SortingDto sortingDto) {
        String sortField = sortingDto != null ? sortingDto.getSortField() : null;
        Boolean sortDescending = sortingDto != null ? sortingDto.getSortDescending() : Boolean.TRUE;

        return SortOrderBuilder.buildOrderSpecifiers(sortField, sortDescending);
    }
}
```

#### PaymentAnalyticService.java
```java
package com.example.service;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.PaymentAnalyticDto;
import com.example.dto.SortingDto;
import com.example.entity.QPaymentAnalyticEntity;
import com.example.mapper.PaymentAnalyticMapper;
import com.example.repository.PaymentAnalyticRepository;
import com.querydsl.core.group.Group;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.OrderSpecifier;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class PaymentAnalyticService {

    private final PaymentAnalyticRepository repository;
    private final SortingService sortingService;
    private final PaymentAnalyticMapper mapper;

    public PaymentAnalyticService(PaymentAnalyticRepository repository, SortingService sortingService, PaymentAnalyticMapper mapper) {
        this.repository = repository;
        this.sortingService = sortingService;
        this.mapper = mapper;
    }

    public List<PaymentAnalyticDto> getPaymentAnalytics(
            List<RegistryCodes> fields,
            SortingDto sortingDto,
            Pageable pageable,
            Predicate predicate
    ) {
        boolean needGrouping = fields.contains(RegistryCodes.PAYMENT_OBJECT)
                            || fields.contains(RegistryCodes.SSR_ARTICLE);

        // Всегда добавляем обязательные поля
        Set<RegistryCodes> extendedFields = new LinkedHashSet<>(fields);
        extendedFields.add(RegistryCodes.ID);
        extendedFields.add(RegistryCodes.CLIENT_ID);
        extendedFields.add(RegistryCodes.PAYMENT_DOCUMENT_ID);

        // Формируем projections
        List<Expression<?>> exprs = new ArrayList<>();
        for (RegistryCodes code : extendedFields) {
            CodeDefinition cd = RegistryCodeDefinitions.getCodeDefinition(code);
            if (cd != null && !cd.getProjections().isEmpty()) {
                exprs.addAll(cd.getProjections());
            }
        }

        // Получаем сортировку от SortingService
        List<OrderSpecifier<?>> orderSpecifiers = sortingService.getOrderSpecifiers(sortingDto);

        Expression<?>[] expressionsArray = exprs.toArray(new Expression[0]);
        List<Group> groups = repository.fetchAnalyticsGrouped(
                expressionsArray,
                orderSpecifiers,
                pageable,
                predicate,
                needGrouping
        );

        // Маппим результаты в DTO
        return mapper.mapGroupsToDto(extendedFields, groups, needGrouping);
    }
}
```

---

**Комментарии:**

- **PaymentAnalyticService**:  
  - Зависит от `PaymentAnalyticRepository` (получение данных),  
  - `SortingService` (получение списков сортировок),  
  - `PaymentAnalyticMapper` (маппинг результатов).
  
  Так мы можем легко замокать эти зависимости в тестах и протестировать логику `PaymentAnalyticService` изолированно.

- **SortingService**:  
  Использует `SortOrderBuilder` для получения `OrderSpecifier`. Можно добавить интерфейс для `SortingService`, чтобы при необходимости использовать разные реализации.

- **PaymentAnalyticMapper**:  
  Инкапсулирует всю логику маппинга `Group` в `PaymentAnalyticDto`. Можно тестировать отдельно: подать на вход тестовые `Group` и проверить корректность сформированных DTO.

Таким образом, код стал более модульным, соответствующим принципам SOLID, упрощенным для тестирования и расширяемости.




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
import com.querydsl.core.types.Order;
import com.querydsl.core.types.OrderSpecifier;

import java.util.ArrayList;
import java.util.List;

public class SortOrderBuilder {
    
    // Поле по умолчанию для сортировки
    private static final OrderSpecifier<?> DEFAULT_ORDER = QPaymentAnalyticEntity.paymentAnalyticEntity.date.desc();
    
    /**
     * Формируем список сортировок на основании входного сортировочного запроса.
     * @param sortField        Строковое значение поля сортировки, соответствует одному из RegistryCodes (или null)
     * @param sortDescending   Если true - сортируем по убыванию, иначе по возрастанию.
     * @return список OrderSpecifier для применения в запросе QueryDSL
     */
    public static List<OrderSpecifier<?>> buildOrderSpecifiers(String sortField, Boolean sortDescending) {
        List<OrderSpecifier<?>> orderSpecifiers = new ArrayList<>();

        RegistryCodes code = null;
        if (sortField != null && !sortField.isBlank()) {
            try {
                code = RegistryCodes.valueOf(sortField.toUpperCase());
            } catch (IllegalArgumentException e) {
                // Если не удалось сопоставить sortField с RegistryCodes, code остаётся null
            }
        }
        
        // Если код не найден или не задан, применяем сортировку по умолчанию
        if (code == null) {
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        CodeDefinition definition = RegistryCodeDefinitions.getCodeDefinition(code);
        if (definition == null) {
            // Если для данного code нет определения - сортируем по умолчанию
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        // Берём orderSpecifiers из определения
        List<OrderSpecifier<?>> baseOrderSpecifiers = definition.getOrderSpecifiers();
        if (baseOrderSpecifiers.isEmpty()) {
            // Если нет явно заданных сортировок в CodeDefinition, сортируем по умолчанию
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        // Инвертируем направление при необходимости
        if (Boolean.TRUE.equals(sortDescending)) {
            // Если нужно сортировать по убыванию, то для каждого поля применяем descending
            for (OrderSpecifier<?> os : baseOrderSpecifiers) {
                orderSpecifiers.add(os.getTarget().desc());
            }
        } else {
            // Если нужно сортировать по возрастанию - используем baseOrderSpecifiers как есть, предполагая что они уже asc.
            // Если в базе CodeDefinition хранились Asc, то просто добавляем их.
            // Если нужно более гибко, можно хранить исходные поля без OrderSpecifier и здесь формировать нужный Order.
            for (OrderSpecifier<?> os : baseOrderSpecifiers) {
                orderSpecifiers.add(os.getTarget().asc());
            }
        }

        return orderSpecifiers;
    }
}






package com.example.config;

import com.querydsl.core.group.GroupBy;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.dsl.ComparableExpressionBase;
import com.querydsl.core.types.dsl.DatePath;
import com.querydsl.core.types.dsl.NumberExpression;
import com.querydsl.core.types.dsl.StringExpression;
import com.example.entity.QPaymentAnalyticEntity;
import com.example.entity.QPaymentObjectEntityBo;
import com.example.entity.QPaymentObjectsSsrEntityBo;
import com.example.entity.QPaymentSsrArticleEntityBo;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.querydsl.core.group.GroupBy.list;

public class RegistryCodeDefinitions {

    private static final QPaymentAnalyticEntity paymentAnalyticEntity = QPaymentAnalyticEntity.paymentAnalyticEntity;
    private static final QPaymentObjectEntityBo paymentObjectEntityBo = QPaymentObjectEntityBo.paymentObjectEntityBo;
    private static final QPaymentObjectsSsrEntityBo paymentObjectsSsrEntityBo = QPaymentObjectsSsrEntityBo.paymentObjectsSsrEntityBo;
    private static final QPaymentSsrArticleEntityBo paymentSsrArticleEntityBo = QPaymentSsrArticleEntityBo.paymentSsrArticleEntityBo;

    private static final Map<RegistryCodes, CodeDefinition> CODE_DEFINITIONS = new HashMap<>();

    static {
        // Обязательные поля
        CODE_DEFINITIONS.put(
            RegistryCodes.ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.id),
                List.of(paymentAnalyticEntity.id.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.CLIENT_ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.clientId),
                List.of(paymentAnalyticEntity.clientId.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_DOCUMENT_ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentDocumentId),
                List.of(paymentAnalyticEntity.paymentDocumentId.asc())
            )
        );

        // Примитивные поля
        CODE_DEFINITIONS.put(
            RegistryCodes.NUMBER,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.number),
                List.of(paymentAnalyticEntity.number.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.date),
                List.of(paymentAnalyticEntity.date.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.LOAN_FUNDS_REQUEST_STATUS,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.status),
                List.of(paymentAnalyticEntity.status.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.FUNDS_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.fundsType),
                List.of(paymentAnalyticEntity.fundsType.asc())
            )
        );

        // CREDIT_AGREEMENT: два поля (номер, дата)
        CODE_DEFINITIONS.put(
            RegistryCodes.CREDIT_AGREEMENT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.creditAgreementNumber, paymentAnalyticEntity.creditAgreementDate),
                List.of(paymentAnalyticEntity.creditAgreementNumber.asc(), paymentAnalyticEntity.creditAgreementDate.asc())
            )
        );

        // PAYER_ACCOUNT: два поля (payerAccount, obcAccountFlag)
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYER_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.payerAccount, paymentAnalyticEntity.obcAccountFlag),
                List.of(paymentAnalyticEntity.payerAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.TRANCHE_ISSUE_DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.trancheIssueDate),
                List.of(paymentAnalyticEntity.trancheIssueDate.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.AMOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.amount),
                List.of(paymentAnalyticEntity.amount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_PURPOSE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentPurpose),
                List.of(paymentAnalyticEntity.paymentPurpose.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_NAME,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientName),
                List.of(paymentAnalyticEntity.recipientName.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientAccount),
                List.of(paymentAnalyticEntity.recipientAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentType),
                List.of(paymentAnalyticEntity.paymentType.asc())
            )
        );

        // DVRU: два поля (dvruNumber, dvruDate)
        CODE_DEFINITIONS.put(
            RegistryCodes.DVRU,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.dvruNumber, paymentAnalyticEntity.dvruDate),
                List.of(paymentAnalyticEntity.dvruNumber.asc(), paymentAnalyticEntity.dvruDate.asc())
            )
        );

        // PAYMENT_OBJECT: Коллекция paymentObjects (name, projectName).
        // Возвращаем List<String> для имен и List<String> для projectName
        Expression<List<String>> paymentObjectNames = list(paymentAnalyticEntity.paymentObjects.any().name);
        Expression<List<String>> paymentObjectProjectNames = list(paymentAnalyticEntity.paymentObjects.any().projectName);

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_OBJECT,
            new CodeDefinition(
                List.of(paymentObjectNames, paymentObjectProjectNames),
                Collections.emptyList()
            )
        );

        // SSR_ARTICLE: Коллекция кодов статей
        Expression<List<String>> ssrArticleCodes = list(paymentAnalyticEntity.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);

        CODE_DEFINITIONS.put(
            RegistryCodes.SSR_ARTICLE,
            new CodeDefinition(
                List.of(ssrArticleCodes),
                Collections.emptyList()
            )
        );
    }

    public static CodeDefinition getCodeDefinition(RegistryCodes code) {
        return CODE_DEFINITIONS.get(code);
    }
}





import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;

import java.util.List;

/**
 * CodeDefinition будет хранить Expressions для проекций и OrderSpecifiers для сортировки.
 * В дальнейшем мы будем наполнять эти структуры конкретными значениями для каждого RegistryCodes.
 */
public class CodeDefinition {
    private final List<Expression<?>> projections;
    private final List<OrderSpecifier<?>> orderSpecifiers;

}

    public CodeDefinition(List<Expression<?>> projections, List<OrderSpecifier<?>> orderSpecifiers) {
        this.projections = projections;
        this.orderSpecifiers = orderSpecifiers;
    }

    public List<Expression<?>> getProjections() {
        return projections;
    }

    public List<OrderSpecifier<?>> getOrderSpecifiers() {
        return orderSpecifiers;
    }
import com.querydsl.core.group.GroupBy;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.dsl.ComparableExpressionBase;
import com.querydsl.core.types.dsl.DatePath;
import com.querydsl.core.types.dsl.NumberExpression;
import com.querydsl.core.types.dsl.StringExpression;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.querydsl.core.group.GroupBy.list;

public class RegistryCodeDefinitions {

    private static final QPaymentAnalyticEntity paymentAnalyticEntity = QPaymentAnalyticEntity.paymentAnalyticEntity;
    private static final QPaymentObjectEntityBo paymentObjectEntityBo = QPaymentObjectEntityBo.paymentObjectEntityBo;
    private static final QPaymentObjectsSsrEntityBo paymentObjectsSsrEntityBo = QPaymentObjectsSsrEntityBo.paymentObjectsSsrEntityBo;
    private static final QPaymentSsrArticleEntityBo paymentSsrArticleEntityBo = QPaymentSsrArticleEntityBo.paymentSsrArticleEntityBo;

    private static final Map<RegistryCodes, CodeDefinition> CODE_DEFINITIONS = new HashMap<>();

    static {
        // Пример для простых полей
        CODE_DEFINITIONS.put(
            RegistryCodes.NUMBER,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.number),
                List.of(paymentAnalyticEntity.number.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.date),
                List.of(paymentAnalyticEntity.date.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.LOAN_FUNDS_REQUEST_STATUS,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.status),
                List.of(paymentAnalyticEntity.status.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.FUNDS_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.fundsType),
                List.of(paymentAnalyticEntity.fundsType.asc())
            )
        );

        // CREDIT_AGREEMENT: два поля (номер, дата)
        CODE_DEFINITIONS.put(
            RegistryCodes.CREDIT_AGREEMENT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.creditAgreementNumber, paymentAnalyticEntity.creditAgreementDate),
                List.of(paymentAnalyticEntity.creditAgreementNumber.asc(), paymentAnalyticEntity.creditAgreementDate.asc())
            )
        );

        // PAYER_ACCOUNT: два поля (payerAccount, obcAccountFlag)
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYER_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.payerAccount, paymentAnalyticEntity.obcAccountFlag),
                List.of(paymentAnalyticEntity.payerAccount.asc()) // сортируем по payerAccount
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.TRANCHE_ISSUE_DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.trancheIssueDate),
                List.of(paymentAnalyticEntity.trancheIssueDate.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.AMOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.amount),
                List.of(paymentAnalyticEntity.amount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_PURPOSE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentPurpose),
                List.of(paymentAnalyticEntity.paymentPurpose.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_NAME,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientName),
                List.of(paymentAnalyticEntity.recipientName.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientAccount),
                List.of(paymentAnalyticEntity.recipientAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentType),
                List.of(paymentAnalyticEntity.paymentType.asc())
            )
        );

        // DVRU: два поля (dvruNumber, dvruDate)
        CODE_DEFINITIONS.put(
            RegistryCodes.DVRU,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.dvruNumber, paymentAnalyticEntity.dvruDate),
                List.of(paymentAnalyticEntity.dvruNumber.asc(), paymentAnalyticEntity.dvruDate.asc())
            )
        );

        // PAYMENT_OBJECT: Коллекция paymentObjects с полями name, projectName.
        // Для агрегации используем list(...) из GroupBy.
        Expression<List<String>> paymentObjectNames = list(paymentAnalyticEntity.paymentObjects.any().name);
        Expression<List<String>> paymentObjectProjectNames = list(paymentAnalyticEntity.paymentObjects.any().projectName);

        // Здесь сортировка для коллекций не предусмотрена, оставляем пустой список
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_OBJECT,
            new CodeDefinition(
                List.of(paymentObjectNames, paymentObjectProjectNames),
                Collections.emptyList()
            )
        );

        // SSR_ARTICLE: Коллекция кодов articles через paymentObjectSsr -> paymentSsrArticles
        Expression<List<String>> ssrArticleCodes = list(paymentAnalyticEntity.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);

        CODE_DEFINITIONS.put(
            RegistryCodes.SSR_ARTICLE,
            new CodeDefinition(
                List.of(ssrArticleCodes),
                Collections.emptyList() // Нет сортировки по коллекциям
            )
        );
    }

    public static CodeDefinition getCodeDefinition(RegistryCodes code) {
        return CODE_DEFINITIONS.get(code);
    }
}
