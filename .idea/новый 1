Function<JPAQuery<PaymentAnalyticEntity>, JPAQuery<MyResponseDto>> projectionFunction = query -> {
    QPaymentAnalyticEntity paymentAnalytic = QPaymentAnalyticEntity.paymentAnalyticEntity;
    QPaymentObject paymentObject = QPaymentObject.paymentObject;
    QPaymentObjectSsr paymentObjectSsr = QPaymentObjectSsr.paymentObjectSsr;
    QPaymentSsrArticle ssrArticle = QPaymentSsrArticle.paymentSsrArticle;
    QConfirmationDocument confirmationDocument = QConfirmationDocument.confirmationDocument;

    return query.select(Projections.bean(
            MyResponseDto.class,
            // Основные поля
            paymentAnalytic.id,
            paymentAnalytic.clientId,
            paymentAnalytic.number.as("applicationNumber"),
            paymentAnalytic.status.as("loanFundsRequestStatus"),
            paymentAnalytic.date.as("applicationDate"),
            paymentAnalytic.fundsType.as("fundsType"),
            paymentAnalytic.creditAgreementNumber.as("creditAgreementNumber"),
            paymentAnalytic.creditAgreementDate.as("creditAgreementDate"),
            paymentAnalytic.payerAccount.as("payerAccount"),
            paymentAnalytic.obcAccountFlag.as("obcAccountFlag"),
            paymentAnalytic.trancheIssueDate.as("trancheIssueDate"),
            paymentAnalytic.amount.as("amount"),
            paymentAnalytic.paymentPurpose.as("paymentPurpose"),
            paymentAnalytic.recipientName.as("recipientName"),
            paymentAnalytic.recipientAccount.as("recipientAccount"),
            paymentAnalytic.dvruNumber.as("dvruNumber"),
            paymentAnalytic.dvruDate.as("dvruDate"),
            paymentAnalytic.paymentType.as("paymentType"),
            paymentAnalytic.paymentOrderStatus.as("paymentOrderStatus"),
            // Связанные таблицы
            paymentObject.id.as("paymentObjectId"),
            paymentObjectSsr.article.as("paymentObjectArticle"),
            ssrArticle.code.as("ssrArticleCodes"),
            confirmationDocument.documentNumber.as("confirmationDocumentNumber")
        ))
        .from(paymentAnalytic)
        // Связь с paymentObject
        .leftJoin(paymentAnalytic.paymentObjects, paymentObject)
        // Связь с paymentObjectSsr через paymentObject
        .leftJoin(paymentObject.paymentObjectSsr, paymentObjectSsr)
        // Связь с ssrArticle через paymentObjectSsr
        .leftJoin(paymentObjectSsr.ssrArticles, ssrArticle)
        // Связь с confirmationDocument
        .leftJoin(paymentAnalytic.confirmationDocuments, confirmationDocument);
};

import com.querydsl.core.types.Expression;
import com.querydsl.core.types.dsl.PathBuilder;
import com.querydsl.core.types.dsl.SimpleExpression;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

public class QuerydslProjectionMapper {

    public static <Entity, DTO> List<Expression<?>> mapFieldsToProjections(Class<Entity> entityClass, Class<DTO> dtoClass) {
        List<Expression<?>> projections = new ArrayList<>();

        // Создаем PathBuilder для указанного класса сущности
        PathBuilder<Entity> entityPath = new PathBuilder<>(entityClass, entityClass.getSimpleName().toLowerCase());

        // Проходим по всем методам DTO
        for (Method method : dtoClass.getDeclaredMethods()) {
            String methodName = method.getName();
            if (methodName.startsWith("get")) {
                // Преобразуем имя метода в имя поля (удаляем "get" и делаем первую букву строчной)
                String fieldName = Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);

                try {
                    // Получаем поле QueryDSL по имени
                    SimpleExpression<?> fieldExpression = entityPath.get(fieldName);
                    // Добавляем поле в список проекций
                    projections.add(fieldExpression.as(fieldName));
                } catch (IllegalArgumentException e) {
                    // Если поле не найдено в PathBuilder, можно обработать исключение
                    System.err.println("Field not found for method: " + methodName);
                }
            }
        }

        return projections;
    }
}
public <T> Expression<?>[] mapFieldsToProjections(Class<E> entityClass, Class<T> dtoClass) {
    List<Expression<?>> projections = new ArrayList<>();
    PathBuilder<E> entityPath = new PathBuilder<>(entityClass, entityClass.getSimpleName().toLowerCase());

    for (Method method : dtoClass.getDeclaredMethods()) {
        if (method.getName().startsWith("get")) {
            // Получение имени поля из метода
            String fieldName = Character.toLowerCase(method.getName().charAt(3)) + method.getName().substring(4);
            try {
                // Маппинг поля QueryDSL с алиасом
                Expression<?> fieldExpression = entityPath.get(fieldName);
                projections.add(fieldExpression.as(fieldName));
            } catch (IllegalArgumentException e) {
                System.err.println("Field not found for method: " + method.getName());
            }
        }
    }

    // Возвращаем массив Expression<?>[]
    return projections.toArray(new Expression<?>[0]);
}

public List<String> extractJoinsFromGraph(EntityManager entityManager, String graphName, Class<?> entityClass) {
    EntityGraph<?> entityGraph = entityManager.getEntityGraph(graphName);

    // Список связей (атрибутов)
    List<String> joins = new ArrayList<>();
    for (AttributeNode<?> node : entityGraph.getAttributeNodes()) {
        joins.add(node.getAttributeName());
    }

    return joins;
}
public <E> JPAQuery<E> applyJoinsFromGraph(
    JPAQuery<E> query,
    EntityManager entityManager,
    String graphName,
    EntityPathBase<E> rootEntity
) {
    // Извлекаем связи из графа
    List<String> joins = extractJoinsFromGraph(entityManager, graphName, rootEntity.getType());

    // Применяем `join` для каждой связи
    for (String join : joins) {
        PathBuilder<?> joinPath = new PathBuilder<>(rootEntity.getType(), join);
        query.leftJoin(joinPath);
    }

    return query;
}




