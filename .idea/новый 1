package com.example.repository;

import com.querydsl.jpa.impl.JPAQueryFactory;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.group.Group;
import com.querydsl.core.group.GroupBy;
import com.example.entity.QPaymentAnalyticEntity;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Repository
public class PaymentAnalyticRepository {

    private final JPAQueryFactory queryFactory;
    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    public PaymentAnalyticRepository(javax.persistence.EntityManager entityManager) {
        this.queryFactory = new JPAQueryFactory(entityManager);
    }

    /**
     * Выполняет запрос с динамическими полями (Expression<?>), сортировкой (OrderSpecifier<?>),
     * фильтрацией (Predicate), пагинацией (Pageable) и группировкой.
     * Предполагается, что в expressions присутствуют pa.id, pa.clientId, pa.paymentDocumentId.
     * Возвращает List<Group>.
     */
    public List<Group> fetchAnalyticsGrouped(
            Expression<?>[] expressions,
            List<OrderSpecifier<?>> orderSpecifiers,
            Pageable pageable,
            Predicate predicate,
            boolean needGrouping
    ) {
        Integer limit = (pageable != null && pageable.getPageSize() > 0) ? pageable.getPageSize() : null;
        Integer offset = null;
        if (pageable != null && pageable.getOffset() > 0) {
            long off = pageable.getOffset();
            offset = (off <= Integer.MAX_VALUE) ? (int) off : Integer.MAX_VALUE;
        }

        var query = queryFactory.select(expressions).from(pa);

        if (predicate != null) {
            query.where(predicate);
        }

        if (orderSpecifiers != null && !orderSpecifiers.isEmpty()) {
            query.orderBy(orderSpecifiers.toArray(new OrderSpecifier[0]));
        }

        if (limit != null && limit > 0) {
            query.limit(limit);
        }

        if (offset != null && offset >= 0) {
            query.offset(offset);
        }

        var groupByBuilder = GroupBy.groupBy(pa.id);

        boolean firstAggregator = true;
        for (Expression<?> expr : expressions) {
            if (expr.equals(pa.id)) {
                var aggregator = GroupBy.first(expr).as(expr.toString());
                if (firstAggregator) {
                    groupByBuilder = groupByBuilder.as(aggregator);
                    firstAggregator = false;
                } else {
                    groupByBuilder = groupByBuilder.and(aggregator);
                }
                continue;
            }

            if (expr.equals(pa.clientId) || expr.equals(pa.paymentDocumentId)) {
                var aggregator = GroupBy.first(expr).as(expr.toString());
                if (firstAggregator) {
                    groupByBuilder = groupByBuilder.as(aggregator);
                    firstAggregator = false;
                } else {
                    groupByBuilder = groupByBuilder.and(aggregator);
                }
                continue;
            }

            // Если needGrouping=true, считаем, что это может быть коллекционное поле -> list
            // Иначе first.
            var aggregator = needGrouping ? GroupBy.list(expr) : GroupBy.first(expr);
            aggregator = aggregator.as(expr.toString());
            if (firstAggregator) {
                groupByBuilder = groupByBuilder.as(aggregator);
                firstAggregator = false;
            } else {
                groupByBuilder = groupByBuilder.and(aggregator);
            }
        }

        if (firstAggregator) {
            groupByBuilder = groupByBuilder.as(GroupBy.first(pa.id).as("id"));
        }

        Map<Long, Group> resultMap = query.transform(groupByBuilder);
        return new ArrayList<>(resultMap.values());
    }
}




Ниже представлен улучшенный вариант сервисного слоя, учитывающий принципы SOLID, улучшенную тестируемость и гибкость. Изменения:

1. **Отделение логики сортировки**:  
   Вместо того, чтобы держать логику сортировки в сервисе, она инкапсулирована в отдельном сервисе/компоненте `SortingService`, который использует `SortOrderBuilder`. Это упростит тестирование: можно отдельно тестировать логику формирования сортировки, подавая разные входные данные и проверяя выходные `OrderSpecifier<?>`.

2. **Отделение логики маппинга**:  
   Создан отдельный маппер `PaymentAnalyticMapper` для преобразования `List<Group>` в `List<PaymentAnalyticDto>` и сборки коллекций в объекты DTO. Это соответствует принципу единственной ответственности (SRP). Теперь `PaymentAnalyticService` не знает деталей о том, как именно маппить поля или коллекции, его задача — orchestrate процесс: получить данные от репозитория, запросить у `SortingService` сортировку, передать их мапперу для преобразования. Это упрощает тестирование, потому что можно отдельно тестировать маппер и отдельно тестировать сервис.

3. **S.O.L.I.D.**:  
   - **S (Single Responsibility)**: Сервис отвечает за общий поток: получить параметры, вызвать репозиторий, отсортировать, замаппить. Логику сортировки и маппинга вынесли в отдельные классы.  
   - **O (Open-Closed)**: Добавить новый вид сортировки или изменить маппинг можно, не меняя код сервисного слоя.  
   - **L (Liskov Substitution)**: Не нарушается, так как мы не меняем иерархии.  
   - **I (Interface Segregation)**: Можно при необходимости выделить интерфейсы для `SortingService`, `PaymentAnalyticMapper`.  
   - **D (Dependency Inversion)**: Сервис зависит от абстракций (например, интерфейсов маппера и сортировщика, если их выделить), а не от конкретных реализаций.

4. **Тестируемость**:  
   - Можно замокать `SortingService` и `PaymentAnalyticMapper` и тестировать `PaymentAnalyticService` изолированно.  
   - Можно отдельно протестировать `PaymentAnalyticMapper` и `SortingService`.

### Код примера

#### PaymentAnalyticMapper.java
```java
package com.example.mapper;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.PaymentAnalyticDto;
import com.example.dto.PaymentAnalyticDto.PaymentObjectEntityDto;
import com.example.dto.PaymentAnalyticDto.PaymentObjectSsrEntityDto;
import com.example.dto.PaymentAnalyticDto.PaymentSsrArticleDto;
import com.example.entity.PaymentAnalyticStatus;
import com.example.entity.PaymentType;
import com.example.entity.FundsType;
import com.example.entity.QPaymentAnalyticEntity;
import com.querydsl.core.group.Group;
import com.querydsl.core.types.Expression;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class PaymentAnalyticMapper {

    private static final QPaymentAnalyticEntity pa = QPaymentAnalyticEntity.paymentAnalyticEntity;

    /**
     * Маппит результаты выборки (List<Group>) в List<PaymentAnalyticDto>.
     * @param fields выбранные поля (содержит ID, CLIENT_ID, PAYMENT_DOCUMENT_ID)
     * @param groups результат запроса
     * @param needGrouping true, если нужны коллекции
     */
    public List<PaymentAnalyticDto> mapGroupsToDto(Set<RegistryCodes> fields, List<Group> groups, boolean needGrouping) {
        List<PaymentAnalyticDto> dtos = new ArrayList<>();

        for (Group g : groups) {
            PaymentAnalyticDto dto = new PaymentAnalyticDto();
            dto.setId((Long) g.get(pa.id));
            dto.setClientId((Long) g.get(pa.clientId));
            dto.setPaymentDocumentId((Long) g.get(pa.paymentDocumentId));

            List<String> paymentObjectNames = null;
            List<String> paymentObjectProjectNames = null;
            List<String> ssrArticleCodes = null;

            // Проходим по полям и маппим скалярные значения
            for (RegistryCodes code : fields) {
                CodeDefinition cd = RegistryCodeDefinitions.getCodeDefinition(code);
                if (cd == null) continue;

                for (Expression<?> expr : cd.getProjections()) {
                    Object value = g.get(expr);
                    if (value == null) continue;

                    switch (code) {
                        case NUMBER -> dto.setNumber((Integer) value);
                        case DATE -> dto.setDate((LocalDate) value);
                        case LOAN_FUNDS_REQUEST_STATUS -> dto.setStatus((PaymentAnalyticStatus) value);
                        case FUNDS_TYPE -> dto.setFundsType((FundsType) value);
                        case CREDIT_AGREEMENT -> {
                            if (expr.equals(pa.creditAgreementNumber)) {
                                dto.setCreditAgreementNumber((String) value);
                            } else if (expr.equals(pa.creditAgreementDate)) {
                                dto.setCreditAgreementDate((LocalDate) value);
                            }
                        }
                        case PAYER_ACCOUNT -> {
                            if (expr.equals(pa.payerAccount)) {
                                dto.setPayerAccount((String) value);
                            } else if (expr.equals(pa.obcAccountFlag)) {
                                dto.setObcAccountFlag((Boolean) value);
                            }
                        }
                        case TRANCHE_ISSUE_DATE -> dto.setTrancheIssueDate((LocalDate) value);
                        case AMOUNT -> dto.setAmount((BigDecimal) value);
                        case PAYMENT_PURPOSE -> dto.setPaymentPurpose((String) value);
                        case RECIPIENT_NAME -> dto.setRecipientName((String) value);
                        case RECIPIENT_ACCOUNT -> dto.setRecipientAccount((String) value);
                        case DVRU -> {
                            if (expr.equals(pa.dvruNumber)) {
                                dto.setDvruNumber((String) value);
                            } else if (expr.equals(pa.dvruDate)) {
                                dto.setDvruDate((LocalDate) value);
                            }
                        }
                        case PAYMENT_TYPE -> dto.setPaymentType((PaymentType) value);
                        case PAYMENT_OBJECT -> {
                            // Коллекции имён и projectName
                            if (expr.toString().contains("projectName")) {
                                paymentObjectProjectNames = (List<String>) value;
                            } else if (expr.toString().contains("name")) {
                                paymentObjectNames = (List<String>) value;
                            }
                        }
                        case SSR_ARTICLE -> {
                            ssrArticleCodes = (List<String>) value;
                        }
                        default -> {
                            // Остальные игнорируем
                        }
                    }
                }
            }

            // Сборка paymentObjects из списков
            dto.setPaymentObjects(buildPaymentObjects(paymentObjectNames, paymentObjectProjectNames, ssrArticleCodes));

            dtos.add(dto);
        }

        return dtos;
    }

    /**
     * Строим список PaymentObjectEntityDto из списков строк.
     */
    private List<PaymentObjectEntityDto> buildPaymentObjects(List<String> names, List<String> projectNames, List<String> ssrCodes) {
        if (names == null || projectNames == null) {
            return null;
        }

        List<PaymentObjectEntityDto> objects = new ArrayList<>();
        int size = Math.min(names.size(), projectNames.size());
        for (int i = 0; i < size; i++) {
            PaymentObjectEntityDto obj = new PaymentObjectEntityDto();
            obj.setName(names.get(i));
            obj.setProjectName(projectNames.get(i));

            PaymentObjectSsrEntityDto ssr = new PaymentObjectSsrEntityDto();
            ssr.setPaymentSsrArticles(buildSsrArticles(ssrCodes));
            obj.setPaymentObjectSsr(ssr);

            objects.add(obj);
        }

        return objects.isEmpty() ? null : objects;
    }

    /**
     * Строим список PaymentSsrArticleDto из списка кодов.
     */
    private List<PaymentSsrArticleDto> buildSsrArticles(List<String> codes) {
        if (codes == null) return null;
        List<PaymentSsrArticleDto> articles = new ArrayList<>();
        for (String c : codes) {
            PaymentSsrArticleDto a = new PaymentSsrArticleDto();
            a.setCode(c);
            articles.add(a);
        }
        return articles.isEmpty() ? null : articles;
    }
}
```

#### SortingService.java
```java
package com.example.service;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.SortingDto;
import com.example.util.SortOrderBuilder;
import com.querydsl.core.types.OrderSpecifier;

import java.util.List;

public class SortingService {

    /**
     * Возвращает список OrderSpecifier для сортировки на основании SortingDto.
     */
    public List<OrderSpecifier<?>> getOrderSpecifiers(SortingDto sortingDto) {
        String sortField = sortingDto != null ? sortingDto.getSortField() : null;
        Boolean sortDescending = sortingDto != null ? sortingDto.getSortDescending() : Boolean.TRUE;

        return SortOrderBuilder.buildOrderSpecifiers(sortField, sortDescending);
    }
}
```

#### PaymentAnalyticService.java
```java
package com.example.service;

import com.example.config.CodeDefinition;
import com.example.config.RegistryCodes;
import com.example.config.RegistryCodeDefinitions;
import com.example.dto.PaymentAnalyticDto;
import com.example.dto.SortingDto;
import com.example.entity.QPaymentAnalyticEntity;
import com.example.mapper.PaymentAnalyticMapper;
import com.example.repository.PaymentAnalyticRepository;
import com.querydsl.core.group.Group;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.Predicate;
import com.querydsl.core.types.OrderSpecifier;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
public class PaymentAnalyticService {

    private final PaymentAnalyticRepository repository;
    private final SortingService sortingService;
    private final PaymentAnalyticMapper mapper;

    public PaymentAnalyticService(PaymentAnalyticRepository repository, SortingService sortingService, PaymentAnalyticMapper mapper) {
        this.repository = repository;
        this.sortingService = sortingService;
        this.mapper = mapper;
    }

    public List<PaymentAnalyticDto> getPaymentAnalytics(
            List<RegistryCodes> fields,
            SortingDto sortingDto,
            Pageable pageable,
            Predicate predicate
    ) {
        boolean needGrouping = fields.contains(RegistryCodes.PAYMENT_OBJECT)
                            || fields.contains(RegistryCodes.SSR_ARTICLE);

        // Всегда добавляем обязательные поля
        Set<RegistryCodes> extendedFields = new LinkedHashSet<>(fields);
        extendedFields.add(RegistryCodes.ID);
        extendedFields.add(RegistryCodes.CLIENT_ID);
        extendedFields.add(RegistryCodes.PAYMENT_DOCUMENT_ID);

        // Формируем projections
        List<Expression<?>> exprs = new ArrayList<>();
        for (RegistryCodes code : extendedFields) {
            CodeDefinition cd = RegistryCodeDefinitions.getCodeDefinition(code);
            if (cd != null && !cd.getProjections().isEmpty()) {
                exprs.addAll(cd.getProjections());
            }
        }

        // Получаем сортировку от SortingService
        List<OrderSpecifier<?>> orderSpecifiers = sortingService.getOrderSpecifiers(sortingDto);

        Expression<?>[] expressionsArray = exprs.toArray(new Expression[0]);
        List<Group> groups = repository.fetchAnalyticsGrouped(
                expressionsArray,
                orderSpecifiers,
                pageable,
                predicate,
                needGrouping
        );

        // Маппим результаты в DTO
        return mapper.mapGroupsToDto(extendedFields, groups, needGrouping);
    }
}
```

---

**Комментарии:**

- **PaymentAnalyticService**:  
  - Зависит от `PaymentAnalyticRepository` (получение данных),  
  - `SortingService` (получение списков сортировок),  
  - `PaymentAnalyticMapper` (маппинг результатов).
  
  Так мы можем легко замокать эти зависимости в тестах и протестировать логику `PaymentAnalyticService` изолированно.

- **SortingService**:  
  Использует `SortOrderBuilder` для получения `OrderSpecifier`. Можно добавить интерфейс для `SortingService`, чтобы при необходимости использовать разные реализации.

- **PaymentAnalyticMapper**:  
  Инкапсулирует всю логику маппинга `Group` в `PaymentAnalyticDto`. Можно тестировать отдельно: подать на вход тестовые `Group` и проверить корректность сформированных DTO.

Таким образом, код стал более модульным, соответствующим принципам SOLID, упрощенным для тестирования и расширяемости.




+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
import com.querydsl.core.types.Order;
import com.querydsl.core.types.OrderSpecifier;

import java.util.ArrayList;
import java.util.List;

public class SortOrderBuilder {
    
    // Поле по умолчанию для сортировки
    private static final OrderSpecifier<?> DEFAULT_ORDER = QPaymentAnalyticEntity.paymentAnalyticEntity.date.desc();
    
    /**
     * Формируем список сортировок на основании входного сортировочного запроса.
     * @param sortField        Строковое значение поля сортировки, соответствует одному из RegistryCodes (или null)
     * @param sortDescending   Если true - сортируем по убыванию, иначе по возрастанию.
     * @return список OrderSpecifier для применения в запросе QueryDSL
     */
    public static List<OrderSpecifier<?>> buildOrderSpecifiers(String sortField, Boolean sortDescending) {
        List<OrderSpecifier<?>> orderSpecifiers = new ArrayList<>();

        RegistryCodes code = null;
        if (sortField != null && !sortField.isBlank()) {
            try {
                code = RegistryCodes.valueOf(sortField.toUpperCase());
            } catch (IllegalArgumentException e) {
                // Если не удалось сопоставить sortField с RegistryCodes, code остаётся null
            }
        }
        
        // Если код не найден или не задан, применяем сортировку по умолчанию
        if (code == null) {
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        CodeDefinition definition = RegistryCodeDefinitions.getCodeDefinition(code);
        if (definition == null) {
            // Если для данного code нет определения - сортируем по умолчанию
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        // Берём orderSpecifiers из определения
        List<OrderSpecifier<?>> baseOrderSpecifiers = definition.getOrderSpecifiers();
        if (baseOrderSpecifiers.isEmpty()) {
            // Если нет явно заданных сортировок в CodeDefinition, сортируем по умолчанию
            orderSpecifiers.add(DEFAULT_ORDER);
            return orderSpecifiers;
        }

        // Инвертируем направление при необходимости
        if (Boolean.TRUE.equals(sortDescending)) {
            // Если нужно сортировать по убыванию, то для каждого поля применяем descending
            for (OrderSpecifier<?> os : baseOrderSpecifiers) {
                orderSpecifiers.add(os.getTarget().desc());
            }
        } else {
            // Если нужно сортировать по возрастанию - используем baseOrderSpecifiers как есть, предполагая что они уже asc.
            // Если в базе CodeDefinition хранились Asc, то просто добавляем их.
            // Если нужно более гибко, можно хранить исходные поля без OrderSpecifier и здесь формировать нужный Order.
            for (OrderSpecifier<?> os : baseOrderSpecifiers) {
                orderSpecifiers.add(os.getTarget().asc());
            }
        }

        return orderSpecifiers;
    }
}






package com.example.config;

import com.querydsl.core.group.GroupBy;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.dsl.ComparableExpressionBase;
import com.querydsl.core.types.dsl.DatePath;
import com.querydsl.core.types.dsl.NumberExpression;
import com.querydsl.core.types.dsl.StringExpression;
import com.example.entity.QPaymentAnalyticEntity;
import com.example.entity.QPaymentObjectEntityBo;
import com.example.entity.QPaymentObjectsSsrEntityBo;
import com.example.entity.QPaymentSsrArticleEntityBo;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.querydsl.core.group.GroupBy.list;

public class RegistryCodeDefinitions {

    private static final QPaymentAnalyticEntity paymentAnalyticEntity = QPaymentAnalyticEntity.paymentAnalyticEntity;
    private static final QPaymentObjectEntityBo paymentObjectEntityBo = QPaymentObjectEntityBo.paymentObjectEntityBo;
    private static final QPaymentObjectsSsrEntityBo paymentObjectsSsrEntityBo = QPaymentObjectsSsrEntityBo.paymentObjectsSsrEntityBo;
    private static final QPaymentSsrArticleEntityBo paymentSsrArticleEntityBo = QPaymentSsrArticleEntityBo.paymentSsrArticleEntityBo;

    private static final Map<RegistryCodes, CodeDefinition> CODE_DEFINITIONS = new HashMap<>();

    static {
        // Обязательные поля
        CODE_DEFINITIONS.put(
            RegistryCodes.ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.id),
                List.of(paymentAnalyticEntity.id.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.CLIENT_ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.clientId),
                List.of(paymentAnalyticEntity.clientId.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_DOCUMENT_ID,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentDocumentId),
                List.of(paymentAnalyticEntity.paymentDocumentId.asc())
            )
        );

        // Примитивные поля
        CODE_DEFINITIONS.put(
            RegistryCodes.NUMBER,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.number),
                List.of(paymentAnalyticEntity.number.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.date),
                List.of(paymentAnalyticEntity.date.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.LOAN_FUNDS_REQUEST_STATUS,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.status),
                List.of(paymentAnalyticEntity.status.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.FUNDS_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.fundsType),
                List.of(paymentAnalyticEntity.fundsType.asc())
            )
        );

        // CREDIT_AGREEMENT: два поля (номер, дата)
        CODE_DEFINITIONS.put(
            RegistryCodes.CREDIT_AGREEMENT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.creditAgreementNumber, paymentAnalyticEntity.creditAgreementDate),
                List.of(paymentAnalyticEntity.creditAgreementNumber.asc(), paymentAnalyticEntity.creditAgreementDate.asc())
            )
        );

        // PAYER_ACCOUNT: два поля (payerAccount, obcAccountFlag)
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYER_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.payerAccount, paymentAnalyticEntity.obcAccountFlag),
                List.of(paymentAnalyticEntity.payerAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.TRANCHE_ISSUE_DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.trancheIssueDate),
                List.of(paymentAnalyticEntity.trancheIssueDate.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.AMOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.amount),
                List.of(paymentAnalyticEntity.amount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_PURPOSE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentPurpose),
                List.of(paymentAnalyticEntity.paymentPurpose.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_NAME,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientName),
                List.of(paymentAnalyticEntity.recipientName.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientAccount),
                List.of(paymentAnalyticEntity.recipientAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentType),
                List.of(paymentAnalyticEntity.paymentType.asc())
            )
        );

        // DVRU: два поля (dvruNumber, dvruDate)
        CODE_DEFINITIONS.put(
            RegistryCodes.DVRU,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.dvruNumber, paymentAnalyticEntity.dvruDate),
                List.of(paymentAnalyticEntity.dvruNumber.asc(), paymentAnalyticEntity.dvruDate.asc())
            )
        );

        // PAYMENT_OBJECT: Коллекция paymentObjects (name, projectName).
        // Возвращаем List<String> для имен и List<String> для projectName
        Expression<List<String>> paymentObjectNames = list(paymentAnalyticEntity.paymentObjects.any().name);
        Expression<List<String>> paymentObjectProjectNames = list(paymentAnalyticEntity.paymentObjects.any().projectName);

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_OBJECT,
            new CodeDefinition(
                List.of(paymentObjectNames, paymentObjectProjectNames),
                Collections.emptyList()
            )
        );

        // SSR_ARTICLE: Коллекция кодов статей
        Expression<List<String>> ssrArticleCodes = list(paymentAnalyticEntity.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);

        CODE_DEFINITIONS.put(
            RegistryCodes.SSR_ARTICLE,
            new CodeDefinition(
                List.of(ssrArticleCodes),
                Collections.emptyList()
            )
        );
    }

    public static CodeDefinition getCodeDefinition(RegistryCodes code) {
        return CODE_DEFINITIONS.get(code);
    }
}





import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;

import java.util.List;

/**
 * CodeDefinition будет хранить Expressions для проекций и OrderSpecifiers для сортировки.
 * В дальнейшем мы будем наполнять эти структуры конкретными значениями для каждого RegistryCodes.
 */
public class CodeDefinition {
    private final List<Expression<?>> projections;
    private final List<OrderSpecifier<?>> orderSpecifiers;

}

    public CodeDefinition(List<Expression<?>> projections, List<OrderSpecifier<?>> orderSpecifiers) {
        this.projections = projections;
        this.orderSpecifiers = orderSpecifiers;
    }

    public List<Expression<?>> getProjections() {
        return projections;
    }

    public List<OrderSpecifier<?>> getOrderSpecifiers() {
        return orderSpecifiers;
    }
import com.querydsl.core.group.GroupBy;
import com.querydsl.core.types.Expression;
import com.querydsl.core.types.OrderSpecifier;
import com.querydsl.core.types.dsl.ComparableExpressionBase;
import com.querydsl.core.types.dsl.DatePath;
import com.querydsl.core.types.dsl.NumberExpression;
import com.querydsl.core.types.dsl.StringExpression;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.querydsl.core.group.GroupBy.list;

public class RegistryCodeDefinitions {

    private static final QPaymentAnalyticEntity paymentAnalyticEntity = QPaymentAnalyticEntity.paymentAnalyticEntity;
    private static final QPaymentObjectEntityBo paymentObjectEntityBo = QPaymentObjectEntityBo.paymentObjectEntityBo;
    private static final QPaymentObjectsSsrEntityBo paymentObjectsSsrEntityBo = QPaymentObjectsSsrEntityBo.paymentObjectsSsrEntityBo;
    private static final QPaymentSsrArticleEntityBo paymentSsrArticleEntityBo = QPaymentSsrArticleEntityBo.paymentSsrArticleEntityBo;

    private static final Map<RegistryCodes, CodeDefinition> CODE_DEFINITIONS = new HashMap<>();

    static {
        // Пример для простых полей
        CODE_DEFINITIONS.put(
            RegistryCodes.NUMBER,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.number),
                List.of(paymentAnalyticEntity.number.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.date),
                List.of(paymentAnalyticEntity.date.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.LOAN_FUNDS_REQUEST_STATUS,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.status),
                List.of(paymentAnalyticEntity.status.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.FUNDS_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.fundsType),
                List.of(paymentAnalyticEntity.fundsType.asc())
            )
        );

        // CREDIT_AGREEMENT: два поля (номер, дата)
        CODE_DEFINITIONS.put(
            RegistryCodes.CREDIT_AGREEMENT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.creditAgreementNumber, paymentAnalyticEntity.creditAgreementDate),
                List.of(paymentAnalyticEntity.creditAgreementNumber.asc(), paymentAnalyticEntity.creditAgreementDate.asc())
            )
        );

        // PAYER_ACCOUNT: два поля (payerAccount, obcAccountFlag)
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYER_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.payerAccount, paymentAnalyticEntity.obcAccountFlag),
                List.of(paymentAnalyticEntity.payerAccount.asc()) // сортируем по payerAccount
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.TRANCHE_ISSUE_DATE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.trancheIssueDate),
                List.of(paymentAnalyticEntity.trancheIssueDate.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.AMOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.amount),
                List.of(paymentAnalyticEntity.amount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_PURPOSE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentPurpose),
                List.of(paymentAnalyticEntity.paymentPurpose.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_NAME,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientName),
                List.of(paymentAnalyticEntity.recipientName.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.RECIPIENT_ACCOUNT,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.recipientAccount),
                List.of(paymentAnalyticEntity.recipientAccount.asc())
            )
        );

        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_TYPE,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.paymentType),
                List.of(paymentAnalyticEntity.paymentType.asc())
            )
        );

        // DVRU: два поля (dvruNumber, dvruDate)
        CODE_DEFINITIONS.put(
            RegistryCodes.DVRU,
            new CodeDefinition(
                List.of(paymentAnalyticEntity.dvruNumber, paymentAnalyticEntity.dvruDate),
                List.of(paymentAnalyticEntity.dvruNumber.asc(), paymentAnalyticEntity.dvruDate.asc())
            )
        );

        // PAYMENT_OBJECT: Коллекция paymentObjects с полями name, projectName.
        // Для агрегации используем list(...) из GroupBy.
        Expression<List<String>> paymentObjectNames = list(paymentAnalyticEntity.paymentObjects.any().name);
        Expression<List<String>> paymentObjectProjectNames = list(paymentAnalyticEntity.paymentObjects.any().projectName);

        // Здесь сортировка для коллекций не предусмотрена, оставляем пустой список
        CODE_DEFINITIONS.put(
            RegistryCodes.PAYMENT_OBJECT,
            new CodeDefinition(
                List.of(paymentObjectNames, paymentObjectProjectNames),
                Collections.emptyList()
            )
        );

        // SSR_ARTICLE: Коллекция кодов articles через paymentObjectSsr -> paymentSsrArticles
        Expression<List<String>> ssrArticleCodes = list(paymentAnalyticEntity.paymentObjects.any().paymentObjectSsr.paymentSsrArticles.any().code);

        CODE_DEFINITIONS.put(
            RegistryCodes.SSR_ARTICLE,
            new CodeDefinition(
                List.of(ssrArticleCodes),
                Collections.emptyList() // Нет сортировки по коллекциям
            )
        );
    }

    public static CodeDefinition getCodeDefinition(RegistryCodes code) {
        return CODE_DEFINITIONS.get(code);
    }
}
